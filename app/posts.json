[
    {
        "id": 8,
        "title": "從點一個 URL 到看到頁面中間發生了什麼事？(下集）",
        "body": "<p></p>\\n<p>上一集在<a href=\"https: //jennycodes.me/posts/%E5%BE%9E%E9%BB%9E%E4%B8%80%E5%80%8B-url-%E5%88%B0%E7%9C%8B%E5%88%B0%E9%A0%81%E9%9D%A2%E4%B8%AD%E9%96%93%E7%99%BC%E7%94%9F%E4%BA%86%E4%BB%80%E9%BA%BC%E4%BA%8B%E4%B8%8A%E9%9B%86\" target=\"_blank\">這裡</a>。</p>\\n<h3>三、應用程式處理請求，打包成 HTTP 回應</h3>\\n<p><em class=\"markup--em markup--p-em\">關鍵字：Routing, MVC, ORM, Action Pack, Active Record</em></p>\\n<p>請求流向：routing → controller action → model ( ←→ database) → controller → view → controller → server</p>\\n<p>Rails 的設計遵守 MVC (Model, View, Controller)* 架構，會先由<strong class=\"markup--strong markup--p-strong\">路由</strong>設定判斷這個請求應該要轉發給哪一個 <strong class=\"markup--strong markup--p-strong\">controller action</strong>。Controller 接收了請求之後，會依照需求與資料庫 (體現在 <strong class=\"markup--strong markup--p-strong\">model</strong> 中) 互動，並且從 <strong class=\"markup--strong markup--p-strong\">view </strong>拿 html template，打包成 http response 傳回瀏覽器。</p>\\n<p>Rails 使用 <a href=\"https://github.com/rails/rails/tree/master/actionpack\" data-href=\"https://github.com/rails/rails/tree/master/actionpack\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">Action Pack</a> 與 <a href=\"https://github.com/rails/rails/tree/master/activerecord\" data-href=\"https://github.com/rails/rails/tree/master/activerecord\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">Active Record</a> 來實作這些機制，下面也會一併介紹。</p>\\n<p>*補充：最近剛好看到一篇說明 Rails（與其他大家認為是 MVC 的後端框架）其實不是 MVC 的文章，耐人尋味：<a href=\"http://blog.turn.tw/?p=1539\" data-href=\"http://blog.turn.tw/?p=1539\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">MVC 是一個巨大誤會</a></p>\\n<h4>路由 (Routing)</h4>\\n<p>路由是請求進入應用程式的把關人，負責辨識請求的 URL，將請求轉給對應的 controller action，還會順便處理網址內的參數，把參數放進 params 中一起交給 controller 處理，是個盡責的守門人來著。可以把路由想像成 2.0 版的霍格華滋分類帽，除了依照每個新進學生的特性分派他們進入不同學院，還會把學生的身家背景一併整理交給學院長。</p>\\n<p>Rails 中是由 routes.rb 檔案管理應用程式的路由設定，值得一提的是有預設的 <strong class=\"markup--strong markup--p-strong\">Resource Routing</strong>。</p>\\n<blockquote>Resource routing allows you to quickly declare all of the common routes for a given resourceful controller. Instead of declaring separate routes for your <code class=\"markup--code markup--blockquote-code\">index</code>, <code class=\"markup--code markup--blockquote-code\">show</code>, <code class=\"markup--code markup--blockquote-code\">new</code>, <code class=\"markup--code markup--blockquote-code\">edit</code>, <code class=\"markup--code markup--blockquote-code\">create</code>, <code class=\"markup--code markup--blockquote-code\">update</code>and <code class=\"markup--code markup--blockquote-code\">destroy</code> actions, a resourceful route declares them in a single line of code.</blockquote>\\n<p>摘錄自 <a href=\"https://guides.rubyonrails.org/routing.html\" data-href=\"https://guides.rubyonrails.org/routing.html\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">Rails Routing from the Outside In</a>。</p>\\n<p>一般常見的 http 請求有 <code class=\"markup--code markup--p-code\">GET</code>, <code class=\"markup--code markup--p-code\">POST</code>, <code class=\"markup--code markup--p-code\">PATCH</code>, <code class=\"markup--code markup--p-code\">PUT</code> and <code class=\"markup--code markup--p-code\">DELETE</code>這幾種，每一種方法都是要對請求的對象（resource）進行特定操作。既然這些操作如此常見，那麼每次都分別定義就太不符合 DRY (Don’t Repeat Yourself) 的原則了。所以，一個 resourceful route 提供這些 http verbs 與 controller action 之間的對應關係，而通常這些 controller action 們也會直接對應到資料庫的 CRUD (Create, Read, Update, Delete) 操作。</p>\\n<p>比如說，今天在檔案內容是</p>\\n<pre># config/routes.rb</pre>\\n<pre>Rails.application.routes.draw do<br>  resources :posts<br>end</pre>\\n<p>在終端機打 <code class=\"markup--code markup--p-code\">$rails routes</code> 會出現這個應用程式的所有路由，這時候你會看到單單這一行宣告會出現下面這些：</p>\\n<pre><strong class=\"markup--strong markup--pre-strong\">Prefix     Verb   URI Pattern                  Controller#Action</strong></pre>\\n<pre>root       GET    /                            posts#index</pre>\\n<pre>posts      GET    /posts(.:format)             posts#index</pre>\\n<pre>           POST   /posts(.:format)             posts#create</pre>\\n<pre>new_post   GET    /posts/new(.:format)         posts#new</pre>\\n<pre>edit_post  GET    /posts/:id/edit(.:format)    posts#edit</pre>\\n<pre>post       GET    /posts/:id(.:format)         posts#show</pre>\\n<pre>           PATCH  /posts/:id(.:format)         posts#update</pre>\\n<pre>           PUT    /posts/:id(.:format)         posts#update</pre>\\n<pre>           DELETE /posts/:id(.:format)         posts#destroy</pre>\\n<p>當一個請求的 URL 是 <code class=\"markup--code markup--p-code\">posts/3, method=GET</code> 時，Rails 路由器看到 <code class=\"markup--code markup--p-code\">resources :posts</code>，就會把請求送到 <code class=\"markup--code markup--p-code\">posts#show</code>，並將 params[:id] 中的參數設為 3。如果沒有使用 resourceful routing，則我們必須單獨定義這個動作，例如 <code class=\"markup--code markup--p-code\">get 'posts/:id', :to =&gt; 'posts#show'</code>。</p>\\n<p>想看更完整又深入淺出的解釋與精美示意圖的話可以來看看這篇 <a href=\"https://railsbook.tw/chapters/11-routes.html\" data-href=\"https://railsbook.tw/chapters/11-routes.html\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">為你自己學 Ruby on Rails</a>。</p>\\n<p>所以現在我們的 https://jennycodes.herokuapp.com 請求到了路由，在 routes.rb 檔案中有一行是<code class=\"markup--code markup--p-code\">root 'posts#index'</code>，代表路由會將對首頁的請求送到 PostController 的 index action，於是我們現在來看 controller。</p>\\n<h4>控制器 (Controller)</h4>\\n<p>Controller 在應用程式中，大概是一個風光程度僅次於分類帽（路由）的角色。請求被送過來之後，到產生回應送回去這中間的所有過程都歸它管了。Controller 會負責去操作資料庫、或是串接外部 API (跟外站要資料)、 跟 View 要 http template，然後進行打包 http response 的工作。</p>\\n<p>Rails 中每個 controller 是一個 ruby class，裡面的 method 就是一個個 controller method。在我們的例子中，請求現在已經被轉到 PostController 中的 index 了，先來看看裡面長什麼樣子。</p>\\n<pre># app/controllers/posts_controller.rb</pre>\\n<pre>class PostsController &lt; ApplicationController<br>  <br>  def index    <br>    @posts = Post.published.order('created_at DESC')  <br>  end</pre>\\n<pre>  ...(略）</pre>\\n<pre>end</pre>\\n<p>（完整版可以看<a href=\"https://github.com/jing-jenny-shih/jenny-codes/blob/master/app/controllers/posts_controller.rb\" data-href=\"https://github.com/jing-jenny-shih/jenny-codes/blob/master/app/controllers/posts_controller.rb\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">這裡</a>）</p>\\n<p>在這個簡單範例中，index 做了兩件事情：1. 去資料庫拿 <code class=\"markup--code markup--p-code\">Post</code> 資料表的資料，2. 存進實例變數 <code class=\"markup--code markup--p-code\">@posts</code> 中。一與二分別是跟 Model 與 View 的互動，於是我們現在先來看看 Model。</p>\\n<h4>模型 (Model)</h4>\\n<p>Rails 的模型是資料庫的代表，一般來說，每個資料表都會有自己對應的模型，就像各國大使一樣，我們要在應用程式中操作資料表，或是設計資料表之間的關聯性（associations），都是交付它。Rails 怎麼做到的呢？</p>\\n<p><strong class=\"markup--strong markup--p-strong\">物件關聯對應 Object Relational Mapping (ORM)</strong></p>\\n<blockquote>\\n<strong class=\"markup--strong markup--blockquote-strong\">物件關聯對映</strong>是一種程式設計技術，用於實現物件導向程式語言裡不同類型系統的資料之間的轉換。</blockquote>\\n<p>節錄自<a href=\"https://zh.wikipedia.org/wiki/%E5%AF%B9%E8%B1%A1%E5%85%B3%E7%B3%BB%E6%98%A0%E5%B0%84\" data-href=\"https://zh.wikipedia.org/wiki/%E5%AF%B9%E8%B1%A1%E5%85%B3%E7%B3%BB%E6%98%A0%E5%B0%84\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">維基百科</a>。</p>\\n<p>好的，我們還是不懂。</p>\\n<p>要理解 ORM，就要先理解現在我們大多數使用的語言都是物件導向語言（Object Oriented Programming）(Ruby 的特色就是<a href=\"http://rubylearning.com/blog/2010/09/27/almost-everything-is-an-object-and-everything-is-almost-an-object/\" data-href=\"http://rubylearning.com/blog/2010/09/27/almost-everything-is-an-object-and-everything-is-almost-an-object/\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">所有東西都會被衡量成物件！</a>)，而資料庫（這邊討論的是關聯式資料庫）的特徵雖然跟 OOP 的物件很像，但是卻有本質上的不同。ORM 的出現就像是翻譯人員，提供一個抽象的介面讓彼此溝通，這樣做有幾個優點：</p>\\n<ol>\\n<li name=\"9645\" id=\"9645\" class=\"graf graf--li graf-after--p\">開發人員可以直接用 OOP (在本例中，是 Ruby) 操作資料庫，而不用接觸到資料庫（SQL）語言，省時省力。</li>\\n<li name=\"790a\" id=\"790a\" class=\"graf graf--li graf-after--li\">因為不是直接寫資料庫語言，所以如果需要更換資料庫（比如說從 SQLite 換成 MySQL），原本的程式碼也不用改。</li>\\n<li name=\"22e7\" id=\"22e7\" class=\"graf graf--li graf-after--li\">比較容易理解。</li>\\n</ol>\\n<p>其實還有其他優點，現在只是舉我自己目前最有感的。Rails 的 ORM 讓我們只要定義好模型類別，就可以在程式碼中使用，比如現在我們的資料庫裡有 <code class=\"markup--code markup--p-code\">posts</code>這張表，而我們在專案資料夾路徑 app/models/ 新增一個 <code class=\"markup--code markup--p-code\">post.rb</code>檔案：</p>\\n<pre># app/models/post.rb</pre>\\n<pre>class Post &lt; ApplicationRecord<br>end</pre>\\n<p>在 controller 中，就可以呼叫 <code class=\"markup--code markup--p-code\">Post.all</code> 來取得 posts 資料表的所有資料了，或是可以在 <code class=\"markup--code markup--p-code\">post.rb</code>中增加一些定義或是方法，來對資料庫做更進階的操作，像剛剛的例子 <code class=\"markup--code markup--p-code\">@posts = Post.published.order(‘created_at DESC’)</code>等式右半邊可以翻譯成「找到狀態是已上架 (published) 的文章，並以創立日期 (created_at) 由新往舊排 (DESC)」。</p>\\n<p>而這個查詢結果，會被存進 <code class=\"markup--code markup--p-code\">@posts</code>，然後帶進 View 中。</p>\\n<h4>畫面 (View)</h4>\\n<p>隨著心理學的不斷推展，View 的重要性，也與日俱增。怎麼說呢？傳統俗諺告訴我們人不可貌相，西洋文化也有 Don’t judge a book by its cover 的諄諄教誨，但是心理學的實驗在在證實了<a href=\"https://www.psychologytoday.com/intl/blog/subliminal/201206/how-we-are-judged-our-appearance\" data-href=\"https://www.psychologytoday.com/intl/blog/subliminal/201206/how-we-are-judged-our-appearance\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">我們就是會被事物外表影響</a>，並且<a href=\"https://conversionxl.com/blog/first-impressions-matter-the-importance-of-great-visual-design/\" data-href=\"https://conversionxl.com/blog/first-impressions-matter-the-importance-of-great-visual-design/\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">一個印象的建立只是幾個瞬間的事情</a>。</p>\\n<p>而 view 就是決定一個網頁會不會在使用者打開 0.5 秒之後就馬上被關掉的決定性因素。</p>\\n<p>View 負責的是資料的呈現，提供樣板（template）來動態產生內容，通常由 HTML, CSS 與 JavaScript 組成。每一個 controller action 都會有自己分別的 view 檔案，比如說 <code class=\"markup--code markup--p-code\">posts#index</code> 對應到的 view 慣例上會放在 app/views/posts/index.html.erb。檔名中的 .erb 是 Rails 預設用來產生 template 的方式，可以自己換成別的，像是許多人（包含我）習慣使用的 <a href=\"https://github.com/slim-template/slim\" data-href=\"https://github.com/slim-template/slim\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">slim</a>。我們在 controller 建立的實例變數 <code class=\"markup--code markup--p-code\">@posts</code> 可以傳進 view 中被呼叫，所以這時候只要寫個迴圈就可以把 <code class=\"markup--code markup--p-code\">@posts</code> 列出來。</p>\\n<pre># app/views/posts/index.html.slim</pre>\\n<pre>...(略)</pre>\\n<pre>- <strong class=\"markup--strong markup--pre-strong\">@posts</strong>.each do |post|<br>  .post-preview<br>    h2.post-title<br>      = link_to post.title, post_path(post)<br>    h3.post-subtitle<br>      = post.description<br>    p.post-meta<br>      = post.created_at.strftime('%B %-d, %Y')<br>  hr/</pre>\\n<p>這邊只列出最相關的部分，可以看到 <code class=\"markup--code markup--p-code\">@posts</code> 可以直接在裡面被呼叫。</p>\\n<p>順帶一提，現在前端技術發展越來越成熟，很多前端框架出現了，這時候呈現資料的方法就變得很多元，像是把 Rails 當作是一個 <a href=\"https://zh.wikipedia.org/wiki/%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%8E%A5%E5%8F%A3\" data-href=\"https://zh.wikipedia.org/wiki/%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%8E%A5%E5%8F%A3\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">API</a> ，不去 view 要 template，而是拿到瀏覽器再渲染 (client-side rendering)，又分了像是 SPA (Single Page Application), SSR (server-side rendering) 等等，可以看看這篇<a href=\"https://medium.com/@hulitw/introduction-mvc-spa-and-ssr-545c941669e9\" data-href=\"https://medium.com/@hulitw/introduction-mvc-spa-and-ssr-545c941669e9\" class=\"markup--anchor markup--p-anchor\" target=\"_blank\">優質好文</a>，當初解了我不少惑。</p>\\n<p>View 的部分完成了，controller 的工作算是功德圓滿，此時它將會送出一個有 status + header + body 三部分組成的 http response，而這個 response 就會沿著前面那些路線一路被送回瀏覽器。</p>\\n<p>所以說這些分派請求、MVC 三部分各自的角色與彼此的溝通，都是怎麼做到的？示範的程式碼明明就看起來很簡單啊（甚至還有一個類別是空的）？這時候就要請默默在背後幫你把事情都打點好的 Action Pack 與 Active Record 出場了。</p>\\n<h4>Action Pack</h4>\\n<blockquote>Action Pack is a framework for handling and responding to web requests. It provides mechanisms for <strong class=\"markup--strong markup--blockquote-strong\">routing</strong> (mapping request URLs to actions), defining <strong class=\"markup--strong markup--blockquote-strong\">controllers</strong> that implement actions, and generating responses by rendering <strong class=\"markup--strong markup--blockquote-strong\">views</strong>, which are templates of various formats.</blockquote>\\n<p>節錄自<a href=\"https://github.com/rails/rails/tree/master/actionpack\" data-href=\"https://github.com/rails/rails/tree/master/actionpack\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\"> Rails 官方文件</a>。</p>\\n<p>看到上面粗體的幾個關鍵字：routing, controllers 與 views，沒耐心看的大概也猜得出來，這些角色之所以能行雲流水的運作，就是靠著 Action Pack 這個框架。</p>\\n<p>Action Pack 底下有兩個模組，Action Dispatch 與 Action Controller。</p>\\n<p><strong class=\"markup--strong markup--p-strong\">Action Dispatch</strong> 負責解析請求、處理開發人員設定好的路由（就是我們剛剛在 <code class=\"markup--code markup--p-code\">routes.rb</code> 中定義的），並且做一些更進階的處理像是 <code class=\"markup--code markup--p-code\">POST</code>, <code class=\"markup--code markup--p-code\">PUT</code>, <code class=\"markup--code markup--p-code\">PATCH</code> 的 http 的請求參數、http 快取邏輯、cookies 和 sessions。</p>\\n<p><strong class=\"markup--strong markup--p-strong\">Action Controller </strong>提供一個 base class 讓眾 controller 們繼承，我們的 PostsController 也是如此。回顧一下剛剛的檔案：</p>\\n<pre># app/controllers/posts_controller.rb</pre>\\n<pre>class PostsController &lt; <strong class=\"markup--strong markup--pre-strong\">ApplicationController</strong><br>  ...(略）<br>end</pre>\\n<p>而 application_controller.rb 檔案長這樣：</p>\\n<pre># app/controllers/application_controller.rb</pre>\\n<pre>class ApplicationController &lt; <strong class=\"markup--strong markup--pre-strong\">ActionController::Base</strong><br>end</pre>\\n<p><a href=\"https://api.rubyonrails.org/classes/ActionController/Base.html\" data-href=\"https://api.rubyonrails.org/classes/ActionController/Base.html\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">ActionController::Base 的 API 文件</a> 在這裡。</p>\\n<p>在 Ruby on Rails 的框架中，開發人員會直接接觸到的只會有 Action Controller 這個模組。Action Dispatch ，與之後的 Action View 會自動被啟動。而在一個簡單專案中（如這個），我們做的事情也只是讓 controller 繼承 <code class=\"markup--code markup--p-code\">ActionController::Base</code> ，剩下的一切就會都幫我們做好。</p>\\n<h4>Active Record</h4>\\n<blockquote>Active Record connects classes to relational database tables to establish an almost zero-configuration persistence layer for applications. The library provides a base class that, when subclassed, sets up a <strong class=\"markup--strong markup--blockquote-strong\">mapping between the new class and an existing table in the database</strong>.</blockquote>\\n<p>節錄自 <a href=\"https://github.com/rails/rails/tree/master/activerecord\" data-href=\"https://github.com/rails/rails/tree/master/activerecord\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">Rails 官方文件</a>。</p>\\n<p>沒錯，Active Record 就是 Rails 實作出 ORM 的地方，將資料庫的表對應到 Ruby 類別（在 Rails 情境中就是 model）。只要讓你的 class 繼承<code class=\"markup--code markup--p-code\">ActiveRecord::Base</code>，並且遵循<a href=\"https://edgeguides.rubyonrails.org/active_record_basics.html#naming-conventions\" data-href=\"https://edgeguides.rubyonrails.org/active_record_basics.html#naming-conventions\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">命名規範</a>，你就可以幾乎零設定就開始用 Ruby 程式碼操作資料庫了。回頭看一下剛剛的例子：</p>\\n<pre># app/models/post.rb</pre>\\n<pre>class Post &lt; <strong class=\"markup--strong markup--pre-strong\">ApplicationRecord</strong><br>end</pre>\\n<p><code class=\"markup--code markup--p-code\">Post </code>這個類別是繼承自<code class=\"markup--code markup--p-code\">ApplicationRecord</code>，在 application_record.rb 中：</p>\\n<pre># app/models/application_record.rb</pre>\\n<pre>class ApplicationRecord &lt; <strong class=\"markup--strong markup--pre-strong\">ActiveRecord::Base</strong><br>  self.abstract_class = true<br>end</pre>\\n<p><code class=\"markup--code markup--p-code\">ApplicationRecord</code>的確是繼承自 <code class=\"markup--code markup--p-code\">ActiveRecord</code>。有興趣的同樣也可以去看看 <a href=\"https://api.rubyonrails.org/\" data-href=\"https://api.rubyonrails.org/\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">Rails 的 API 文件</a>，這邊就先附上連結不多說了。</p>\\n<p>介紹完了 Rails 的 MVC 機制，使用者在螢幕那端大約快要不耐煩了（她還沒看到畫面哪），現在 response 已經被產生，接下來它會沿著 request 進來時的路徑，從路由、中介軟體一路被送出去。</p>\\n<h3>第四步：瀏覽器收到回應，渲染頁面，完成！</h3>\\n<p>這邊直接列點描述會經過的步驟：</p>\\n<ol>\\n<li name=\"2ec5\" id=\"2ec5\" class=\"graf graf--li graf-after--p\">判斷狀態碼：2XX 表示可以放行，3XX 表示你要找的路不在這在另一邊，4XX 與 5XX 表示你要找的路不在這但不知道在哪邊</li>\\n<li name=\"aab3\" id=\"aab3\" class=\"graf graf--li graf-after--li\">多國語言的編碼解析： 常常看到 I18N 卻不知道是什麼意思嗎？是 Internationalization</li>\\n<li name=\"ae84\" id=\"ae84\" class=\"graf graf--li graf-after--li\">根據 html 建構 DOM Tree：如果遇到 &lt;stylesheet&gt; 會先保存給之後渲染，如果遇到 &lt;script&gt; 標記則會送到 Javascript 引擎</li>\\n<li name=\"e17d\" id=\"e17d\" class=\"graf graf--li graf-after--li\">製造 Render Tree：根據 html 與 css 製造的，這邊會把被 css 隱藏的部分留下，不會放進樹中。</li>\\n<li name=\"f9f1\" id=\"f9f1\" class=\"graf graf--li graf-after--li\">渲染頁面，頁面加載完成。</li>\\n</ol>\\n<p>事到如今，網頁終於呈現出來了。雖然經過了兩大篇的篇幅，但是這段從輸入 URL 到看到回應的過程實際上只會發生在幾秒之間，是不是偉哉網路。</p><h3>後記</h3>\\n<p>噫！我寫完了！</p>\\n<p>本來只是覺得好玩，想要挑戰一下自己，沒想到邊寫邊查資料的過程中也順道為自己釐清了很多原本模糊或是似懂非懂的觀念。講得出來才是真正理解的開始啊！除了釐清觀念之外，同時也發現了很多有趣的東西，但考量到放進來的話篇幅就會太長而且發散，所以以後有空慢慢來介紹。</p>\\n<p>雖然已盡能力所及地確保資料的正確性，但我恐怕還是會有不對/不精確的觀念或用字，如果願意<a href=\"https://jennycodes.herokuapp.com/contact\" data-href=\"https://jennycodes.me/contact\" class=\"markup--anchor markup--p-anchor\" rel=\"noopener nofollow\" target=\"_blank\">指正我</a>的話我會非常感激！</p><h3>參考資料</h3>\\n<p><a href=\"https://guides.rubyonrails.org/routing.html\" data-href=\"https://guides.rubyonrails.org/routing.html\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">Rails Routing from the Outside In</a></p>\\n<p><a href=\"http://andrewberls.com/blog/post/rails-from-request-to-response-part-2--routing\" data-href=\"http://andrewberls.com/blog/post/rails-from-request-to-response-part-2--routing\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">Rails from Request to Response</a></p>\\n<p><a href=\"https://www.rubypigeon.com/posts/examining-internals-of-rails-request-response-cycle/\" data-href=\"https://www.rubypigeon.com/posts/examining-internals-of-rails-request-response-cycle/\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">Examining The Internals Of The Rails Request/Response Cycle</a></p>\\n<p><a href=\"https://www.jianshu.com/p/d616d887953a\" data-href=\"https://www.jianshu.com/p/d616d887953a\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">浏览器的工作原理：新式网络浏览器幕后揭秘</a></p><p>文章同步發表於 <a href=\"https://medium.com/@jinghua.shih\">Medium</a>。",
        "status": 1,
        "description": "終於，我們進入 Ruby on Rails 應用程式中。",
        "created_at": "2019-01-15T00:03:27.535673",
        "updated_at": "2019-02-23T02:51:26.213622",
        "slug": "從點一個-url-到看到頁面中間發生了什麼事下集",
        "medium_url": "https://medium.com/@jinghua.shih/%E5%BE%9E%E9%BB%9E%E4%B8%80%E5%80%8B-url-%E5%88%B0%E7%9C%8B%E5%88%B0%E9%A0%81%E9%9D%A2%E4%B8%AD%E9%96%93%E7%99%BC%E7%94%9F%E4%BA%86%E4%BB%80%E9%BA%BC%E4%BA%8B-%E4%B8%8B%E9%9B%86-2749b2863342"
    },
    {
        "id": 5,
        "title": "將 Django 應用程式部署到 Heroku，與使用 conda 環境的注意事項",
        "body": "<p></p>\\n<p>好的，其實這篇本來沒有在<a href=\"https://jennycodes.me/upcoming\" data-href=\"https://jennycodes.me/upcoming\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">預計要寫的文章</a>中，但是它橫空出世的原因是我原本以為前幾天才剛用 Heroku 部署了一個網站（<a href=\"https://jennycodes.me\" data-href=\"https://jennycodes.me\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">就是這個網站</a>）（這個部署過程又是另一個警世故事了，還因為遲遲無法將資料庫從 SQLite3 搬遷到 PostgreSQL 而打掉重練），今天想說一鼓作氣再把<a href=\"https://bevereusage.herokuapp.com/\" data-href=\"https://bevereusage.herokuapp.com/\" class=\"markup--anchor markup--p-anchor\" rel=\"noopener nofollow\" target=\"_blank\">另一個網站</a>（今天的主角）也上線，再做一次，應該能夠行雲流水地搞定吧？</p>\\n<p>當然不。</p>\\n<p>先介紹一下本日主角：這是在 Anaconda 環境下用 Django（一個用 Python 寫成的網頁框架）做的網頁應用程式，資料庫原本是用 SQLite3，部署時將 production 環境的資料庫改成（受 Heroku 寵愛的）PostgreSQL。</p>\\n<p>儘管同時參照擁有清楚說明的<a href=\"https://developer.mozilla.org/zh-TW/docs/Learn/Server-side/Django/Deployment\" data-href=\"https://developer.mozilla.org/zh-TW/docs/Learn/Server-side/Django/Deployment\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\"> MDN 教學</a> 與 <a href=\"https://devcenter.heroku.com/categories/working-with-django\" data-href=\"https://devcenter.heroku.com/categories/working-with-django\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">Heroku 本身的文件</a>，除了更改資料庫設定、重新設定應用程式金鑰位置等等之外，也依序新增了 Procfile, requirements.txt, 與 runtime.txt，還有下載相關的套件（這邊就不細講了，連結裡面都有詳細的說明），但是在最後執行 git push heroku master 時，出現了令人匪夷所思的狀況：</p>\\n<blockquote>Could not find a version that satisfies the requirement anaconda-client==1.6.14</blockquote>\\n<p>Heroku 會要求 anaconda-client 這個套件是因為 requirements.txt 中有將 anaconda-client 列出來，而 requirements.txt 是使用了 pip3 freeze &gt; requirements.txt 這個指令製造出來的，這個指令翻譯出來就是「把現在這個環境中有安裝的套件都列出來，存進一個叫做 requirements.txt 的檔案裡，如果沒有這個檔案就製造一個」，將一個 Django 應用程式部署到 Heroku 時，這是一個必要的檔案，讓 Heroku 知道這個應用程式需要搭配哪些套件。</p>\\n<p>而 Heroku 報錯的這個狀況讓我覺得匪夷所思的原因是，它明明就有被安裝在我的環境啊（我在 conda 的 default 環境 (base)中，使用指令 conda list env 可以看到你在 conda 有哪些虛擬環境，而指令 conda list 或 pip list 都可以讓你看到這個環境裝了哪些套件）。順帶一提，其實原本開這個專案時想要使用比較常被拿來舉例的 virtualenv，但最後沒有，為什麼呢？因為忘了XD 總之 conda 與 virtualenv 做的事基本上是一樣的，也就是讓你開虛擬環境（不過 conda 可以做更多，因為 conda 主會出現的主要原因是看見了 virtualenv 的限制，可以參考 <a href=\"https://stackoverflow.com/questions/20994716/what-is-the-difference-between-pip-and-conda\" data-href=\"https://stackoverflow.com/questions/20994716/what-is-the-difference-between-pip-and-conda\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">Stack Overflow 的這個回答</a>））。</p>\\n<p>後來自己摸索了一段時間後，發現應該是因為我是在 conda base 的環境中，裡面其實有很多跟這個專案無關的套件，而不必要的套件一多就會出現像是相依性（dependency）的問題。</p>\\n<p>怎麼解？一開始的想法是，既然 Heroku 看的是 requirements.txt 這個檔案來部署套件，但現在這個檔案裡面有太多不相干的套件，那就直接修改檔案，暴力幫它瘦身！</p>\\n<p>於是，一個原本有 216 行的檔案，被刪到只剩下 10 行左右XD</p>\\n<p>刪完之後，果真 push 沒問題了，但是當我滿心期待的打下</p>\\n<pre>heroku open</pre>\\n<p>打開我的專案時，卻打不開。用 heroku logs — tail 檢查 log 狀態時，找到了</p>\\n<blockquote>heroku[router]: at=error code=H10 desc=”App crashed”</blockquote>\\n<p>這個非常含糊的錯誤。</p>\\n<p>錯誤的原因實在可能有太多，但我想，十之八九是跟剛剛被我手動去蕪存菁的 requirements.txt 檔案有關，畢竟當時刪除套件的時候，完全只憑藉我個人微薄的網路知識與不到兩個月的 Django 學習經驗來判斷，非常有可能刪到了沒有被直接指名卻默默被需要的套件們。</p>\\n<p>既然我不能自己判斷什麼能刪什麼不能刪，而產生這個清單的 pip3 freeze 指令又會把所有在這個環境中的套件列出來，那麼答案很明顯了，就是創一個虛擬環境，在環境裡面重新安裝那些我需要的套件，這樣這個環境中就只會有系統自動裝好的（也就是系統自己需要的套件）與我需要的套件了。</p>\\n<p>於是在終端機打</p>\\n<pre>conda create — name django_env — python=3.6.6</pre>\\n<pre>source activate django_env</pre>\\n<p>第一行指令創立了一個叫做 django_env 的虛擬環境，使用 version = 3.6.6 的 Python。之之所以會使用 3.6.6 版本是因為 Heroku 建議使用 3.6.6 或是 3.7.0 的版本（在我書寫的現在）。第二行指令進入 django_env 這個環境。</p>\\n<p>可以用 conda env list 再確認一次。成功進入的話就會在命令提示元前面出現（你的虛擬環境）的提示。</p>\\n<p>進來之後，你至少會需要裝的有 django, gunicorn, dj-database-url, psycopg2, whitenoise， 我自己則是再裝了 ipython，基本上你在 source code 裡面有引入的套件都要裝過一遍，這樣輸出的時候才會正確。安裝的方法是</p>\\n<p>pip install [package_name]</p>\\n<p>重點來了！</p>\\n<p>在 conda 的虛擬環境中，使用 pip3 跟 pip 是不一樣的！在一般的情況下，pip 與 pip3 是可以交互使用的，至於為什麼會出現這兩種指令就暫且按下不表，有心的可以自己 google 一下，總之，在 conda 的虛擬環境中，使用 pip 做的舉動才會是專屬於這個虛擬環境的，使用 pip3 下指令則這個虛擬環境會被直接無視。 舉個例子：</p>\\n<figure class=\"text-center\"><img class=\"lazy\" data-action=\"zoom\" data-action-value=\"1*Dwbfa3cQHYRYeHZqJb_Ztw.png\" data-src=\"https://cdn-images-1.medium.com/max/1600/1*Dwbfa3cQHYRYeHZqJb_Ztw.png\"></figure><p>同樣在 django_env 這個環境，同樣是 install django 這個指令，如果用 pip3 下的話，會出現「Requirement already satisfied:…(略）」的訊息，但是如果是用 pip 下，則會開始跑安裝程序，並把 django 裝在 /anaconda3/envs/django_env/ 目錄下面。</p>\\n<p>所以一定要記得安裝的時候要用 pip 而不是 pip3（尤其像是剛剛介紹的 <a href=\"https://developer.mozilla.org/zh-TW/docs/Learn/Server-side/Django/Deployment\" data-href=\"https://developer.mozilla.org/zh-TW/docs/Learn/Server-side/Django/Deployment\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">MDN 教學</a> 都是叫你用 pip3，很容易直接複製貼上），輸出的時候也要用 pip freeze &gt; requirements.txt。</p>\\n<figure class=\"text-center\"><img class=\"lazy\" data-src=\"https://cdn-images-1.medium.com/max/1600/1*IFyr21wYK0rr-I7vKBX2iQ.png\"></figure><p>好了！現在我們有了一份乾淨又簡潔的 requirement list，重新推上 heroku，成功！！！</p>\\n<p>沒有成功。再次出現了</p>\\n<blockquote>Could not find a version that satisfies the requirement ……</blockquote>\\n<p>的訊息，只是這次是另一個套件。這時候該怎麼做呢？使用虛擬環境的好處就是，你可以隨意的玩（破壞），如果真的被玩壞了就刪掉環境重新裝一個就好，所以既然這個套件出問題，那就先 pip uninstall [這個不配合的套件名字] ，重新輸出一次，看看結果如何。</p>\\n<p>結果就成功了。</p>\\n<p><a href=\"https://bevereusage.herokuapp.com/interaction/\" data-href=\"https://bevereusage.herokuapp.com/interaction/\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">真正網站在這裡</a></p>\\n<p>所以說，有時候就是需要一些誤打誤撞的勇氣。</p>\\n<p>還有，將 django 應用程式部署到 heroku 上時，記得善用 virtual environment (不管是 virtualenv 還是 conda），可以避免引入不必要的套件，日後也比較好管理與 debug。最重要的是，記得 pip 與 pip3 的分別。</p><p>雖然已盡能力所及地確保資料的正確性，但我恐怕還是會有不對/不精確的觀念或用字，如果願意<a href=\"https://jennycodes.herokuapp.com/contact\" data-href=\"https://jennycodes.herokuapp.com/contact\" class=\"markup--anchor markup--p-anchor\" rel=\"noopener nofollow nofollow noopener\" target=\"_blank\">指正我</a>的話我會非常感激！</p><p>文章同步發表於 <a href=\"https://medium.com/@jinghua.shih\">Medium</a>。",
        "status": 1,
        "description": "重點節錄：善用虛擬環境真的很重要，還有注意 conda 中 pip 與 pip3 在虛擬環境中是不一樣的！",
        "created_at": "2019-01-01T13:38:22.502625",
        "updated_at": "2019-02-23T03:10:30.164393",
        "slug": "將-django-應用程式部署到-heroku與使用-conda-環境的注意事項-cb3451cd-e190-4a14-aa39-6bc85cdabcf6",
        "medium_url": "https://medium.com/@jinghua.shih/%E5%B0%87-django-%E6%87%89%E7%94%A8%E7%A8%8B%E5%BC%8F%E9%83%A8%E7%BD%B2%E5%88%B0-heroku-%E8%88%87%E4%BD%BF%E7%94%A8-conda-%E7%92%B0%E5%A2%83%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A0%85-427d6d656498"
    },
    {
        "id": 1,
        "title": "網頁開發見習生｜混沌初開",
        "body": "<p>截至目前為止（2018 年底），學寫程式差不多滿兩年了，嗚呼哀哉！說兩年其實有點心虛，因為中間有停擺過一陣（半年？一年？不可考了），但繞了一圈還是回來了。大家通常最疑惑的就是為何一個外文系的學生（對，而且我今年會從外文系畢業！）會跑去寫程式，其實對我來說，就是剛好很幸運地找到了一個能夠同時給我滿足感與成就感，又可以當飯吃的興趣而已。至於我是如何找到這個興趣的？之後有空再說好了XD</p>\\n<p>總而言之，從一開始的 C++，到後來的 Ruby 與 Ruby on Rails，到之後開始做 IT 實習，每一個新的嘗試都讓我越來越確定兩件事：(1) 我喜歡做一個工程師做的事 (2) 我可以做好一個工程師做的事。又有樂趣又有成就感的事如此可遇不可求，當然要好好珍惜。</p>\\n<p>除了去美國交換的那兩個學期，大多數時間我是自學的。在程式學習的世界，網路是個友善溫暖的大個子。實在是有太多次某個網站中的某筆紀錄（可能是一個解釋清楚的文章、一個驚心動魄的除錯過程、一個很笨的但剛好就是我想問的問題與解答）就這樣幫助了一個在電腦螢幕前瀕臨絕望的女子。所以說，開這個網誌的一個核心目的就是把愛傳下去，就算我其實也只算是剛起步（還在沙灘玩沙），眼界絕對沒有辦法放得很遠，但是總之多一筆紀錄就是多一個參考，也算是為自己的足跡留下個見證。</p>\\n<p>這個部落格會以技術性文章為主，紀錄自己學到現在覺得很酷（ = 花了很久的時間終於弄懂後，才發現其實根本沒有很難，或是真的很難所以其實也還沒有完全懂）的東西，且戰且走，最終目標是寫到再難的概念都能夠讓看的人覺得很清楚又很簡單，也希望能順手讓剛好正在學/想要學的人少走一點冤枉路，或是得到一些「啊原來有人也在這種莫名其妙的地方卡了這麼久」的那種找到同伴的慰藉。</p>\\n<p>受眾呢？希望任何對網頁科技、網頁開發、Ruby on Rails 有一點點興趣的人都能夠在這個部落格得到一點收穫吧！</p>\\n<p>既然 2019 要來了，新年新希望就是一週一篇，多不退少補！</p>",
        "status": 1,
        "description": "重點節錄：新年開始，一週一篇。",
        "created_at": "2018-12-30T12:32:30.277917",
        "updated_at": "2019-02-24T11:52:44.737337",
        "slug": "網頁開發見習生｜混沌初開",
        "medium_url": ""
    },
    {
        "id": 21,
        "title": "Serverless & FaaS",
        "body": "<p></p>\\n<p>很久很久以前（大約 <a href=\"https://www.technologyreview.com/s/425970/who-coined-cloud-computing/\" data-href=\"https://www.technologyreview.com/s/425970/who-coined-cloud-computing/\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">13 年前</a>），「雲端運算」（cloud computing） 這個詞開始逐漸被使用並且蓬勃發展，很多相應的服務就此產生，被稱為 XaaS（X as a Service，X 可以以任何字替換）。 SaaS, PaaS 與 IaaS 是傳統三種分類方式，分別代表了軟體即服務（Software as a Service），平台即服務（Platform as a Service），與基礎架構及服務（Infrastructure as a Service）。沒有實際使用經驗的人（e.g. 半年前的我）一開始可能會有點難理解這些服務的差異，不過有很多很棒的平台寫文章介紹，比如 <a href=\"https://www.ithome.com.tw/article/93007\" data-href=\"https://www.ithome.com.tw/article/93007\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">iThome</a> 與 <a href=\"https://progressbar.tw/posts/51\" data-href=\"https://progressbar.tw/posts/51\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">ProgressBar</a>，推薦還不理解直接讀一讀。下面就不錦上添花，直接放一張以車為例子的示意圖。</p>\\n<figure class=\"text-center\"><img class=\"lazy\" data-action=\"zoom\" data-action-value=\"1*EVNF6iHBgAMnvBsWkFrH6A.png\" data-src=\"https://cdn-images-1.medium.com/max/1600/1*EVNF6iHBgAMnvBsWkFrH6A.png\"><figcaption class=\"imageCaption\"><a href=\"https://www.k3syspro.com/cloud-computing-choosing-right-deployment-method/\" data-href=\"https://www.k3syspro.com/cloud-computing-choosing-right-deployment-method/\" class=\"markup--anchor markup--figure-anchor\" rel=\"nofollow noopener\" target=\"_blank\">https://www.k3syspro.com/cloud-computing-choosing-right-deployment-method/</a></figcaption></figure><p>簡單地說，現在各式各樣的應用程式（Gmail, 手機 app 等等）都是屬於 SaaS 軟體服務的範疇，而一個開發人員如果想要部署自己的程式碼，通常會選擇使用 PaaS 平台服務或是 IaaS 基礎建設服務。</p>\\n<p>好了，不負責任的 Serverless 簡單背景介紹結束，下面進入正題。</p>\\n<h3>Serverless 與 FaaS</h3>\\n<p>一般而言，工程師可以簡單分成開發（Development）跟維運（Operation）兩類。開發工程師負責實現商業邏輯，也就是撰寫程式碼，維運工程師則負責管理程式碼的基礎架構（伺服器、資料庫等），讓程式碼可以順利運行。</p>\\n<p>雖然現在許多企業都已經採用上面介紹的 IaaS，將網站基礎建設放到雲端，維運的負擔卻沒有減輕很多，還是必須處理資安問題、監控系統等等。</p>\\n<p>Serverless 是最近發展出來的概念，由 Amazon 在 2014 年發布的 <a href=\"https://aws.amazon.com/tw/lambda/\" data-href=\"https://aws.amazon.com/tw/lambda/\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">Amazon Lambda</a> 開先鋒，其他科技龍頭也在之後陸續推出相似的服務，像是 <a href=\"https://cloud.google.com/functions/\" data-href=\"https://cloud.google.com/functions/\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">Google Cloud Functions</a>，<a href=\"https://www.ibm.com/cloud/functions\" data-href=\"https://www.ibm.com/cloud/functions\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">IBM Cloud Functions</a> 與 <a href=\"https://azure.microsoft.com/en-us/services/functions/\" data-href=\"https://azure.microsoft.com/en-us/services/functions/\" class=\"markup--anchor markup--p-anchor\" rel=\"noopener nofollow\" target=\"_blank\">Azure Functions</a>。</p>\\n<blockquote>這項技術的目的並不是為了實現真正意義上的「無服務器」，而是指由第三方雲計算供應商負責後端基礎結構的維護，以服務的方式為開發者提供所需功能，例如數據庫、消息，以及身份驗證等。簡單地說，這個架構就是要讓開發人員專注代碼的運行而不需要管理任何的基礎設施。程序代碼被部署在諸如 AWS Lambda 這樣的平台上，通過事件驅動的方式去觸發對函數的調用。</blockquote>\\n<p>節錄自 從 <a href=\"https://aws.amazon.com/cn/blogs/china/iaas-faas-serverless/\" data-href=\"https://aws.amazon.com/cn/blogs/china/iaas-faas-serverless/\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">IaaS 到 FaaS— Serverless 架構的前世今生</a>。</p>\\n<p>Serverless 開發的一個好處是「用程式碼來控制程式碼」，也就是 <a href=\"https://en.wikipedia.org/wiki/Infrastructure_as_code\" data-href=\"https://en.wikipedia.org/wiki/Infrastructure_as_code\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">Infrastructure as Code</a>，以往維運工程師可能會是手動去介面調整參數，現在當這些工作變成程式碼，就可以享有<a href=\"https://medium.com/kkstream/infrastructure-as-code-%E5%A6%82%E4%BD%95%E6%94%B9%E5%96%84%E6%88%91%E5%80%91%E7%9A%84%E7%94%9F%E6%B4%BB%E5%93%81%E8%B3%AA-ee11e9d67b71\" data-href=\"https://medium.com/kkstream/infrastructure-as-code-%E5%A6%82%E4%BD%95%E6%94%B9%E5%96%84%E6%88%91%E5%80%91%E7%9A%84%E7%94%9F%E6%B4%BB%E5%93%81%E8%B3%AA-ee11e9d67b71\" class=\"markup--anchor markup--p-anchor\" target=\"_blank\">很多好處</a>，包含版本控制與 CI/CD（持續整合/持續部署）的流程。</p>\\n<p>那 FaaS 又是什麼呢？FaaS 的全名是「Function as a Service」（函式即服務），是 Serverless 實現的方式：</p>\\n<blockquote>Serverless applications are event-driven cloud-based systems where application development rely solely on a combination of third-party services, client-side logic<strong class=\"markup--strong markup--blockquote-strong\"> </strong>and <strong class=\"markup--strong markup--blockquote-strong\">cloud-hosted remote procedure calls</strong> <strong class=\"markup--strong markup--blockquote-strong\">(Functions as a Service)</strong>.</blockquote>\\n<p>節錄自 <a href=\"https://hackernoon.com/what-is-serverless-architecture-what-are-its-pros-and-cons-cc4b804022e9\" data-href=\"https://hackernoon.com/what-is-serverless-architecture-what-are-its-pros-and-cons-cc4b804022e9\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">Hackernoon</a>。</p>\\n<p>從上可以看出幾個重點：Serverless 是「事件驅動」（event-driven），由第三方服務（third-party services）、客戶端邏輯（client-side logic）與在雲端上的遠端程序呼叫（cloud-hosted remote procedure calls）所組成。這第三個組成的元素就是 FaaS。</p>\\n<h3>FaaS 的幾個特性</h3>\\n<h4>就是個函式（independent, sever-side, logical functions）</h4>\\n<p>名如其實，functions 就如同我們會在程式碼裡面寫的 functions，獨立、分離、自成一格。</p>\\n<h4>無狀態（stateless）</h4>\\n<p>每個請求都是獨立的。每次執行不會受到之前的執行內容/結果影響。任兩次對同一個 function 的呼叫可能會可能會在完全不同的容器（container）裡面執行。</p>\\n<h4>來得很快，去得也快（ephemeral）</h4>\\n<p>FaaS 隨叫隨開，並且做完了任務就馬上關掉，需要的啟動時間與關機時間都非常的短（尺度是毫秒）。</p>\\n<h4>事件驅動（event-triggered）</h4>\\n<p>雖然 functions 可以直接被取用，它們通常會從其他雲端服務被觸發，像是 HTTP 請求或是內部訊息通知。FaaS 比較常被使用的情境是雲端環境中各服務之間的橋樑。</p>\\n<h4>擴展性高（scalable by default）</h4>\\n<p>你可以一次啟動好幾個 container 來同時呼叫同一個 function。就算同意時間有很多的請求（incoming request）也不怕。</p>\\n<h3>Serverless 的優點與缺點</h3>\\n<h4>從企業的角度來看</h4>\\n<p>Serverless 最大的優勢就是降低成本，<a href=\"https://www.ithome.com.tw/news/112431\" data-href=\"https://www.ithome.com.tw/news/112431\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">這篇文</a>讓我們看到可口可樂因此省了多少錢。Serverless 可以真的做到「按件計酬」—當沒有使用的時候就沒有花費，這也是它跟 PaaS 最大的不同之處，因為 PaaS 不會因為一個事件而開啟整個應用程序又結束，但是 FaaS 可以做到。不過，如果你的應用程式結構複雜並且會長時間運行，那麼使用 Serverless 不會幫你省到什麼費用。 Serverless 最適合的情境是是不固定、落差大的需求量（spiky demands）。</p>\\n<p>Serverless 省錢方便的好處也有它的犧牲，由於許多工作都交給了第三方管理，所以企業對產品整體的控制權會減弱，也會有安全性、災後回復的風險。</p>\\n<h4>從開發人員的角度來看</h4>\\n<p>Serverless 可以將維運的負擔降到最低（比如說，不需要為不同的環境設定不同的機器），並且它與 Nanoservices, Microservices, <a href=\"https://en.wikipedia.org/wiki/Service-oriented_architecture\" data-href=\"https://en.wikipedia.org/wiki/Service-oriented_architecture\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">SOA (Service-Oriented Architecture)</a> 的概念是天作之合。同時，由於 FaaS 的高伸縮性，同時併發的請求們（concurrent requests）再也不是難題。</p>\\n<p>然而，由於 Serverless 還算是一個新的技術，再缺乏有經驗的人的引導之下，可能會導致個元件的碎片化（component fragmentation）、增加整以架構的複雜程度（complex ≠ complicated）還有增加測試的困難。</p>\\n<p>Serverless 也不是適合所有的架構。當你的應用程式依賴了很多第三方套件（3rd Party Dependencies），那麼表示當你打包這個應用程式時，它會變得很巨大，就不能發揮 FaaS 輕便簡潔的優勢了。</p><p>Serverless 是目前還正在如火如荼發展的技術，許多相關的配套與功能也都漸漸成熟。市面上也有出現了像是<a href=\"https://github.com/apex/apex\" data-href=\"https://github.com/apex/apex\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\"> Apex</a> 讓你更輕鬆部署 AWS Lambda 的工具，看著看著實在很手癢，希望哪一天真的有實際使用到的機會。</p><p>雖然已盡能力所及地確保資料的正確性，但我恐怕還是會有不對/不精確的觀念或用字，如果願意<a href=\"https://jennycodes.herokuapp.com/contact\" data-href=\"https://jennycodes.herokuapp.com/contact\" class=\"markup--anchor markup--p-anchor\" rel=\"noopener nofollow nofollow noopener nofollow noopener nofollow noopener\" target=\"_blank\">指正我</a>的話我會非常感激！</p>\\n<h4>Random Gems 一些不太相關的資源</h4>\\n<p>最近找資料的時候突然發現這個 <a href=\"https://github.com/ripienaar/free-for-dev\" data-href=\"https://github.com/ripienaar/free-for-dev\" class=\"markup--anchor markup--p-anchor\" rel=\"noopener nofollow\" target=\"_blank\">free-for-dev</a> 網站，裡面羅列了各種有提供免費服務的平台，並且持續更新中，很完整，很貼心。</p>\\n<p>還有順便看到這篇 <a href=\"https://medium.com/kkstream/%E5%B0%8E%E5%85%A5-configuration-as-code-%E5%AE%8C%E6%88%90%E4%B8%89%E4%BD%8D%E4%B8%80%E9%AB%94-all-are-codes-ede2c1470513\" data-href=\"https://medium.com/kkstream/%E5%B0%8E%E5%85%A5-configuration-as-code-%E5%AE%8C%E6%88%90%E4%B8%89%E4%BD%8D%E4%B8%80%E9%AB%94-all-are-codes-ede2c1470513\" class=\"markup--anchor markup--p-anchor\" target=\"_blank\">導入 Configuration as code，完成三位一體</a>，裡面將一個分成 infrastructure, code , configuration 三個部分，並探討如何將三個元素都程序化，存參存參。</p>\\n<h3>參考資源</h3>\\n<div>\\n<a href=\"https://hackernoon.com/what-is-serverless-architecture-what-are-its-pros-and-cons-cc4b804022e9\" data-href=\"https://hackernoon.com/what-is-serverless-architecture-what-are-its-pros-and-cons-cc4b804022e9\" class=\"markup--anchor markup--mixtapeEmbed-anchor\" title=\"https://hackernoon.com/what-is-serverless-architecture-what-are-its-pros-and-cons-cc4b804022e9\" rel=\"nofollow\"><strong class=\"markup--strong markup--mixtapeEmbed-strong\">What is Serverless Architecture? What are its Pros and Cons?</strong><br>hackernoon.com</a><a href=\"https://hackernoon.com/what-is-serverless-architecture-what-are-its-pros-and-cons-cc4b804022e9\" class=\"js-mixtapeImage mixtapeImage u-ignoreBlock\" data-media-id=\"8385dab132f96127f79e0fd167b789e2\" data-thumbnail-img-id=\"1*16x1_xEclXT4MB0FN_xr2g.jpeg\" style=\"background-image: url(https://cdn-images-1.medium.com/fit/c/320/320/1*16x1_xEclXT4MB0FN_xr2g.jpeg);\"></a>\\n</div>\\n<div>\\n<a href=\"https://github.com/serverless/examples\" data-href=\"https://github.com/serverless/examples\" class=\"markup--anchor markup--mixtapeEmbed-anchor\" title=\"https://github.com/serverless/examples\" rel=\"nofollow\"><strong class=\"markup--strong markup--mixtapeEmbed-strong\">serverless/examples</strong><br>github.com</a><a href=\"https://github.com/serverless/examples\" class=\"js-mixtapeImage mixtapeImage u-ignoreBlock\" data-media-id=\"3291887c7ab3bbed331431f343121d97\" data-thumbnail-img-id=\"0*y628g0OJEXtWRWi_\" style=\"background-image: url(https://cdn-images-1.medium.com/fit/c/320/320/0*y628g0OJEXtWRWi_);\"></a>\\n</div>\\n<div>\\n<a href=\"https://amio.github.io/serverless-zhcn/\" data-href=\"https://amio.github.io/serverless-zhcn/\" class=\"markup--anchor markup--mixtapeEmbed-anchor\" title=\"https://amio.github.io/serverless-zhcn/\" rel=\"nofollow\"><strong class=\"markup--strong markup--mixtapeEmbed-strong\"></strong><br>无服务器架构（Serverless Architectures）amio.github.io</a><a href=\"https://amio.github.io/serverless-zhcn/\" class=\"js-mixtapeImage mixtapeImage mixtapeImage--empty u-ignoreBlock\" data-media-id=\"3153b377a1bc76a838c0bb7136ea2989\"></a>\\n</div><p>文章同步發表於 <a href=\"https://medium.com/@jinghua.shih\">Medium</a>。",
        "status": 1,
        "description": "順帶一提 SaaS, PaaS & IaaS",
        "created_at": "2019-02-17T04:47:15.362117",
        "updated_at": "2019-02-23T04:25:43.811814",
        "slug": "serverless-faas",
        "medium_url": "https://medium.com/@jinghua.shih/serverless-faas-3b607f0158fe"
    },
    {
        "id": 16,
        "title": "Rails 網站效能提升實錄",
        "body": "<p></p>\\n<figure class=\"text-center\"><img class=\"lazy\" data-src=\"https://cdn-images-1.medium.com/max/1600/1*bbDwlQmfVVh0J-MA6MxrHA.png\"><figcaption class=\"imageCaption\">網站改造過後在 Google PageSpeed Insights 的分數</figcaption></figure><blockquote>[2019/4/6 更新 1] 感謝 Yuna 來信提醒其實 image size也是一個可以被優化的面向，下面新增兩個 image compression 推薦資源。Thank you Yuna!</blockquote><br>\\n<blockquote>[2019/4/6 更新 2] 後來發現 <a href=\"https://www.cloudflare.com/\" data-href=\"https://www.cloudflare.com/\" class=\"markup--anchor markup--blockquote-anchor\" rel=\"noopener nofollow\" target=\"_blank\">CloudFlare CDN</a> 有提供免費 CDN 服務，設定很快效果很好！</blockquote><p>先上前後對照</p>\\n<h3>Before vs After</h3>\\n<figure class=\"text-center\"><img class=\"lazy\" data-action=\"zoom\" data-action-value=\"1*kfndB0ZBJEtcTTB4CHbeyg.png\" data-src=\"https://cdn-images-1.medium.com/max/1600/1*kfndB0ZBJEtcTTB4CHbeyg.png\"><figcaption class=\"imageCaption\"><a href=\"https://jennycodes.herokuapp.com\" data-href=\"https://jennycodes.herokuapp.com\" class=\"markup--anchor markup--figure-anchor\" rel=\"noopener nofollow\" target=\"_blank\">https://jennycodes.herokuapp.com</a> 改造前，55 分。</figcaption></figure><figure class=\"text-center\"><img class=\"lazy\" data-action=\"zoom\" data-action-value=\"1*YrAPQd_in53l--oj_2UHNA.png\" data-src=\"https://cdn-images-1.medium.com/max/1600/1*YrAPQd_in53l--oj_2UHNA.png\"><figcaption class=\"imageCaption\"><a href=\"https://jennycodes.herokuapp.com\" data-href=\"https://jennycodes.herokuapp.com\" class=\"markup--anchor markup--figure-anchor\" rel=\"noopener nofollow\" target=\"_blank\">https://jennycodes.herokuapp.com</a> 改造後，97 分</figcaption></figure><p>這是 <a href=\"https://developers.google.com/speed/pagespeed/insights/\" data-href=\"https://developers.google.com/speed/pagespeed/insights/\" class=\"markup--anchor markup--p-anchor\" rel=\"noopener nofollow\" target=\"_blank\">Google PageSpeed Insights</a>，一個幫你免費診斷網站效能的工具，直接輸入要測試的網址，它就會從資源使用效率、載入速度等給你一個評分，並且也會針對你的網站沒做好的部分給建議。</p>\\n<p>上面是動工前的樣子，可以看到幾乎每一欄位都是紅色，總分也只有 55，慘不忍睹。改造過後，總分變成 97 分，首次有效繪製（從輸入網址到看到頁面主要內容的時間）時間差了足足有 5.2–1.9 = 3.3 秒之多。在每豪秒都要斤斤計較的網路世界，3.3 秒大概可以換算成現實世界的三個世紀吧！</p><p>最近的事情忙到一個段落，終於有時間好好的整頓我用 Ruby on Rails 架的部落格 https://jennycodes.me。從今年初上線至今，最大的痛點就是網站載入速度很慢。（其實還有其他許許多多想要改進/實現的功能，但是我們一步一步來。）</p>\\n<p>網站慢到什麼程度呢？第一次進站大概需要等 5~6 秒，有時候等一等還會因為作業時間過久直接出現 application error 給你看（直接被伺服器放棄的意思）。</p>\\n<p>其實，本來就預期網站效能不會太好，因為這個網站是使用 Heroku 平台服務的免費層級，而它有兩點可能會拖慢網站的速度：</p>\\n<ol>\\n<li name=\"5e0f\" id=\"5e0f\" class=\"graf graf--li graf-after--p\">只要有超過三十分鐘的閒置時間，伺服器就會關掉。要再進入就會需要重新連線。</li>\\n<li name=\"1846\" id=\"1846\" class=\"graf graf--li graf-after--li\">伺服器位置選項只有美國與歐洲，從台灣連過去就會需要比較久的時間。</li>\\n</ol>\\n<p>儘管如此，網站的速度還是太不可思議的慢了。這畢竟是一個架構簡單（資料庫裡只有兩張資料表）的部落格，免費的平台也不應該這樣。</p>\\n<h3>優化過程</h3>\\n<p>這次網站改造主要做了三件事：</p>\\n<ol>\\n<li name=\"6e4a\" id=\"6e4a\" class=\"graf graf--li graf-after--p\">Set <code class=\"markup--code markup--li-code\">config.assets.compile = false</code>.</li>\\n<li name=\"b731\" id=\"b731\" class=\"graf graf--li graf-after--li\">Set all javascript files to <code class=\"markup--code markup--li-code\">async</code>.</li>\\n<li name=\"7441\" id=\"7441\" class=\"graf graf--li graf-after--li\">Add <a href=\"http://jquery.eisbehr.de/lazy/\" data-href=\"http://jquery.eisbehr.de/lazy/\" class=\"markup--anchor markup--li-anchor\" rel=\"nofollow noopener\" target=\"_blank\">jQuery Lazy</a> plugin.</li>\\n<li name=\"0a08\" id=\"0a08\" class=\"graf graf--li graf-after--li\">Connect to CDN.</li>\\n</ol>\\n<p>除了這四點，下面也會介紹一些這次沒有做但也可以大幅優化網站的項目。</p>\\n<p>讓我來一一解釋。</p>\\n<h3>Set config.assets.compile = false</h3>\\n<p>這個選項是在 config/environments/production.rb 中，預設值本來就是 false，heroku 官網也建議<a href=\"https://devcenter.heroku.com/articles/rails-asset-pipeline#compile-set-to-true-in-production\" data-href=\"https://devcenter.heroku.com/articles/rails-asset-pipeline#compile-set-to-true-in-production\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">最好不要把這選項打開</a>，因為打開的話靜態資源（asset）會在第一次請求到來時才被編譯並且快取，而在之後的請求伺服器都會經過一系列尋找、確認的步驟才會呈現，拖慢網站的效能。（這篇 <a href=\"https://stackoverflow.com/questions/8821864/config-assets-compile-true-in-rails-production-why-not/8827757#8827757\" data-href=\"https://stackoverflow.com/questions/8821864/config-assets-compile-true-in-rails-production-why-not/8827757#8827757\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">stackoverflow</a> 的解釋也值得一讀）。</p>\\n<p>但我的網站原本是將這個選項打開的，原因是在一開始上線時，不知道為什麼怎麼樣就是無法載入首頁背景的圖，試了很久之後，發現唯有將這個選項打開，然後再手動 precompile assets，圖片才可以成功載入。於是當初就決定先將就這個寫法，日後再來還債。</p>\\n<p>要還債，就不得不找出圖片不能載入的真正原因。要找到圖片不能載入的原因，就要先好好暸解 rails 的<a href=\"https://guides.rubyonrails.org/asset_pipeline.html\" data-href=\"https://guides.rubyonrails.org/asset_pipeline.html\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\"> asset pipeline</a> 這個幫你處理靜態資源的機制。一個一個步驟檢視後，發現當發出 asset precompile 指令時，rails 找得到 css &amp; javascript 檔案，但是照片檔卻有時找得到，有時找不到。進一步縮小問題，我的圖檔是 .jpeg，是檔案格式的問題嗎？</p>\\n<p>上網一查，果真如此。Rails 預設支援的圖片格式是 .jpg，所以 .jpeg 格式的檔案並不會自動編譯。在 config/application.rb 中加上 <code class=\"markup--code markup--p-code\">config.assets.precompile += %w(.jpeg)</code>，再試一次，果真成功了！</p>\\n<p>找出圖片無法載入的真正癥結，就可以放心調整<code class=\"markup--code markup--p-code\">config.assets.compile = true</code>。但是還要記得清掉原本手動 precompile 在 public/ 資料夾產生的 assets 檔案，不然 heroku 在部署時看到這個檔案還是會直接拿來用，而不會更新資源。在 terminal 打 <code class=\"markup--code markup--p-code\">rake assets:clobber RAILS_ENV=production</code> 就可以了。</p>\\n<h3>Set All Javascript Files to Async</h3>\\n<p>一個心頭大患解決了，但還是不夠好。 <a href=\"https://developers.google.com/speed/pagespeed/insights\" data-href=\"https://developers.google.com/speed/pagespeed/insights\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">Google PageSpeed Insights</a> 的診斷還有提供一些方向：</p>\\n<figure class=\"text-center\"><img class=\"lazy\" data-action=\"zoom\" data-action-value=\"1*fWd49nx9MamQoOQH0c4cjg.png\" data-src=\"https://cdn-images-1.medium.com/max/1600/1*fWd49nx9MamQoOQH0c4cjg.png\"><figcaption class=\"imageCaption\">Google PageSpeed Insights 最初的診斷</figcaption></figure><p>第一條「排除禁止轉譯的資源」的解釋是「資源過多會妨礙首次繪製頁面。建議內嵌重要的 JS/CSS，延遲所有不重要的 JS/樣式。」意思是這些靜態資源其實也有親疏遠近之分；當你載入網頁時，有些 javascript 效果或是 css 樣式不那麼快出現也不會有人掛念，所以讓他們在比較重要的檔案完成載入之後再開始動作，就可以節省等待這些邊緣人被下載的時間。</p>\\n<p>要將不重要的 js 檔案延遲，可以在 template 引入 js 檔案的程式碼後面加上 async (asynchronous) ，例如 app/views/layout/application.html.slim（rails 預設的樣板引擎是 erb，我習慣用的是 slim）檔案，原本在 head 標籤中是</p>\\n<pre>= javascript_include_tag ‘application’, ‘data-turbolinks-track’: ‘reload’</pre>\\n<p>改成</p>\\n<pre>= javascript_include_tag ‘application’, ‘data-turbolinks-track’: ‘reload’, <strong class=\"markup--strong markup--pre-strong\">async: Rails.env.production?</strong></pre>\\n<p>如此一來，application.js 這個 bundle 就會在 <code class=\"markup--code markup--p-code\">DOMContentLoaded</code> 事件後才會執行。而這段程式碼的意思是「如果是在 production 環境的話，就讓此段 javascript 變成 async」。不直接讓 <code class=\"markup--code markup--p-code\">async = true</code> 的原因是 development 環境的設定是 <code class=\"markup--code markup--p-code\">config.assets.debug = true</code>。這個選項開啟後 rails 在執行應用程式時，就會將 js 引入檔一個個載入，而不會全部打包在一個大 js 檔案，如此讓除錯變得更加方便，但也會讓效能降低，所以只在開發模式開啟。</p>\\n<p>而在開發環境中， <code class=\"markup--code markup--p-code\">async = true</code> 而 js 引入檔又都分別引入的情況下，所有檔案非同步執行的結果就是<strong class=\"markup--strong markup--p-strong\">引入的順序會亂掉</strong>，就會出現像是<code class=\"markup--code markup--p-code\"> $ is not defined</code>（沒有先載入 jQuery）的情況。</p>\\n<h4>Turbolinks 與 Async 的微妙平衡</h4>\\n<p><a href=\"https://github.com/turbolinks/turbolinks\" data-href=\"https://github.com/turbolinks/turbolinks\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">Turbolinks</a> 是 一個 rails 自動載入的 gem，主要功能是「不完全換頁」，也就是在應用程式內切換頁面時，不重新載入所有的元素與樣式，可以節省的時間。讓你可以不使用前端 js 框架也可以享受到 SPA (Single Page Application) 的效果。</p>\\n<p>對 application.js 使用 async 後，必須注意原本寫在檔案內的 <code class=\"markup--code markup--p-code\">‘turbolinks:load’</code> 事件會失效，因為現在 js 檔案會在頁面載入之後才會開始動作，也就是說當程式碼跑到 <code class=\"markup--code markup--p-code\">‘turbolinks:load’</code> 的時候，頁面已經加載完了，所以這個事件就不會觸發，裡面的程式碼也就不會被執行。</p>\\n<p>我的做法是將 <code class=\"markup--code markup--p-code\">‘turbolinks:load’</code> 觸發條件改成 <code class=\"markup--code markup--p-code\">‘ready’</code> ：</p>\\n<pre>// app/assets/javascripts/application.js</pre>\\n<pre>// 原本是<br>// $(document).on(<strong class=\"markup--strong markup--pre-strong\">'turbolinks:load'</strong>, function() {<br>//   console.log('I'm loading');<br>// });<br>// 改成</pre>\\n<pre>$(document).on(<strong class=\"markup--strong markup--pre-strong\">'ready'</strong>, function() {<br>  console.log('I'm loading');<br>});</pre>\\n<p>Turbolinks 的<a href=\"https://github.com/turbolinks/turbolinks/issues/281\" data-href=\"https://github.com/turbolinks/turbolinks/issues/281\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">這個討論</a>有提到一些其他的作法，比如說在 <code class=\"markup--code markup--p-code\">&lt;head&gt;</code> 加一些程式碼或是使用 <code class=\"markup--code markup--p-code\">requestAnimationFrame</code>，但是目前似乎還沒有一個完美的解法。</p>\\n<h3>Connect to CDN</h3>\\n<p>不得不說，這真的是個 CP 值很高的東西啊！CDN 全名是 Content Distributed Network，它的概念很簡單，前面不是說網站的伺服器是在美國嗎？CDN 會在全球各地設節點，然後把放在美國伺服器的網站內容複製到這些節點，當有人想要連線到網站，請求會被自動送到離這個人最近的節點，然後從那邊載入。我在<a href=\"https://jennycodes.me/posts/%E5%BE%9E%E9%BB%9E%E4%B8%80%E5%80%8B-url-%E5%88%B0%E7%9C%8B%E5%88%B0%E9%A0%81%E9%9D%A2%E4%B8%AD%E9%96%93%E7%99%BC%E7%94%9F%E4%BA%86%E4%BB%80%E9%BA%BC%E4%BA%8B%E4%B8%8A%E9%9B%86\" data-href=\"https://jennycodes.me/posts/%E5%BE%9E%E9%BB%9E%E4%B8%80%E5%80%8B-url-%E5%88%B0%E7%9C%8B%E5%88%B0%E9%A0%81%E9%9D%A2%E4%B8%AD%E9%96%93%E7%99%BC%E7%94%9F%E4%BA%86%E4%BB%80%E9%BA%BC%E4%BA%8B%E4%B8%8A%E9%9B%86\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">《從點一個 URL 到看到頁面中間發生了什麼事？》</a>裡面有比較詳細的介紹。</p>\\n<p>最棒的是，網路上提供 CDN 的公司—像是 <a href=\"https://www.cloudflare.com/\" data-href=\"https://www.cloudflare.com/\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">CloudFlare</a>—有提供免費的服務，而且設定超簡單，就不多介紹了，總之，還沒申請的快去吧！你不會後悔的。</p>\\n<h3>Add jQuery Lazy Plugin</h3>\\n<p>做到這邊，其實算是可以收手了（？）只是想到前公司專案有用過一個函式庫，讓網站上的圖片部分做到延遲載入（ delayed content loading），其實跟 async 是相同的概念。考量到之後應該會在文章中放不少照片，到時候這個函式庫就會發揮很大效用，所以就先一鼓作氣，順道解決。</p>\\n<p>其實加入這個也不難，就是依照<a href=\"http://jquery.eisbehr.de/lazy/\" data-href=\"http://jquery.eisbehr.de/lazy/\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">網站指示</a>做就好了。唯一一點需要注意的是如果你的 jQuery 是在 application.js 中，那 jQuery Lazy 也要下載放在專案裡面，不能直接從 CDN 載入，不然使用 async 後就會出現上面提到的， 載入順序亂掉導致出現錯誤。</p>\\n<h3>更上一層樓：Compress Your Images</h3>\\n<p>當網站規模逐漸擴大，除了想辦法提升應用程式本身的效能之外，還可以檢視使用資源本身大小，像是如果是有大量使用照片的話，則在匯入時就先處理過照片就會顯著提升載入效能。這裡 Yuna 推薦網站 <a href=\"https://www.websiteplanet.com/webtools/imagecompressor/\" data-href=\"https://www.websiteplanet.com/webtools/imagecompressor/\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">Websiteplanet’s ImageCompressor</a>，操作簡單到你只要把圖片拉近框框裡面就好了。隨便丟了一張圖片來測，原本 676KB 的照片被壓縮到只剩下 179 KB，不錯。</p>\\n<p>儘管它已經很方便了，如果不想要每次上傳都要去先去網站手動壓縮的話，可以考慮 <a href=\"https://github.com/toy/image_optim\" data-href=\"https://github.com/toy/image_optim\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">ImageOptim</a> 這個服務。它同樣是免費的，但強大的地方在它直接是 gem 的形式—也就是說你可以用程式碼自動壓縮傳進來的圖片，非常厲害！</p><p>更進一步還有各式各樣的快取，例如 <a href=\"https://memcached.org/\" data-href=\"https://memcached.org/\" class=\"markup--anchor markup--p-anchor\" rel=\"noopener nofollow\" target=\"_blank\">Memcached</a>, <a href=\"https://redis.io/\" data-href=\"https://redis.io/\" class=\"markup--anchor markup--p-anchor\" rel=\"noopener nofollow\" target=\"_blank\">Redis</a> 等（其實 CDN 也是快取的一種）等你去玩，不過對於一個如此規模的部落格而言，現在這樣足夠了。所以就暫且告一段落，繼續往下個目標前進。</p>\\n<h4>參考資料</h4>\\n<div>\\n<a href=\"https://developers.google.com/speed/pagespeed/insights\" data-href=\"https://developers.google.com/speed/pagespeed/insights\" class=\"markup--anchor markup--mixtapeEmbed-anchor\" title=\"https://developers.google.com/speed/pagespeed/insights\" rel=\"nofollow\"><strong class=\"markup--strong markup--mixtapeEmbed-strong\">PageSpeed Insights</strong><br>developers.google.com</a><a href=\"https://developers.google.com/speed/pagespeed/insights\" class=\"js-mixtapeImage mixtapeImage mixtapeImage--empty u-ignoreBlock\" data-media-id=\"0d1c9c440825b5f9a40c6d6109a250bf\"></a>\\n</div>\\n<div>\\n<a href=\"https://rhardih.io/2015/03/rails-4-gotcha-asynchronous-loading-of-javascript-in-development-mode/\" data-href=\"https://rhardih.io/2015/03/rails-4-gotcha-asynchronous-loading-of-javascript-in-development-mode/\" class=\"markup--anchor markup--mixtapeEmbed-anchor\" title=\"https://rhardih.io/2015/03/rails-4-gotcha-asynchronous-loading-of-javascript-in-development-mode/\" rel=\"nofollow\"><strong class=\"markup--strong markup--mixtapeEmbed-strong\">Ruby on Rails Gotcha: Asynchronous loading of Javascript in development mode</strong><br>rhardih.io</a><a href=\"https://rhardih.io/2015/03/rails-4-gotcha-asynchronous-loading-of-javascript-in-development-mode/\" class=\"js-mixtapeImage mixtapeImage u-ignoreBlock\" data-media-id=\"e420e199f372a413087a36862199da20\" data-thumbnail-img-id=\"0*vfj_8UKliSaBzaEE\" style=\"background-image: url(https://cdn-images-1.medium.com/fit/c/320/320/0*vfj_8UKliSaBzaEE);\"></a>\\n</div>\\n<div>\\n<a href=\"https://github.com/turbolinks/turbolinks/issues/28\" data-href=\"https://github.com/turbolinks/turbolinks/issues/28\" class=\"markup--anchor markup--mixtapeEmbed-anchor\" title=\"https://github.com/turbolinks/turbolinks/issues/28\" rel=\"nofollow\"><strong class=\"markup--strong markup--mixtapeEmbed-strong\">turbolinks:load and async script loading · Issue #28 · turbolinks/turbolinks</strong><br>github.com</a><a href=\"https://github.com/turbolinks/turbolinks/issues/28\" class=\"js-mixtapeImage mixtapeImage u-ignoreBlock\" data-media-id=\"08cb8eb1aa903750cea2a8a7f9f1b19d\" data-thumbnail-img-id=\"0*1mqVVTrJsu4_klNz\" style=\"background-image: url(https://cdn-images-1.medium.com/fit/c/320/320/0*1mqVVTrJsu4_klNz);\"></a>\\n</div>\\n<div>\\n<a href=\"https://github.com/turbolinks/turbolinks/pull/274\" data-href=\"https://github.com/turbolinks/turbolinks/pull/274\" class=\"markup--anchor markup--mixtapeEmbed-anchor\" title=\"https://github.com/turbolinks/turbolinks/pull/274\" rel=\"nofollow\"><strong class=\"markup--strong markup--mixtapeEmbed-strong\">If page is interactive, fire pageLoaded() immediately by nateberkopec · Pull Request #274 ·…</strong><br>github.com</a><a href=\"https://github.com/turbolinks/turbolinks/pull/274\" class=\"js-mixtapeImage mixtapeImage u-ignoreBlock\" data-media-id=\"bfe0e93e81663e85b54a67a6ad1488fd\" data-thumbnail-img-id=\"0*zbm5TkVsDWi-AMtm\" style=\"background-image: url(https://cdn-images-1.medium.com/fit/c/320/320/0*zbm5TkVsDWi-AMtm);\"></a>\\n</div>\\n<p><a href=\"http://jquery.eisbehr.de/lazy/#basic-usage\" data-href=\"http://jquery.eisbehr.de/lazy/#basic-usage\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener nofollow noopener\" target=\"_blank\">http://jquery.eisbehr.de/lazy</a></p><p>文章同步發表於 <a href=\"https://medium.com/@jinghua.shih\">Medium</a>。",
        "status": 1,
        "description": "我如何讓一個網站載入速度提升 173%",
        "created_at": "2019-02-08T04:10:20.629382",
        "updated_at": "2019-04-06T05:51:08.223544",
        "slug": "rails-網站效能提升實錄",
        "medium_url": "https://medium.com/@jinghua.shih/rails-%E7%B6%B2%E7%AB%99%E6%95%88%E8%83%BD%E6%8F%90%E5%8D%87%E5%AF%A6%E9%8C%84-6fb6fcbcc745"
    },
    {
        "id": 7,
        "title": "從點一個 URL 到看到頁面中間發生了什麼事？(上集）",
        "body": "<p></p>\\n<p>這題的有趣之處是，任何人都回答得出來，但你對網頁知識的瞭解程度會清楚展現在你的回答中。你可以拆三步，花一分鐘講完，也可以為其中每個發生的事情寫成一系列叢書，端看你對網頁的知識到哪裡（還有時間夠不夠）。如果想自己挑戰看看的，可以先擬出一個回答，再去偉哉網路上看看大神們都如何接招或是繼續看下去。</p>\\n<p>Hindsight: 原本天真地想「大概四個小時就寫完了吧？」殊不知最後花了四倍以上的時間，唉。但也幸好我這樣以為，不然可能就不會寫了哈哈哈。下一篇在這裡：<a href=\"https://jennycodes.me/posts/%E5%BE%9E%E9%BB%9E%E4%B8%80%E5%80%8B-url-%E5%88%B0%E7%9C%8B%E5%88%B0%E9%A0%81%E9%9D%A2%E4%B8%AD%E9%96%93%E7%99%BC%E7%94%9F%E4%BA%86%E4%BB%80%E9%BA%BC%E4%BA%8B%E4%B8%8B%E9%9B%86\" target=\"_blank\">從點一個 URL 到看到頁面中間發生了什麼事？(下集）</a>。</p><p>我把過程分成四個部分：</p>\\n<blockquote>一、瀏覽器收到 URL，找到對應的 Web Server，發送 HTTP 請求</blockquote>\\n<blockquote>二、Web Server 接到請求，將請求送到應用程式</blockquote>\\n<blockquote>三、應用程式處理請求，打包成 HTTP 回應</blockquote>\\n<blockquote>四、瀏覽器收到回應，呈現頁面</blockquote>\\n<p>前兩節放在上集，後兩節放下集。在這個回答中有牽涉到網頁應用程式的部分（第二、三節）我會聚焦在一個以一個 Rails 框架寫成的應用程式作為例子。</p>\\n<p>另外，這篇文章有部分（好啦其實是所有）段落會有中英夾雜的情況，原因是有些專有名詞平常溝通時就不會使用翻譯，硬要用中文反而顯得奇怪，但是基本上這裡每個專有名詞都會同時放上中文與英文，避免翻譯不一樣導致無法理解。</p>\\n<p>開始吧！</p><h3><strong class=\"markup--strong markup--h3-strong\">一、瀏覽器收到 URL，找到對應的網域，發送 HTTP 請求</strong></h3>\\n<p><em class=\"markup--em markup--p-em\">關鍵字：DNS, CDN, TCP, HTTP</em></p>\\n<p>請求流向：URL → DNS 找 IP → TCP 連線 → 發送 HTTP 請求</p>\\n<h4><strong class=\"markup--strong markup--h4-strong\">網域名稱系統 Domain Name Server (DNS)</strong></h4>\\n<p>瀏覽器一收到 URL，首先會利用 DNS (Domain Name Server)，將人類可辨識的、以英文與數字組成的網址，轉換成機器可辨識的，以純數字組成的 IP 位址（像是 google.com 的其中一個 IP 位址是 172.217.160.78）。可以將 DNS 想像成一本超大型戶口名簿，我們輸入的網址是姓名，是人類稱呼彼此的方式，而 IP 位址是身分證字號，獨一無二，是電腦識別身份的方式。</p>\\n<p>在查找 DNS 的過程，會經過一個四階層的<a href=\"https://en.wikipedia.org/wiki/Domain_Name_System#Recursive_and_caching_name_server\" data-href=\"https://en.wikipedia.org/wiki/Domain_Name_System#Recursive_and_caching_name_server\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">快取</a>（瀏覽器 → 操作系統 → 操作系統中 hosts 文件 → LDNS），加速查找過程。</p>\\n<h4>內容傳遞網路 Content Delivery Network (CDN)</h4>\\n<blockquote>A CDN allows for the quick transfer of assets needed for loading Internet content including HTML pages, javascript files, stylesheets, images, and videos.</blockquote>\\n<p>節錄自 <a href=\"https://www.cloudflare.com/learning/cdn/what-is-a-cdn/\" data-href=\"https://www.cloudflare.com/learning/cdn/what-is-a-cdn/\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">CloudFlare</a>。</p>\\n<p>CDN 的主要存在目的，是確保頁面載入時間，解決訪問延遲的問題。當今天一個台灣的使用者發送請求到一個主機位置在美國的網站 A，他就必須要連線去美國取得資料，美國的伺服器再把資料傳回台灣，這樣一來一往中間傳輸的成本就會反映在網頁載入的速度。所以當一個網站服務量大，想要確保從世界各地的使用者連線到網站都能夠有同樣的速度，CDN 就可以登場了。</p>\\n<p>CDN 的運作原理是，在世界各個點設立伺服器，利用快取將原本主機上的資料複製到每個伺服器，而當使用者要連線時，會自動抓離使用者最近的那個快取伺服器來連線。假設今天網站 A 用 CDN 在日本的伺服器存了一份檔案，那麼台灣的使用者要連線到 A 時，就會去找日本的伺服器，不用大老遠跑到美國去撈資料了。</p>\\n<p>如果網站有使用 CDN 服務的話，則一個 URL 的 IP 位址會有很多個，在這個步驟中會依照發送請求的位置、網路流量、負載狀況等等決定要導流到哪一個 IP 位址（哪一個伺服器）。</p>\\n<h4>TCP 協議與 HTTP 協議</h4>\\n<p>找到 IP 位址後，瀏覽器利用 <a href=\"https://zh.wikipedia.org/wiki/%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AE\" data-href=\"https://zh.wikipedia.org/wiki/%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AE\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">TCP 協議</a> 跟 web server 建立連線（俗稱握手），再根據 URL 的內容產生 http 請求。TCP 連線的標頭中會包含 source port 與destination port，一般來說，destination port 默認的值是 80，意思是網頁伺服器通常會監聽 port 80 來接收 http 請求，而 source port 則會隨著使用者的瀏覽器作業系統有所變化。當我們使用 localhost:3000，我們就是打開 port 3000 來監聽請求。</p>\\n<p>一個典型的 HTTP 請求包含 header（標頭）, action（方法，本例中用 GET ）, body（內容），有興趣的可以看看 Mozilla 的 <a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Identifying_resources_on_the_Web\" data-href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Identifying_resources_on_the_Web\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">Http Basics</a> 這篇文章。</p><h3>二、Web Server 接到請求，將請求送到應用程式</h3>\\n<p><em class=\"markup--em markup--p-em\">關鍵字：Middleware, Web Server, Application Server, Rack</em></p>\\n<p>請求流向： (load balance) → web server → application server → application</p>\\n<p>在介紹這些名詞之前，先來介紹一下中介軟體。</p>\\n<h4>中介軟體 Middleware</h4>\\n<blockquote>The purpose of middleware is to provide high level abstraction that you can use to easily bind together the functionality that allows your web application to receive, and then respond to client requests.</blockquote>\\n<p>節錄自<a href=\"https://www.coursera.org/learn/web-app/lecture/MvV3i/video-2-middleware-in-web-apps\" data-href=\"https://www.coursera.org/learn/web-app/lecture/MvV3i/video-2-middleware-in-web-apps\" class=\"markup--anchor markup--p-anchor\" rel=\"noopener nofollow\" target=\"_blank\"> Web Application Development: Basic Concepts</a>。</p>\\n<p>中介軟體原本是用在分散式系統（distributed systems）中。分散式系統是一群電腦透過網路互相傳遞訊息的系統，簡言之就是多台電腦一起合作出任務，<a href=\"https://medium.freecodecamp.org/a-thorough-introduction-to-distributed-systems-3b91562c9b3c\" data-href=\"https://medium.freecodecamp.org/a-thorough-introduction-to-distributed-systems-3b91562c9b3c\" class=\"markup--anchor markup--p-anchor\" rel=\"noopener nofollow\" target=\"_blank\">FreeCodeCamp</a> 有一篇詳細的介紹，很長但值得一看。這群電腦合作的過程中，必定要有一些方法才能保持個體間的合作順暢，而這就是中介軟體的工作。</p>\\n<p>這裡中介軟體做的事情，是接受 http 請求，把請求交給應用程式的 scripts/services、處理請求、打包成回應後送回客戶端。因為有了中介軟體，開發人員不需要去煩惱有關 web server, app server 這些設定，只要專心把程式碼寫好就好了。MVC 架構其實就是建立在這些中介軟體上，讓我們的程式碼能夠與 web server 溝通，所以也可以將中介軟體想像成客戶端與伺服器端的橋樑（the dash in client-server）。</p>\\n<p>在這樣的定義下，這一節所做的事，其實都是中介軟體，以下分別介紹。</p>\\n<h4><strong class=\"markup--strong markup--h4-strong\">負載均衡 Load Balance</strong></h4>\\n<p>負載均衡其實就是分流。今天當一台 server 不能負荷請求的數量，加開了第二台、第三 server 之後，就要開始思考如何將請求分配給這些機器。有幾種方式能做到，其中一種是<strong class=\"markup--strong markup--p-strong\">反向代理（reverse proxy server）</strong>。</p>\\n<p>反向代理的原理，可以想像一個場景：今天到餐廳用餐，你向服務生點了一道紅蘿蔔炒蛋炒飯，十五分鐘後服務生把你要的紅蘿蔔炒蛋炒飯給你。你不知道服務生把點菜單送進廚房後發生了什麼事，或實際上是誰炒了你的紅蘿蔔炒蛋炒飯，你唯一能掌握的是服務生的樣子，還有你桌上的紅蘿蔔炒蛋炒飯。</p>\\n<p>因此，反向代理除了能夠實現負載均衡，同時還有許多功能，像是提升網路安全性，或是像 CDN 也是一個反向代理的延伸應用。常見的反向代理軟體包含 Nginx, Apache HTTP server 與 HAProxy。</p>\\n<h4><strong class=\"markup--strong markup--h4-strong\">網頁伺服器 Web Server</strong></h4>\\n<blockquote>網頁伺服器 主要的功能是接受並且回應用戶端請求的網頁靜態內容。用戶端十之八九是瀏覽器或是手機應用程式，而請求與回應都是以 HTTP 的形式。</blockquote>\\n<p>翻譯節錄自<a href=\"https://www.nginx.com/resources/glossary/application-server-vs-web-server/\" data-href=\"https://www.nginx.com/resources/glossary/application-server-vs-web-server/\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\"> Nginx 官網</a>。</p>\\n<p>其實網頁伺服器有兩個意思，一個是可以處理 HTTP 請求的伺服器（似乎有人直接叫它 server 以作區分），一個是提供網頁的伺服器程式。總之，每一台 server 都會最少執行一個 web server。</p>\\n<p>一般常見的網頁伺服器供應商有 Apache 與 Nginx 。</p>\\n<h4><strong class=\"markup--strong markup--h4-strong\">應用程式伺服器 Application Server</strong></h4>\\n<blockquote>應用程式伺服器是一種提供一個應用程式執行環境的軟體框架。</blockquote>\\n<p>翻譯節錄自<a href=\"https://en.wikipedia.org/wiki/Application_server\" data-href=\"https://en.wikipedia.org/wiki/Application_server\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">維基百科</a>。</p>\\n<p>白話地說，就是一個能夠讓你寫的程式碼可以跑起來的框架。 在 Rails 中常見的 app server 選項有 WEBrick, Unicorn, Thin, Puma, Passenger，現在 <a href=\"https://github.com/puma/puma\" data-href=\"https://github.com/puma/puma\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">Puma</a> 是 Rails 預設的伺服器。很多 app server 也會同時提供負載均衡、故障轉移等功能，讓開發者夠專注在商業邏輯。</p>\\n<h4>Rack，Rails 的中介軟體管理者</h4>\\n<blockquote>A Rack application is a Ruby object (not a class) that responds to <code class=\"markup--code markup--blockquote-code\"><em class=\"markup--em markup--blockquote-em\">call</em></code>. It takes exactly one argument, the <strong class=\"markup--strong markup--blockquote-strong\">environment</strong> and returns an Array of exactly three values: The <strong class=\"markup--strong markup--blockquote-strong\">status</strong>, the <strong class=\"markup--strong markup--blockquote-strong\">headers</strong>, and the <strong class=\"markup--strong markup--blockquote-strong\">body</strong>.</blockquote>\\n<p>摘錄自 <a href=\"https://www.rubydoc.info/github/rack/rack/master/file/SPEC\" data-href=\"https://www.rubydoc.info/github/rack/rack/master/file/SPEC\" class=\"markup--anchor markup--p-anchor\" rel=\"noopener nofollow\" target=\"_blank\">RubyDoc</a>。</p>\\n<p>Rack 是中介軟體中的 middleware framework。Middleware framework 是連接網頁框架 (web application framework) 與應用程式伺服器 (application server) 的工具。基本上網頁開發人員不會需要動到這裏。而 Rails 中的 middleware framework 就叫做 Rack。</p>\\n<p>Rack 把 Rails 中一系列 middleware components （通常用 Ruby 寫成）用 stack 堆疊起來，使開發者便於操作。要看 Rails 裡面有裝了哪些中介軟體，在應用程式資料夾的終端機上打 <code class=\"markup--code markup--p-code\">$rake middleware</code>就可以看到了。當我們打 <code class=\"markup--code markup--p-code\">$rails server</code>，我們實際上做的事情是建立了一個 Rack::Server，連接到 app server (在 Rails 5 中沒有特別指名的話就是預設的 puma），並且呼叫那一系列 middleware 來與 app server 合作。</p>\\n<p>根據 Rack 的定義，我們其實可以實作一個 Rack middleware，像是<a href=\"http://gafur.me/2018/01/29/writing-rack-middleware.html\" data-href=\"http://gafur.me/2018/01/29/writing-rack-middleware.html\" class=\"markup--anchor markup--p-anchor\" rel=\"noopener nofollow\" target=\"_blank\">這個範例</a>。</p>\\n<p>如果你確實在終端機打了 <code class=\"markup--code markup--p-code\">$rake middleware</code>，你會在最後一行看到</p>\\n<blockquote>run [your app name]::Application.routes</blockquote>\\n<p>代表這個請求在經過一系列中介軟體，最後被送到 Rails 的路由器，由此便進入 MVC 的闖關世界了！所以下一篇，將會從路由開始。</p><h3>參考資料</h3>\\n<p><a href=\"http://Web%20Application%20Development:%20Basic%20Concepts\" data-href=\"http://Web Application Development: Basic Concepts\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">Web Application Development: Basic Concepts</a> (很推的一門 coursera 課程)</p>\\n<p><a href=\"http://fex.baidu.com/blog/2014/05/what-happen/\" data-href=\"http://fex.baidu.com/blog/2014/05/what-happen/\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">從輸入 URL 到頁面加載完成的過程中都發生了什麼事情？</a></p>\\n<p><a href=\"https://medium.com/@maneesha.wijesinghe1/what-happens-when-you-type-an-url-in-the-browser-and-press-enter-bb0aa2449c1a\" data-href=\"https://medium.com/@maneesha.wijesinghe1/what-happens-when-you-type-an-url-in-the-browser-and-press-enter-bb0aa2449c1a\" class=\"markup--anchor markup--p-anchor\" target=\"_blank\">What happens when you type an URL in the browser and press enter?</a></p>\\n<p><a href=\"https://www.incapsula.com/cdn-guide/what-is-cdn-how-it-works.html\" data-href=\"https://www.incapsula.com/cdn-guide/what-is-cdn-how-it-works.html\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">What is a CDN? How does a CDN work?</a></p>\\n<p><a href=\"https://zhuanlan.zhihu.com/p/28939811\" data-href=\"https://zhuanlan.zhihu.com/p/28939811\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">CDN 知識詳解</a></p>\\n<p><a href=\"https://medium.freecodecamp.org/a-thorough-introduction-to-distributed-systems-3b91562c9b3c\" data-href=\"https://medium.freecodecamp.org/a-thorough-introduction-to-distributed-systems-3b91562c9b3c\" class=\"markup--anchor markup--p-anchor\" rel=\"noopener nofollow\" target=\"_blank\">A Thorough Introduction to Distributed Systems</a></p><p>文章同步發表於 <a href=\"https://medium.com/@jinghua.shih\">Medium</a>。",
        "status": 1,
        "description": "那天在網路上看到這個題目，覺得實在是非常有趣，不挑戰看看對不起自己。",
        "created_at": "2019-01-11T14:35:03.533111",
        "updated_at": "2019-02-23T02:53:05.289946",
        "slug": "從點一個-url-到看到頁面中間發生了什麼事上集",
        "medium_url": "https://medium.com/@jinghua.shih/%E5%BE%9E%E9%BB%9E%E4%B8%80%E5%80%8B-url-%E5%88%B0%E7%9C%8B%E5%88%B0%E9%A0%81%E9%9D%A2%E4%B8%AD%E9%96%93%E7%99%BC%E7%94%9F%E4%BA%86%E4%BB%80%E9%BA%BC%E4%BA%8B-%E4%B8%8A%E9%9B%86-56a4791faf8c"
    },
    {
        "id": 9,
        "title": "Container 概念筆記",
        "body": "<p></p>\\n<p>先一句話簡介以上四個字的關係：</p>\\n<blockquote>Docker 是一個讓 Container 標準化的專案 /工具，而 Kubernetes 是用來管理 Container 的系統。Microservice 是基於 Container 之上快速發展起來的概念。</blockquote>\\n<p>很明顯的，要暸解以上這些東西，就要先暸解 Container。但要暸解 Container，還要先暸解一個概念叫做虛擬機器。</p>\\n<h3>虛擬機器 Virtual Machine</h3>\\n<p>在 Container 的概念尚未開始流行之前，一般而言一個應用程式的執行會是透過虛擬機器（以下簡稱 VM）來進行。為什麼不直接執行應用程式呢？因爲每台主機的環境配置、作業系統都不盡相同，所以當一台主機要直接執行用另外一台主機開發出來的應用程式，很可能會因為環境不一致的關係而失敗。VM 的概念是在將應用程式打包時，除了程式本身，還順便一起打包開發的作業系統，當任何一台主機（Host OS）要執行此應用程式時，就可以在 VM 中先下載裝有此應用程式所需一切資源的作業系統（此稱 Guest OS）， 模擬出一個熟悉的空間給此應用程式，這樣就能確保應用程式的順利執行。</p>\\n<p>VM 的好處有</p>\\n<ol>\\n<li name=\"81a3\" id=\"81a3\" class=\"graf graf--li graf-after--p\">\\n<strong class=\"markup--strong markup--li-strong\">軟硬體分離</strong>：因為應用程式執行的環境是虛擬的，所以硬體不用被限制在特定廠牌或是規格。</li>\\n<li name=\"a9f5\" id=\"a9f5\" class=\"graf graf--li graf-after--li\">\\n<strong class=\"markup--strong markup--li-strong\">安全性高</strong>：對作業系統而言，看起來就像是在一臺正常的實體機器中，在 VM 中做的動作不會影響到 Host OS，並且就算多個 VM 在同一臺實體伺服器中執行，彼此之間也都是獨立互不干擾的。</li>\\n</ol>\\n<p>但 VM 同時也有一個顯而易見的缺點：冗。時間上來說，每次都要先在 VM 裡面裝好一套作業系統才能執行應用程式，建好作業系統也要等開機，所以 VM 的建立速度就不會很快（大約是幾十秒到幾分鐘）。空間上來說，一套作業系統大都上百 MB，就算應用程式本身只有幾 KB，還是必須要耗費一整個作業系統的資源。資源分配上來說，實體伺服器不只要分配資源給應用程式本身，也會需要將一部份運算資源分給作業系統的執行，是個必要之惡。</p>\\n<h3>容器 Container</h3>\\n<p>為了改善 VM 不能把錢（資源）花在刀口上的缺憾，Container 登場了。</p>\\n<p>Container 同樣是將應用程式連同其所需環境（相關程式碼、函式庫、環境配置檔）一同打包的技術，但是在 Container 中不需要安裝作業系統就能執行應用程式。既然 Container 不像 VM 那樣自己的作業系統自己做，那 Container 要在哪裡運行呢？答案是在 Host OS 的核心系統層。</p>\\n<p>所有 Container 共用 Host OS，並建立資源控管機制來分配 Host OS 上的系統資源，因此省去了執行 Guest OS 的時間與心力，而能夠同時做到每個 Container 互相獨立。就像在雨水中旋開的一把把雨傘， Container 在同一個空間中，卻又彼此有自己獨立的傘下空間。</p>\\n<p>所以說，VM 的中心是作業系統，而 Container 的中心是應用程式。</p>\\n<p>Container 的優勢基本上都跟甩掉了大個子 Guest OS 有關：</p>\\n<ol>\\n<li name=\"d719\" id=\"d719\" class=\"graf graf--li graf-after--p\">\\n<strong class=\"markup--strong markup--li-strong\">執行速度快</strong>：相比 VM 以分鐘為單位，Container 執行速度可以以秒為單位。</li>\\n<li name=\"9721\" id=\"9721\" class=\"graf graf--li graf-after--li\">\\n<strong class=\"markup--strong markup--li-strong\">儲存空間小</strong>：相比 VM 以 GB 為單位，Container 執行速度以 MB 為單位。</li>\\n<li name=\"d6e1\" id=\"d6e1\" class=\"graf graf--li graf-after--li\">\\n<strong class=\"markup--strong markup--li-strong\">資源更有效運用</strong>：免去了執行 Guest OS 的義務，同一台主機上可以裝載的 Container 數量可以是 VM 的好幾倍。</li>\\n</ol>\\n<p>但 Container 也不是一個完美情人。比如說它沒有建立自己的作業系統，所以只能依賴 Host OS，並且縱然它解決了很多 VM 的限制，想要體驗 Container 的完整威力，就要先將應用程式變成等等會提到的 Microservice，不然 Container 就只會是一個讓你比較容易打包的工具而已。</p>\\n<h3>Docker</h3>\\n<blockquote>Docker provides tooling and a platform to manage the lifecycle of your containers:</blockquote>\\n<blockquote>- Develop your application and its supporting components using containers.</blockquote>\\n<blockquote>- The container becomes the unit for distributing and testing your application.</blockquote>\\n<blockquote>- When you’re ready, deploy your application into your production environment, as a container or an orchestrated service. This works the same whether your production environment is a local data center, a cloud provider, or a hybrid of the two.</blockquote>\\n<p>節錄自 <a href=\"https://docs.docker.com/engine/docker-overview/\" data-href=\"https://docs.docker.com/engine/docker-overview/\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">Docker 官網</a>。</p>\\n<p>Docker 是目前最流行的一個容器化技術。它創造了一個標準化的 container 製造程序，讓應用程式具有相同的封裝方式、啟動方式、存取方式，不用修改就能在任何支援 Docker 的平臺上執行。</p>\\n<p>Docker 映像檔（Dockerfile）是讓 Docker 之所以強大的關鍵（之一）。Container 在打包的過程，所有這個 Container 需要的程式和設定資訊都會放在 Dockerfile 中，於是在所有支援 Docker 的環境中執行這個 Dockerfile，就能夠確保建立一模一樣的 Container。</p>\\n<p>Docker 一個很大的影響是波及了 PaaS （平台即服務）的生計，因為 IaaS 平臺只要支援 Docker，就可以執行 Container 中的應用程式，不再需要設定 Virtual Machine，因此很容易就可以達成 PaaS 的功能。</p>\\n<p>想要看有更深入一點的細節但又不要太深的導覽文章可以參考<a href=\"https://www.ithome.com.tw/news/91839\" data-href=\"https://www.ithome.com.tw/news/91839\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">這篇文章</a>。</p>\\n<h3>Kubernetes</h3>\\n<p>有了 Container 改善傳統 Virtual Machine 的笨重、有了 Docker 來標準化 Container 的製造，再一個能夠讓你輕鬆管理 Container 的平台，聽起來挺完美的吧？Kubernetes 就是如此平台，所謂 Container Orchestration Platform。Kubernetes 介紹就到這。我是認真的。</p>\\n<h3>微服務 Microservice</h3>\\n<p>容器化的技術讓應用程式能夠被打包成更輕量簡便的包裹，於是「微服務」的概念就興起了。在此風潮之前，傳統的單體架構（Monolithic Architecture）是所有的資源、功能、操作等等放在一個應用程式中，彼此之間關係緊密，因此常常會有改一個小細節就必須波及許多部分的「牽一髮而動全身」的情況，所以可擴展性（Scalability）就不能很高。</p>\\n<p>於是微服務出現了。微服務是一種重新建構應用程式的方法，將一個應用程式中不同的功能切開，變成彼此獨立的運作個體。</p>\\n<p>幾個特色：</p>\\n<ol>\\n<li name=\"d651\" id=\"d651\" class=\"graf graf--li graf-after--p\">\\n<strong class=\"markup--strong markup--li-strong\">低耦合（loose coupling）與高內聚力（high cohesion）: </strong>服務與服務之間關聯低，不互相牽制，而相同功能應該要放在同一個服務之內。如此達成的效果是想要改變一項功能只需要去一個地方修改，並且不會影響到其他服務。</li>\\n<li name=\"d6c5\" id=\"d6c5\" class=\"graf graf--li graf-after--li\">\\n<strong class=\"markup--strong markup--li-strong\">資料管理去中心化（decentralized data management）</strong>：每個服務可以有自己的資料庫。</li>\\n<li name=\"b084\" id=\"b084\" class=\"graf graf--li graf-after--li\">\\n<strong class=\"markup--strong markup--li-strong\">使用 API 溝通：</strong>利用像是 HTTP protocal 來聯絡每個服務。</li>\\n<li name=\"92f9\" id=\"92f9\" class=\"graf graf--li graf-after--li\">\\n<strong class=\"markup--strong markup--li-strong\">服務可以獨立部署</strong>：小組可以直接更新現有服務，而不需要重建和重新部署整個應用程式。</li>\\n</ol>\\n<p><a href=\"https://columns.chicken-house.net/2017/04/15/microservice8-case-study/\" data-href=\"https://columns.chicken-house.net/2017/04/15/microservice8-case-study/\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">這位架構師</a>用了很詳細的篇幅來解釋微服務的概念還有實作的經驗，存參。</p><p>筆記先到這邊。雖然已盡能力所及地確保資料的正確性，但我恐怕還是會有不對/不精確的觀念或用字，如果願意<a href=\"https://jennycodes.herokuapp.com/contact\" data-href=\"https://jennycodes.herokuapp.com/contact\" class=\"markup--anchor markup--p-anchor\" rel=\"noopener nofollow nofollow noopener\" target=\"_blank\">指正我</a>的話我會非常感激！</p>\\n<h4>參考資料</h4>\\n<div>\\n<a href=\"https://azure.microsoft.com/en-us/overview/what-is-a-virtual-machine/\" data-href=\"https://azure.microsoft.com/en-us/overview/what-is-a-virtual-machine/\" class=\"markup--anchor markup--mixtapeEmbed-anchor\" title=\"https://azure.microsoft.com/en-us/overview/what-is-a-virtual-machine/\" rel=\"nofollow\"><strong class=\"markup--strong markup--mixtapeEmbed-strong\">What is a Virtual Machine and How Does it Work | Microsoft Azure</strong><br>azure.microsoft.com</a><a href=\"https://azure.microsoft.com/en-us/overview/what-is-a-virtual-machine/\" class=\"js-mixtapeImage mixtapeImage u-ignoreBlock\" data-media-id=\"dfa62363651210a76d57fc9720011fe6\" data-thumbnail-img-id=\"0*Lp4LB4wYauT8amQX\" style=\"background-image: url(https://cdn-images-1.medium.com/fit/c/320/320/0*Lp4LB4wYauT8amQX);\"></a>\\n</div>\\n<div>\\n<a href=\"https://www.ithome.com.tw/news/91839\" data-href=\"https://www.ithome.com.tw/news/91839\" class=\"markup--anchor markup--mixtapeEmbed-anchor\" title=\"https://www.ithome.com.tw/news/91839\" rel=\"nofollow\"><strong class=\"markup--strong markup--mixtapeEmbed-strong\">Docker風潮席捲IT世界</strong><br>www.ithome.com.tw</a><a href=\"https://www.ithome.com.tw/news/91839\" class=\"js-mixtapeImage mixtapeImage u-ignoreBlock\" data-media-id=\"6b285ee1cd385d29851940ab34e572b3\" data-thumbnail-img-id=\"0*5hydcEeFCIzDQis9\" style=\"background-image: url(https://cdn-images-1.medium.com/fit/c/320/320/0*5hydcEeFCIzDQis9);\"></a>\\n</div>\\n<div>\\n<a href=\"https://www.ithome.com.tw/news/108746\" data-href=\"https://www.ithome.com.tw/news/108746\" class=\"markup--anchor markup--mixtapeEmbed-anchor\" title=\"https://www.ithome.com.tw/news/108746\" rel=\"nofollow\"><strong class=\"markup--strong markup--mixtapeEmbed-strong\">為何Orchestration是企業擁抱容器的關鍵？</strong><br>www.ithome.com.tw</a><a href=\"https://www.ithome.com.tw/news/108746\" class=\"js-mixtapeImage mixtapeImage u-ignoreBlock\" data-media-id=\"90448581ea99fe7f200fb784d4ca96c8\" data-thumbnail-img-id=\"0*2r4A9wDdXKPHc8qY\" style=\"background-image: url(https://cdn-images-1.medium.com/fit/c/320/320/0*2r4A9wDdXKPHc8qY);\"></a>\\n</div>\\n<div>\\n<a href=\"https://medium.com/flow-ci/introduction-to-containers-concept-pros-and-cons-orchestration-docker-and-other-alternatives-9a2f1b61132c\" data-href=\"https://medium.com/flow-ci/introduction-to-containers-concept-pros-and-cons-orchestration-docker-and-other-alternatives-9a2f1b61132c\" class=\"markup--anchor markup--mixtapeEmbed-anchor\" title=\"https://medium.com/flow-ci/introduction-to-containers-concept-pros-and-cons-orchestration-docker-and-other-alternatives-9a2f1b61132c\"><strong class=\"markup--strong markup--mixtapeEmbed-strong\">Introduction to Containers: Concept, Pros and Cons, Orchestration, Docker, and Other Alternatives</strong><br>medium.com</a><a href=\"https://medium.com/flow-ci/introduction-to-containers-concept-pros-and-cons-orchestration-docker-and-other-alternatives-9a2f1b61132c\" class=\"js-mixtapeImage mixtapeImage u-ignoreBlock\" data-media-id=\"3d56e022852d552e01370a2b99e37d73\" data-thumbnail-img-id=\"1*M7_GFGinPfriQIII3SMWNg.png\" style=\"background-image: url(https://cdn-images-1.medium.com/fit/c/320/320/1*M7_GFGinPfriQIII3SMWNg.png);\"></a>\\n</div>\\n<div>\\n<a href=\"https://columns.chicken-house.net/2017/04/15/microservice8-case-study/\" data-href=\"https://columns.chicken-house.net/2017/04/15/microservice8-case-study/\" class=\"markup--anchor markup--mixtapeEmbed-anchor\" title=\"https://columns.chicken-house.net/2017/04/15/microservice8-case-study/\" rel=\"nofollow\"><strong class=\"markup--strong markup--mixtapeEmbed-strong\">架構師觀點 - 轉移到微服務架構的經驗分享 (Part 1)</strong><br>columns.chicken-house.net</a><a href=\"https://columns.chicken-house.net/2017/04/15/microservice8-case-study/\" class=\"js-mixtapeImage mixtapeImage u-ignoreBlock\" data-media-id=\"6ec6e516291b75d02728df733b0064ed\" data-thumbnail-img-id=\"0*72TFoPVgdY5bbFs3\" style=\"background-image: url(https://cdn-images-1.medium.com/fit/c/320/320/0*72TFoPVgdY5bbFs3);\"></a>\\n</div>\\n<div>\\n<a href=\"https://www.docker.com/resources/what-container\" data-href=\"https://www.docker.com/resources/what-container\" class=\"markup--anchor markup--mixtapeEmbed-anchor\" title=\"https://www.docker.com/resources/what-container\" rel=\"nofollow\"><strong class=\"markup--strong markup--mixtapeEmbed-strong\">What is a Container</strong><br>www.docker.com</a><a href=\"https://www.docker.com/resources/what-container\" class=\"js-mixtapeImage mixtapeImage u-ignoreBlock\" data-media-id=\"b8fca127ddd98786dd64841942f9875e\" data-thumbnail-img-id=\"0*lJEvMU1Hpsyeg55F\" style=\"background-image: url(https://cdn-images-1.medium.com/fit/c/320/320/0*lJEvMU1Hpsyeg55F);\"></a>\\n</div><p>文章同步發表於 <a href=\"https://medium.com/@jinghua.shih\">Medium</a>。",
        "status": 1,
        "description": "最近好常聽到 Container, Docker, Kubernetes, Microservice 這些名詞，該是時候來好好梳理清楚了。",
        "created_at": "2019-01-27T00:51:16.204363",
        "updated_at": "2019-02-23T02:55:51.108686",
        "slug": "container-概念筆記",
        "medium_url": "https://medium.com/@jinghua.shih/container-%E6%A6%82%E5%BF%B5%E7%AD%86%E8%A8%98-b0963ae2d7c6"
    },
    {
        "id": 6,
        "title": "Django 網站實做紀錄",
        "body": "<p></p>\\n<figure class=\"text-center\"><img class=\"lazy\" data-action=\"zoom\" data-action-value=\"1*TDS9FqFVjAZXaW3Voh95qg.png\" data-src=\"https://cdn-images-1.medium.com/max/1600/1*TDS9FqFVjAZXaW3Voh95qg.png\"></figure><h3><strong class=\"markup--strong markup--h3-strong\">基本資料</strong></h3>\\n<p>框架｜Django</p>\\n<p>資料庫 ｜ PostgreSQL(production), SQLite(development)</p>\\n<p>部署服務｜Heroku</p>\\n<p>Django 分成三個部分：Model, Template, View (MTV)，其中 Model 負責處理資料庫與模型，Template 負責前端呈現，View 負責後端邏輯，以下分別簡介：</p>\\n<p><strong class=\"markup--strong markup--p-strong\">Model</strong></p>\\n<p>這個專案的資料庫原本使用預設的 SQLite, 而在將應用程式部署到雲端時將 production 環境的資料庫改成 PostgreSQL，development 環境不變。 Django 使用 Object Relational Mapping (ORM) 技術，所以直接用 python 下指令就可以操作資料庫。在模型方面建了三張表，一張紀錄使用者（包含顧客與商家）、一張紀錄杯子、一張管理杯子物流。</p>\\n<p><strong class=\"markup--strong markup--p-strong\">View</strong></p>\\n<p>前端請求與後端資料庫的中間人，乍看之下很像是流行的 MVC (Model, View, Controller) 架構中的 Controller 角色（對是 controller 不是 view 哦），但其實有細微的差異。差異在哪裡？<a href=\"https://docs.djangoproject.com/en/2.1/faq/general/#django-appears-to-be-a-mvc-framework-but-you-call-the-controller-the-view-and-the-view-the-template-how-come-you-don-t-use-the-standard-names\" data-href=\"https://docs.djangoproject.com/en/2.1/faq/general/#django-appears-to-be-a-mvc-framework-but-you-call-the-controller-the-view-and-the-view-the-template-how-come-you-don-t-use-the-standard-names\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">Django 官網</a>回答</p>\\n<blockquote>In our interpretation of MVC, the “view” describes the data that gets presented to the user. It’s not necessarily <em class=\"markup--em markup--blockquote-em\">how</em> the data <em class=\"markup--em markup--blockquote-em\">looks</em>, but <em class=\"markup--em markup--blockquote-em\">which</em> data is presented.</blockquote>\\n<p>他們（Django 的始作俑者們）認為 MVC 架構中 View 的角色處理的是資料的選取而不是資料的呈現方式。所以在他們設計的 MTV 架構中，View 是一個 url 的回呼程式（callback function）負責資料的選取。在<a href=\"https://jennycodes.herokuapp.com/about\" data-href=\"https://jennycodes.herokuapp.com/about\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">我預計要寫的文章</a>中有一篇是關於 MTV 架構與以 MVC 架構的比較。現在先講這樣。</p>\\n<p><strong class=\"markup--strong markup--p-strong\">Template</strong></p>\\n<p>這就是 Django 設計負責「如何呈現」資料的部分，將從 View 傳過來的資料呈現出來，在 MVC 架構中的大致對應是 View。主要使用前端三劍客 html, css 與 Javascript。</p>\\n<p><strong class=\"markup--strong markup--p-strong\">Form</strong></p>\\n<p>這是我覺得 Django 一個滿酷的設計，雖然不是 MTV 三元素之一，但還是特別來介紹一下。由於表單是網頁中一個很常被使用的元素，所以 Django 直接將 Form 寫成一些實用的類別，讓我們可以直接拿來用。Form 表單算是在 View 與 Template 中間，常見做法是另外開一個 forms.py 檔案或是 forms 資料夾，在裡面管理所有表格相關的邏輯。跟 forms 有關的 library 包含了像是 ModelForm，可以直接讓你用模型來創立表單，只要把 routing 設好 then you’re good to go.</p>\\n<p><strong class=\"markup--strong markup--p-strong\">Admin</strong></p>\\n<p>Admin 是 Django 所謂「自帶電池」的特色之一：直接自帶一整個後台管理系統！只要在終端機先建立一個 superuser，就可以進入後台管理模型的實例（新增、修改等等）。另外一個特色就是如果你只要最簡單最快的網站，user 的模型也直接送給你（不過這種情形大概不多）。</p>\\n<h3>操作實例</h3>\\n<p><strong class=\"markup--strong markup--p-strong\">網站設計</strong></p>\\n<p>寫一個網站最重要的就是設計結構了。當初開始做時也是邊摸邊調整，畢竟是第一次用 Django，有很多這個框架的特性還沒有摸熟，還不知道怎麼樣設計才能最大發揮這個框架的特長，所以前前後後其實改了滿多。以下紀錄最終版本。</p>\\n<p><strong class=\"markup--strong markup--p-strong\">模型</strong></p>\\n<p>三張表：使用者、杯子、紀錄。</p>\\n<p>使用者包含商家與顧客，共享同一張資料表。本來研究了很久到底要不要把他們拆開，但是依照目前網站的需求，其實顧客與使用者的差異不大，所以就統一放在一張表。欄位主要是各種使用者基本資料與登入資料。</p>\\n<p>杯子主要有自己獨特的 ID。</p>\\n<p>紀錄表單紀錄了每一次杯子從借出到被還回去的資料，總共有借出店家、借出日期、借出人、還入店家與還入日期。</p>\\n<p>它們之間的關係是：</p>\\n<p>使用者擁有多個杯子與多個紀錄。</p>\\n<p>杯子屬於使用者、有很多紀錄。</p>\\n<p>紀錄屬於使用者與杯子。</p>\\n<p>在每次的表格更新時，都會同時更新這些表單的相關欄位。</p>\\n<p><strong class=\"markup--strong markup--p-strong\">後端發生的事</strong></p>\\n<p>非～～～常簡略的版本是：當使用者發送 url，urls.py 會擔任路由角色把該網址轉給負責的 view (放在 views 資料夾中)，可能是一個 function 或是 class。 view 根據需求處理資料（從 request 傳來的或是去操作資料庫(模型放在 models.py)），或是交給相應的 form（放在 forms 資料夾）處理，最後把要回傳的資料傳到 template (放在 template 資料夾)，呈現給使用者。</p>\\n<h3><strong class=\"markup--strong markup--h3-strong\">自己學到的東西</strong></h3>\\n<ol><li name=\"e6b2\" id=\"e6b2\" class=\"graf graf--li graf-after--h3\"><strong class=\"markup--strong markup--li-strong\">設計資料庫模型的重要（還有自己多不會做這件事）</strong></li></ol>\\n<p>做這個網站時大概有一半的時間都在修模型，深深體會到模型好了剩下的都不是難事了啊。下學期要來找一門資料庫設計的課來修！</p>\\n<p><strong class=\"markup--strong markup--p-strong\">2. Rails 框架的特性</strong></p>\\n<p>為什麼是 Rails 不是 Django 呢？因為其實我自己比較熟 Ruby 語言，唯一用過的框架是 Rails ，所以在寫Rails 的時候沒有實際從一個遠一點的角度來看 Rails 的機會，就算知道它的特性但是沒有比較標準也不會特別有感，直到 Django 的到來。概括來說，Django 雖然號稱自帶電池 (battery included)，但是比起 Rails，它是輕巧靈活（但比較囉唆）的那一個。</p>\\n<p>Rails 注重的是 「Convention over configuration.」也就是說，你只要照著它設定好的那一套邏輯走，你與它就會走得輕鬆寫意又超快，因為很多環境設定它都自動幫你喬好了。但前提是，你要照著它的邏輯走。</p>\\n<p>Django 從架構本身就看得出來，一個 project 底下有好幾個 application，這個 project 可以隨時插拔每個 app，而每個 app 也都可以被拿去其他 project 重複使用。這就是現在漸趨主流的 microservice 概念？好處是元素重複使用率高，當部件越寫越多以後開發就會越來越快。</p>\\n<p><strong class=\"markup--strong markup--p-strong\">3. Javascript</strong></p>\\n<p>雖然這個專案中我的角色不是前端（所以說網站中美麗的畫面都不是我的功勞），但大部分的 JS 是我寫的，也是一個邊學邊做現學現賣的過程，意外地發現其實很有趣！雖然現在還是寫地生疏又心虛，但我相信我們變熟的那一天指日可待。</p>\\n<p>4. Git/Github</p>\\n<p>雖然說平常在實習的時候、自己的專案都會用，但是這算是第一次帶一群人一起用，很多原本不求甚解的眉眉角角都到了這時候才不得不真的弄清楚，也算是一個收穫。</p>\\n<p>最後，<a href=\"https://bevereusage.herokuapp.com/interaction/\" data-href=\"https://bevereusage.herokuapp.com/interaction/\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">網站在這裡</a>。</p><p>文章同步發表於 <a href=\"https://medium.com/@jinghua.shih\">Medium</a>。",
        "status": 1,
        "description": "紀錄一下這學期嘗試邊學邊做的一個 Django 網頁",
        "created_at": "2019-01-09T14:14:29.795024",
        "updated_at": "2019-02-23T02:56:48.535576",
        "slug": "django-網站實做紀錄",
        "medium_url": "https://medium.com/@jinghua.shih/django-%E7%B6%B2%E7%AB%99%E5%AF%A6%E5%81%9A%E7%B4%80%E9%8C%84-d5e0136f4099"
    },
    {
        "id": 29,
        "title": "[Ruby] Hash 的 Default Value",
        "body": "<p></p>\\n<p><strong class=\"markup--strong markup--p-strong\">假設今天你要創建一個 hash，你想要這個 hash 的鍵（key）都有個預設值（default value），你會怎麼寫呢？</strong></p>\\n<p>聽起來很簡單，我本來也一直覺得很簡單，啊不就 <code class=\"markup--code markup--p-code\">Hash.new(“YOUR DEFAULT VALUE”)</code> 就好？如此一來，每個新建立的鍵，都會預先有一個值是 <code class=\"markup--code markup--p-code\">“YOUR DEFAULT VALUE”</code>。比如說</p>\\n<pre>writers = Hash.new('jennycodes') # set default value to 'jennycodes'</pre>\\n<pre>writers['jenny']  <br>=&gt; 'jennycodes'               # default value</pre>\\n<pre>writers['aguy'] = 'dontcare'<br>writers['aguy']<br>=&gt; 'dontcare'                 # assigned value</pre>\\n<p>So far, so fine.</p>\\n<p>假如我們今天想要建立一個 hash，其中每一個 key 都對到一個 array，不用 default value 的話我們會寫出這樣一個 function：</p>\\n<pre>h = Hash.new()</pre>\\n<pre>def add(hsh, key, new_val)<br>  # Create a new array first unless the key already exists.<br>  unless hsh[key]            <br>    hsh[key] = Array.new<br>  end</pre>\\n<pre>  # add the new value to array<br>  hsh[key] &lt;&lt; new_val<br>end</pre>\\n<p>當然這是正確且合理的，但是 Ruby 怎麼可能讓我們寫得這麼冗？精通 Ruby 的我們當然想到直接用 default value 來解決。</p>\\n<pre># pry</pre>\\n<pre>h = Hash.new(<strong class=\"markup--strong markup--pre-strong\">[]</strong>)    # Now we pass a new array as the default value.</pre>\\n<pre>h[1] &lt;&lt; 'a'<br>=&gt;<code class=\"markup--code markup--pre-code\">[\"a\"]            # Good.</code></pre>\\n<pre>h[2] &lt;&lt; 'b'<br>=&gt;<code class=\"markup--code markup--pre-code\">[\"a\", \"b\"]       # Weird. Isn't it supposed to be ['b']?</code></pre>\\n<pre>h[3] &lt;&lt; 'c'<br>=&gt; [\"a\", \"b\", \"c\"]  # Weirder.</pre>\\n<pre>h<br>=&gt; {}               # Where are all the values?</pre>\\n<pre>h.default           <br>=&gt; [\"a\", \"b\", \"c\"]</pre>\\n<p>為什麼會這樣？那些值都跑到哪裡去了？其實，當我們下了諸如 <code class=\"markup--code markup--p-code\">h[1] &lt;&lt; 'a'</code>的指令時，以程式的角度來看是這樣：</p>\\n<blockquote>尋找 <code class=\"markup--code markup--blockquote-code\">h</code> 中有沒有一個 key 叫做 <code class=\"markup--code markup--blockquote-code\">1</code> ？沒有 → 拿出預設值 <code class=\"markup--code markup--blockquote-code\">[]</code> → 把 ‘a’ 加入這個預設值<code class=\"markup--code markup--blockquote-code\">[]</code>中 → 打包收工。</blockquote>\\n<p>這個過程中，並沒有任何<strong class=\"markup--strong markup--p-strong\">賦值</strong>的動作，只是修改了 default value 而已。所以事實上現在 <code class=\"markup--code markup--p-code\">h</code> 的預設值已經不是 <code class=\"markup--code markup--p-code\">[]</code>，而是 <code class=\"markup--code markup--p-code\">[‘a’, ‘b’, ‘c’]</code>，正如 <code class=\"markup--code markup--p-code\">h.default</code> 中所看到的。而最後查看 h 本身仍然是空的，因為我們並沒有把值傳給任何的 key。</p>\\n<h4>解法一：記得加上等於</h4>\\n<pre># pry</pre>\\n<pre>h = Hash.new([])   # Still pass an empty array as default value</pre>\\n<pre>h[1] <strong class=\"markup--strong markup--pre-strong\">+=</strong> ['a']<br>=&gt; [\"a\"]</pre>\\n<pre>h[2] <strong class=\"markup--strong markup--pre-strong\">+=</strong> ['b']<br>=&gt; [\"b\"]</pre>\\n<pre>h[3] <strong class=\"markup--strong markup--pre-strong\">+=</strong> ['c']<br>=&gt; [\"c\"]</pre>\\n<pre>h<br>=&gt; {<strong class=\"markup--strong markup--pre-strong\">1</strong>=&gt;[<strong class=\"markup--strong markup--pre-strong\">\"</strong>a<strong class=\"markup--strong markup--pre-strong\">\"</strong>], <strong class=\"markup--strong markup--pre-strong\">2</strong>=&gt;[<strong class=\"markup--strong markup--pre-strong\">\"</strong>b<strong class=\"markup--strong markup--pre-strong\">\"</strong>], <strong class=\"markup--strong markup--pre-strong\">3</strong>=&gt;[<strong class=\"markup--strong markup--pre-strong\">\"</strong>c<strong class=\"markup--strong markup--pre-strong\">\"</strong>]}</pre>\\n<pre>h.default <br>=&gt; []</pre>\\n<p>賦值的動作其實就相當於 = ，而 <code class=\"markup--code markup--p-code u-paddingRight0 u-marginRight0\">h[1] <strong class=\"markup--strong markup--p-strong\">+=</strong> [‘a’]</code> 其實就是 <code class=\"markup--code markup--p-code u-paddingRight0 u-marginRight0\">h[1] <strong class=\"markup--strong markup--p-strong\">=</strong> h[1] + [‘a’]</code> 的省略寫法，可以看到中間有個賦值的動作發生了，因此這個鍵就會被存在 <code class=\"markup--code markup--p-code\">h</code> 裡。同時，因為<code class=\"markup--code markup--p-code\">h[1] + [‘a’]</code>這個動作是對 <code class=\"markup--code markup--p-code\">h[1]</code> 做的，所以並不會影響到 default value。</p>\\n<p>所以這個解法是「創造一個 default value，並且不改變它」(one default value without mutation)。</p>\\n<h4>解法二：雜湊預設區塊 Hash Default Block</h4>\\n<p>前面 <code class=\"markup--code markup--p-code\">h = Hash.new([])</code> 我們是傳一個引數給 Hash.new 作為<strong class=\"markup--strong markup--p-strong\">雜湊預設物件（default object）</strong>，如果今天我們不傳引數，而是傳一個 block 給 <code class=\"markup--code markup--p-code\">Hash.new</code>，像是 <code class=\"markup--code markup--p-code u-paddingRight0 u-marginRight0\">h = Hash.new<strong class=\"markup--strong markup--p-strong\">{</strong>‘some block’<strong class=\"markup--strong markup--p-strong\">}</strong></code>，那麼會發生兩件事：<br>1. 區塊會以「指向雜湊的址參器」（reference to the hash）以及「當前鍵」（current key）（即將被我們存取的鍵）作為參數，對區塊賦值。<br>2. 區塊回傳值（block’s return value）會變成雜湊鍵的當前值（key’s current value）。</p>\\n<p>直接看例子比較清楚：</p>\\n<pre># pry</pre>\\n<pre>h = Hash.new<strong class=\"markup--strong markup--pre-strong\">{ |hsh, key| hsh[key] = [] }</strong>   <br># Still pass an empty array, but this time<strong class=\"markup--strong markup--pre-strong\"> </strong>to a block</pre>\\n<pre>h[1] &lt;&lt; 'a'<br>=&gt; [\"a\"]</pre>\\n<pre>h[2] &lt;&lt; 'b'<br>=&gt; [\"b\"]</pre>\\n<pre>h[3] &lt;&lt; 'c'<br>=&gt; [\"c\"]</pre>\\n<pre>h<br>=&gt; {<strong class=\"markup--strong markup--pre-strong\">1</strong>=&gt;[<strong class=\"markup--strong markup--pre-strong\">\"</strong>a<strong class=\"markup--strong markup--pre-strong\">\"</strong>], <strong class=\"markup--strong markup--pre-strong\">2</strong>=&gt;[<strong class=\"markup--strong markup--pre-strong\">\"</strong>b<strong class=\"markup--strong markup--pre-strong\">\"</strong>], <strong class=\"markup--strong markup--pre-strong\">3</strong>=&gt;[<strong class=\"markup--strong markup--pre-strong\">\"</strong>c<strong class=\"markup--strong markup--pre-strong\">\"</strong>]}</pre>\\n<pre>h.default <br>=&gt; <strong class=\"markup--strong markup--pre-strong\">nil</strong></pre>\\n<p>這個寫法跟上個寫法的差別是<strong class=\"markup--strong markup--p-strong\">使用預設區塊每一個新的 key 得到的都會是一個新的值，而不是一個已經存在的 default value</strong>。所以 <code class=\"markup--code markup--p-code\">h.default</code> 才會顯示 <code class=\"markup--code markup--p-code\">nil</code>。我們的確直接改變這個值（ <code class=\"markup--code markup--p-code\">&lt;&lt;</code> 的部分），但是因為每個新的鍵都拿到全新的 <code class=\"markup--code markup--p-code\">array</code>，所以依然一切安好。</p>\\n<p>下面是一個很容易犯的錯，不要學：</p>\\n<pre><strong class=\"markup--strong markup--pre-strong\"># WARNING: THIS IS WRONG</strong><br># pry</pre>\\n<pre>h = Hash.new<strong class=\"markup--strong markup--pre-strong\">{ [] }</strong>   # Create a new array in the block. <br>                     # Sounds reasonable, right? </pre>\\n<pre>h[1] &lt;&lt; 'a'       <br>=&gt; [\"a\"]             # Good.</pre>\\n<pre>h[2] &lt;&lt; 'b'<br>=&gt; [\"b\"]             # Good.</pre>\\n<pre>h[3] &lt;&lt; 'c'<br>=&gt; [\"c\"]             # Good.</pre>\\n<pre>h<br>=&gt; <strong class=\"markup--strong markup--pre-strong\">{}                # Here. </strong></pre>\\n<pre>h.default <br>=&gt; nil</pre>\\n<p><code class=\"markup--code markup--p-code\">h</code> 為什麼會是空的？前面講到「區塊回傳值會變成雜湊鍵的當前值」，但是<strong class=\"markup--strong markup--p-strong\">這不代表它有對雜湊鍵賦值</strong>。<strong class=\"markup--strong markup--p-strong\">如果我們沒有指明 </strong><code class=\"markup--code markup--p-code\">h[key]</code><strong class=\"markup--strong markup--p-strong\"> 來接收 [] 這個 block 的回傳值，那麼它就不會存進這個鍵裡面。</strong>所以 h 只會一次次呼叫新的區塊給每一個鍵。</p>\\n<h4>哪種解法好？</h4>\\n<p>都好，只是個人覺得用解法二（雜湊預設區塊）寫比較容易閱讀，寫起來也比較直觀。但是一定要記得正確的寫法，不然到時候出 bug 別說你沒有被警告過！</p><h4>參考資料</h4>\\n<p><a href=\"https://www.books.com.tw/products/0010746213\" data-href=\"https://www.books.com.tw/products/0010746213\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">深入淺出 Ruby：A Brain-Friendly Guide</a></p>\\n<div>\\n<a href=\"https://docs.ruby-lang.org/en/2.6.0/Hash.html\" data-href=\"https://docs.ruby-lang.org/en/2.6.0/Hash.html\" class=\"markup--anchor markup--mixtapeEmbed-anchor\" title=\"https://docs.ruby-lang.org/en/2.6.0/Hash.html\" rel=\"nofollow\"><strong class=\"markup--strong markup--mixtapeEmbed-strong\">class Hash - Documentation for Ruby 2.6.0</strong><br>docs.ruby-lang.org</a><a href=\"https://docs.ruby-lang.org/en/2.6.0/Hash.html\" class=\"js-mixtapeImage mixtapeImage mixtapeImage--empty u-ignoreBlock\" data-media-id=\"c06f5e5a9bdad42affb36ddfcf96d321\"></a>\\n</div>\\n<div>\\n<a href=\"https://stackoverflow.com/questions/16159370/ruby-hash-default-value-behavior\" data-href=\"https://stackoverflow.com/questions/16159370/ruby-hash-default-value-behavior\" class=\"markup--anchor markup--mixtapeEmbed-anchor\" title=\"https://stackoverflow.com/questions/16159370/ruby-hash-default-value-behavior\" rel=\"nofollow\"><strong class=\"markup--strong markup--mixtapeEmbed-strong\">Ruby hash default value behavior</strong><br>stackoverflow.com</a><a href=\"https://stackoverflow.com/questions/16159370/ruby-hash-default-value-behavior\" class=\"js-mixtapeImage mixtapeImage u-ignoreBlock\" data-media-id=\"692fd3309d3c05fa407fb0c3fa8d19bb\" data-thumbnail-img-id=\"0*qyXOZqKskvVjeuIQ\" style=\"background-image: url(https://cdn-images-1.medium.com/fit/c/320/320/0*qyXOZqKskvVjeuIQ);\"></a>\\n</div><p>文章同步發表於 <a href=\"https://medium.com/@jinghua.shih\">Medium</a>。",
        "status": 1,
        "description": "你嘗試在 hash 中使用 array 但是出錯了嗎？",
        "created_at": "2019-02-28T03:24:06.479803",
        "updated_at": "2019-02-28T03:24:06.479803",
        "slug": "ruby-hash-的-default-value",
        "medium_url": "https://medium.com/@jinghua.shih/ruby-hash-%E7%9A%84-default-value-1d29a8ecd398"
    },
    {
        "id": 28,
        "title": "[筆記] Threads in Ruby",
        "body": "<p></p>\\n<h3>Ruby is Single-Threaded</h3>\\n<blockquote>Ruby’s thread is a user-level thread that is originally written. The characteristic of this implementation is a <strong class=\"markup--strong markup--blockquote-strong\">very high portability</strong> in both specification and implementation. Surprisingly a MS-DOS can run the thread. Furthermore, you can expect the same response in any environment. Many people mention that this point is the best feature of Ruby.</blockquote>\\n<blockquote>However, as a trade off for such an extremeness of portability, Ruby abandons the speed. It’s, say, probably the slowest of all user-level thread implementations in this world.</blockquote>\\n<p>節錄自 <a href=\"https://ruby-hacking-guide.github.io/intro.html\" data-href=\"https://ruby-hacking-guide.github.io/intro.html\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">Ruby Hacking Guide</a>。</p>\\n<h4>Thread</h4>\\n<p>Thread 是 program 的執行單位。在一個多核心（core）的裝置，作業系統可以將多個 thread 放在不同核心跑，提升整體表現速度。Thread 會儲存自己在 program 中的位置，所以可以很輕易地切換。Ruby 只會跑在一個 thread 中，所以不會有交換的時候（No switching of tasks taking place），也只會跑在一個核心中。但是如果今天是多核心的電腦，如下圖所示，我們要如何才能夠好好利用這個資源呢？</p>\\n<figure class=\"text-center\"><img class=\"lazy\" data-src=\"https://cdn-images-1.medium.com/max/1600/0*fB0vpZwk9GE8wSk2.png\"><figcaption class=\"imageCaption\">source: <a href=\"https://dev.to/enether/rubys-gil-in-a-nutshell\" data-href=\"https://dev.to/enether/rubys-gil-in-a-nutshell\" class=\"markup--anchor markup--figure-anchor\" rel=\"nofollow noopener\" target=\"_blank\">https://dev.to/enether/rubys-gil-in-a-nutshell</a></figcaption></figure><p>Ruby 有一個 <code class=\"markup--code markup--p-code\">Thread</code> 類別，顧名思義它會幫我們創造一個 native thread 跑在作業系統裡。</p>\\n<p>不過當我們要使用 <code class=\"markup--code markup--p-code\">Thread</code> 的時候，要記得當 main thread 結束了 program 就會結束，所以如果要確保 program 等到所有線程都跑完才結束，就要加上 <code class=\"markup--code markup--p-code\">ThreadsWait</code> 類別（<code class=\"markup--code markup--p-code\">require ‘thwait’</code>）並且在程式裡面宣告 <code class=\"markup--code markup--p-code\">ThreadsWait.all_waits(another_thread)</code>。</p>\\n<p>所以現在 Ruby 就可以跑在多個 thread 裡面了？不。Ruby 有一個 GIL (Global Interpreter Lock) 特性阻止這件美好事情的發生。</p>\\n<h4>Ruby 的 Global Interpreter Lock</h4>\\n<p>GIL (Global Interpreter Lock) 是一個 Ruby implementation 的特性，它會讓資料一次只能被一個 thread 存取。也就是說，它禁止 parallelism with shared memory（比如說同時存取同一個變數）。所以 <code class=\"markup--code markup--p-code\">another_thread</code> 會在主要程序跑到它願意釋放 GIL（經由 Ruby Runtime）才被執行。誰有 GIL 誰就有 CPU 資源。在這個情況之下，使用 <code class=\"markup--code markup--p-code\">Thread</code> 這個類別只會徒耗資源。</p>\\n<p>切換 thread 的過程叫做 <a href=\"https://en.wikipedia.org/wiki/Context_switch\" data-href=\"https://en.wikipedia.org/wiki/Context_switch\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">Context Switching</a>。</p>\\n<p>為何會有 Global Interpreter Lock anyway? 因為它保障了 <code class=\"markup--code markup--p-code\">thread-safe</code>的特性。Ruby 的官方 interpreter <a href=\"https://en.wikipedia.org/wiki/YARV\" data-href=\"https://en.wikipedia.org/wiki/YARV\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">YARV (Yet Another Ruby VM)</a> 與 <a href=\"https://en.wikipedia.org/wiki/Ruby_MRI\" data-href=\"https://en.wikipedia.org/wiki/Ruby_MRI\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">MRI (Matz’s Ruby Interpreter</a>)有 GIL，但是不是所有 implementation 都有，比如說 <a href=\"https://www.jruby.org/\" data-href=\"https://www.jruby.org/\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">JRuby</a> 與 <a href=\"http://ironruby.net/\" data-href=\"http://ironruby.net/\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">IronRuby</a> 就沒有。</p>\\n<p><strong class=\"markup--strong markup--p-strong\">所以說 Ruby 是一個 single-threaded 語言不是最精確的，應該是說 Ruby 的 implementation 是 single-threaded。</strong></p>\\n<h4>Thread Safety</h4>\\n<p>OS context switch 是一個 involuntary context switch，它會被 kernel’s scheduler 安排，是不可避免也不可預期的。當 context switch 發生在一個式子賦值之前，比如在當 <code class=\"markup--code markup--p-code\">a = a + 1</code>，正在進行到一半，也就是 a+1，但是還沒有把這個新的值賦予 a 時，context switching 就會讓 a 停留在原本的狀態，造成災難。</p>\\n<p>GIL 會在 OS context switch 發生時拒絕 interpreter 的存取，強制把 CPU 的控制權還給有 GIL 的 thread。所以 involuntary context switch 發生時只會讓速度慢下來，而不會破壞它。</p>\\n<h4>GIL 的其他好處</h4>\\n<ul>\\n<li name=\"b95f\" id=\"b95f\" class=\"graf graf--li graf-after--h4\">更快速的 single-threaded programs (MRI 的開發人員曾經嘗試過把 GIL 拿掉，用其他方式保護核心函式庫的 thread-safety，但結果發現這樣 single-threaded 的情況下速度會變很慢，所以放棄了)。</li>\\n<li name=\"8de8\" id=\"8de8\" class=\"graf graf--li graf-after--li\">使用 C 的函式庫更加容易，因為我們不需要考慮到 thread safety (這跟 MRI 的歷史有關，可以參考<a href=\"https://www.jstorimer.com/pages/more-about-mri-and-the-gil\" data-href=\"https://www.jstorimer.com/pages/more-about-mri-and-the-gil\" class=\"markup--anchor markup--li-anchor\" rel=\"nofollow noopener\" target=\"_blank\">這篇文章</a>)。</li>\\n<li name=\"cbed\" id=\"cbed\" class=\"graf graf--li graf-after--li graf--trailing\">讓 Garbage Collection 更簡單。</li>\\n</ul><p>雖然已盡能力所及地確保資料的正確性，但我恐怕還是會有不對/不精確的觀念或用字，如果願意<a href=\"https://jennycodes.herokuapp.com/contact\" data-href=\"https://jennycodes.herokuapp.com/contact\" class=\"markup--anchor markup--p-anchor\" rel=\"noopener nofollow nofollow noopener nofollow noopener nofollow noopener nofollow noopener\" target=\"_blank\">指正我</a>的話我會非常感激！</p>\\n<h4>參考資料</h4>\\n<div>\\n<a href=\"https://dev.to/enether/rubys-gil-in-a-nutshell\" data-href=\"https://dev.to/enether/rubys-gil-in-a-nutshell\" class=\"markup--anchor markup--mixtapeEmbed-anchor\" title=\"https://dev.to/enether/rubys-gil-in-a-nutshell\" rel=\"nofollow\"><strong class=\"markup--strong markup--mixtapeEmbed-strong\">Ruby's GIL in a nutshell</strong><br>dev.to</a><a href=\"https://dev.to/enether/rubys-gil-in-a-nutshell\" class=\"js-mixtapeImage mixtapeImage u-ignoreBlock\" data-media-id=\"bfa4ee1183da8abb42c1f689d276c5a1\" data-thumbnail-img-id=\"0*2cshMOpSiX7eiEry\" style=\"background-image: url(https://cdn-images-1.medium.com/fit/c/320/320/0*2cshMOpSiX7eiEry);\"></a>\\n</div>\\n<div>\\n<a href=\"https://stackoverflow.com/questions/3086467/confused-are-languages-like-python-ruby-single-threaded-unlike-say-java-for\" data-href=\"https://stackoverflow.com/questions/3086467/confused-are-languages-like-python-ruby-single-threaded-unlike-say-java-for\" class=\"markup--anchor markup--mixtapeEmbed-anchor\" title=\"https://stackoverflow.com/questions/3086467/confused-are-languages-like-python-ruby-single-threaded-unlike-say-java-for\" rel=\"nofollow\"><strong class=\"markup--strong markup--mixtapeEmbed-strong\">Confused, are languages like python, ruby single threaded? unlike say java? (for web apps)</strong><br>stackoverflow.com</a><a href=\"https://stackoverflow.com/questions/3086467/confused-are-languages-like-python-ruby-single-threaded-unlike-say-java-for\" class=\"js-mixtapeImage mixtapeImage u-ignoreBlock\" data-media-id=\"aac15dd8d1fe55dbffd75611ab1c1fa8\" data-thumbnail-img-id=\"0*Js5bZdlDkql8kAZQ\" style=\"background-image: url(https://cdn-images-1.medium.com/fit/c/320/320/0*Js5bZdlDkql8kAZQ);\"></a>\\n</div>\\n<div>\\n<a href=\"https://www.jstorimer.com/pages/more-about-mri-and-the-gil\" data-href=\"https://www.jstorimer.com/pages/more-about-mri-and-the-gil\" class=\"markup--anchor markup--mixtapeEmbed-anchor\" title=\"https://www.jstorimer.com/pages/more-about-mri-and-the-gil\" rel=\"nofollow\"><strong class=\"markup--strong markup--mixtapeEmbed-strong\">More about MRI and the GIL</strong><br>www.jstorimer.com</a><a href=\"https://www.jstorimer.com/pages/more-about-mri-and-the-gil\" class=\"js-mixtapeImage mixtapeImage mixtapeImage--empty u-ignoreBlock\" data-media-id=\"76fb70e11d4da7082bae5f5cf5f5a4d0\"></a>\\n</div><p>文章同步發表於 <a href=\"https://medium.com/@jinghua.shih\">Medium</a>。",
        "status": 1,
        "description": "到底說 Ruby is single-threaded 是什麼意思？",
        "created_at": "2019-02-27T09:45:35.30668",
        "updated_at": "2019-03-02T08:31:44.671904",
        "slug": "筆記-rubys-threads",
        "medium_url": "https://medium.com/@jinghua.shih/%E7%AD%86%E8%A8%98-rubys-threads-e746038b71c8"
    },
    {
        "id": 35,
        "title": "每個開發者都應該要會用的編輯器–Vim",
        "body": "<p></p>\\n<p>經過了上禮拜的 <a href=\"https://jennycodes.me/posts/mac-setup-%E8%AE%93%E4%BD%A0%E7%9A%84%E9%96%8B%E7%99%BC%E9%80%9F%E5%BA%A6%E5%A4%A7%E8%BA%8D%E9%80%B2\" data-href=\"https://jennycodes.me/posts/mac-setup-%E8%AE%93%E4%BD%A0%E7%9A%84%E9%96%8B%E7%99%BC%E9%80%9F%E5%BA%A6%E5%A4%A7%E8%BA%8D%E9%80%B2\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">Mac 環境設定</a>後，我們的開發環境開始有模有樣起來了。</p>\\n<p>但作為一個真正的駭客，我們還缺少了一項東西—Vim 編輯器。</p>\\n<p>現代的 IDE (Integrated Development Environment）有各式各樣的選擇，除了優雅的 <a href=\"https://www.sublimetext.com/\" data-href=\"https://www.sublimetext.com/\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">Sublime Text</a>，其他也很熱門的有 <a href=\"https://code.visualstudio.com/\" data-href=\"https://code.visualstudio.com/\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">VS Code</a>, <a href=\"https://atom.io/\" data-href=\"https://atom.io/\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">Atom</a> 等等，<a href=\"https://www.jetbrains.com/\" data-href=\"https://www.jetbrains.com/\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">JetBrains</a> 出品的系列也是個個品質保證（現在我用的就是他們的 <a href=\"https://www.jetbrains.com/ruby/\" data-href=\"https://www.jetbrains.com/ruby/\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">RubyMine</a>），但是 Vim不一樣。</p>\\n<p>Vim 是大部分系統都有內建的編輯器，所以當你打開一個全新的電腦，或是用任何人的電腦，他們不一定會裝你熟悉的 sublime 或是 vs code，但是一定有 vim 可以用。再者，它可以直接在 terminal 介面裡面操作，當你只是需要快速修改某個檔案，或是握一些簡單的編輯又不想開肥大的 IDE 時，vim 是個非常方便的選擇。</p>\\n<p>Vim 不只是方便而已—它最大的特點就是讓你的手能夠一直保持在鍵盤之上就能完成所有工作。當你對 vim 的掌握已經爐火純青，就能夠做到「所思即所打」，讓鍵盤跟得上思考的速度。這是 Vim 強大的地方，也是它非常難學的原因。基本上可以把 Vim 看成一個語言，它有自己的語法與邏輯，所以也需要時間來逐漸熟悉。不過是一個編輯器，真的有必要花這個心力去學嗎？相信我，學會了你就知道它的威力有多大了。</p>\\n<p>而 Vim 強悍到許多現代 IDE 都有支援 Vim mode（Sublime 中的 <a href=\"https://www.sublimetext.com/docs/3/vintage.html\" data-href=\"https://www.sublimetext.com/docs/3/vintage.html\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">Vintage Mode</a>、RubyMine 中的 <a href=\"https://plugins.jetbrains.com/plugin/164-ideavim\" data-href=\"https://plugins.jetbrains.com/plugin/164-ideavim\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">Idea Vim</a>）就知道開發者們還是放不下它。</p>\\n<p>基本上這篇文章的定位是一個資源的指引，不會有手把手教學，但是絕對會把你安全的送往很多有完整手把手教學的地方。很多都是我一路學過來發現的寶藏。大概分成四個部分：</p>\\n<blockquote>1. 怎麼開始</blockquote>\\n<blockquote>2. .vimrc 設定檔</blockquote>\\n<blockquote>3. 實用的 Vim Plugins/外掛</blockquote>\\n<blockquote>4. 好（神）資源</blockquote>\\n<h3>一、怎麼開始</h3>\\n<p>Vim 不像其他的編輯器/IDE，一打開就可以用直覺開始使用，記得我第一次用 vim 打開一個新檔案，盯著鍵盤半分鐘後，完全不知道應該怎麼做，只好默默關掉改用 sublime 開。</p>\\n<p>所以到底要怎麼克服這個真的是有點高的入門門檻呢？</p>\\n<h4>不要看 cheat sheet</h4>\\n<figure class=\"text-center\"><img class=\"lazy img-fluid\" data-src=\"https://cdn-images-1.medium.com/max/1600/1*L0nzBn129FC8Ro6osL1X-w.png\"><figcaption class=\"imageCaption\"><a href=\"https://upload.wikimedia.org/wikipedia/commons/3/34/Cheatsheet_Vim_with_%27programming_Dvorak%27_layout.png\" data-href=\"https://upload.wikimedia.org/wikipedia/commons/3/34/Cheatsheet_Vim_with_%27programming_Dvorak%27_layout.png\" class=\"markup--anchor markup--figure-anchor\" rel=\"noopener nofollow\" target=\"_blank\">https://upload.wikimedia.org/wikipedia/commons/3/34/Cheatsheet_Vim_with_%27programming_Dvorak%27_layout.png</a></figcaption></figure><p>一開始準備要學 Vim 時，第一件事就是去下載一張類似上面的 vim cheat sheet，變成自己的桌面，還跑去圖書館撈了一本 vi/vim editor 的參考手冊，想說這樣有事沒事就會看到，也可以隨時有個參考，看著看著就會記住了，吧？</p>\\n<p>我錯了。對於一個連上下左右都還需要遲疑一下才知道在哪裡的菜鳥而言，這張密密麻麻的表唯一的作用只有嚇壞自己而已。就像是跟一個劍鞘都還拿不穩的初心者介紹屠龍刀的二十種用法一樣—無福消受啊。Cheat sheet 的特點就是資訊密集度非常高，所以可以讓<strong class=\"markup--strong markup--p-strong\">有經驗的人</strong>一眼就知道自己要找的資訊在哪裡，但是如果每一個資訊對你來說都是新的，那你看這張表只會感到疲憊、被淹沒、還有很煩。</p>\\n<h4>寫自己的小抄</h4>\\n<p>這是我後來發現很有效的方法—從最基礎的 <code class=\"markup--code markup--p-code\">y</code>(yank), <code class=\"markup--code markup--p-code\">p</code>(paste), <code class=\"markup--code markup--p-code\">d</code>(delete), <code class=\"markup--code markup--p-code\">c</code>(change) 還有它們的變化，比如說 <code class=\"markup--code markup--p-code\">yy</code>(yank a line), <code class=\"markup--code markup--p-code\">3dw</code>( → 3 delete word → delete 3 words) 開始寫小抄，一次大概寫 1/3 A4 紙大小就好了。小抄哪裡來？Google 是好幫手。當你發現自己有什麼不會的指令，google，然後把它抄下來。有需要再查也會比較有感。</p>\\n<p>等第一張夠熟練了，就換下一張，如此你不斷在加強新知識，但是同時可以掌握學習的份量。丟掉前一張小抄換成下一張的時候也是一種證實自己進步了的儀式，成就感/里程碑是保持熱忱萬萬不可或缺的因素啊。</p>\\n<p>當你對 vim 有一定的熟悉程度後，就可以去看 cheat sheet 了。但是不要看上面那一張，網路上有更好的選擇，這張真的沒有很好看。</p>\\n<h4>沒有「下次再學」這件事</h4>\\n<p>做個有骨氣的人。學 vim 的人應該都有一個原本用得很順手的 IDE 了，練習的時候一定會有時常又強烈的渴望打開那個 IDE 結束這一切苦難—相信我，I’ve been there。只能說，撐下去就是你的，還有網路是你的救星。</p>\\n<h4>從寫小東西開始</h4>\\n<p>一個對我很有幫助的方式是從寫小東西開始。這個小東西最好原本就是你生活中會使用的一部份、比較沒有時間壓力、格式醜一點之類的沒有什麼關係的，對我來說就是筆記了。反正做筆記的時候最低要求就是該記下來的字有記下來，還不會分行？沒關係之後再說。還不會移動文字？沒關係之後再說。總之就是先讓自己習慣使用 vim 這個環境，還有練習在小抄上面的指令。side project 也是個合適的選擇。總之，讓它出現在你生活中，慢慢練習，總有一天你會發現你越來越不用思考就能夠順暢的使用 vim 了。</p>\\n<p>呼應之前說的，把 vim 當成一個語言，多用自然就會了。</p>\\n<h3>二、Vim 環境設定：.vimrc</h3>\\n<p>vim 很厲害的一點是它是一個 highly configurable 的編輯器，你可以對它做各式各樣的設定，為你自己刻出一個量身打造的工具。Vim 本身不會附帶 config file，你要自己創造一個檔名叫做 <code class=\"markup--code markup--p-code\">.vimrc</code> 的檔案放在 home directory 底下。（順帶一提，通常開頭是 . 的檔案都是系統設定檔，預設是看不到，可以在命令列用 <code class=\"markup--code markup--p-code\">ls -a</code> 看到。）</p>\\n<p>既然每個人都有自己獨特的設定檔，要怎麼開始建立自己的 .vimrc 呢？當然這時候就是去參照各方大神的 .vimrc 的時間了。<a href=\"https://github.com/vgod/vimrc/blob/master/vimrc\" data-href=\"https://github.com/vgod/vimrc/blob/master/vimrc\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">vgod</a> 的跟 <a href=\"https://github.com/amix/vimrc\" data-href=\"https://github.com/amix/vimrc\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">amix</a> 的可以做個起手式。好吧既然你都問了，我就也放上<a href=\"https://github.com/jing-jenny-shih/dotfiles/blob/master/.vimrc\" data-href=\"https://github.com/jing-jenny-shih/dotfiles/blob/master/.vimrc\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">我的</a>做個參考。</p>\\n<p>不過建議先不要把自己的 .vimrc 弄得太複雜，可以先看過一遍大概知道有哪些常見的選擇，但是最好是碰到什麼需求再去一點一點慢慢加，這樣也會對那些設定有更清楚的暸解。</p>\\n<h3>三、實用的 Vim Plugins</h3>\\n<p>在現代 IDE 各種酷炫功能的虎視眈眈之下，Vim 這個被很多人嫌古老的編輯器當然不甘示弱地出了很多厲害的外掛，不輸那些 IDE 功能，只怕還更好。<a href=\"https://vimawesome.com/\" data-href=\"https://vimawesome.com/\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">Vim Awesome</a> 是一個集大成的網頁，可以上去挑選自由取用。以下介紹幾個自己現在比較常用的。</p>\\n<h4>Vundle</h4>\\n<p>網址：<a href=\"https://github.com/VundleVim/Vundle.vim\" data-href=\"https://github.com/VundleVim/Vundle.vim\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">https://github.com/VundleVim/Vundle.vim</a></p>\\n<p>Vundle 是一個<strong class=\"markup--strong markup--p-strong\">幫你管 plugin 的 plugin</strong>—它的工作是自動下載、安裝與管理你的 Vim plugins。相信我，你想要的。裝好 Vundle 之後下面介紹的所有 plugins 一次裝完絕對五分鐘之內搞定。</p>\\n<figure class=\"text-center\"><img class=\"lazy img-fluid\" data-src=\"https://cdn-images-1.medium.com/max/1600/1*WGICOIjveeFQOG4APNQJ_g.png\"><figcaption class=\"imageCaption\">Vundle plugin list example</figcaption></figure><p>這是目前我在 .vimrc 中插件的示意圖。基本上你想要裝什麼插件只要加上一行 <code class=\"markup--code markup--p-code\">Plugin '&lt;the plugin&gt;'</code>然後按 <code class=\"markup--code markup--p-code\">:</code> 開啟命令行，跑 <code class=\"markup--code markup--p-code\">PluginInstall</code>就好了。既然安裝方式都一樣，下面就不特別說安裝方式了。</p>\\n<h4>Vim Surround</h4>\\n<p>網址：<a href=\"https://github.com/tpope/vim-surround\" data-href=\"https://github.com/tpope/vim-surround\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">https://github.com/tpope/vim-surround</a></p>\\n<p>Vim Surround 是處理一切有關 brackets ，包含 <code class=\"markup--code markup--p-code\">[]</code>, <code class=\"markup--code markup--p-code\">{}</code> ,<code class=\"markup--code markup--p-code\">()</code>, <code class=\"markup--code markup--p-code\">“”</code>, <code class=\"markup--code markup--p-code\">‘’</code>的或是 backtick <code class=\"markup--code markup--p-code\">``</code> 的好工具。最厲害的是它整合了 vim 的 object 觀念，也就是你可以指定要對這個句子、這個字還是這個字直到這行行尾做括號，去除括號還是換一種括號。簡言之—是的它也需要一小段時間習慣，但是絕對值得投資！</p>\\n<h4>The NERDTree</h4>\\n<p>網址：<a href=\"https://github.com/scrooloose/nerdtree\" data-href=\"https://github.com/scrooloose/nerdtree\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">https://github.com/scrooloose/nerdtree</a></p>\\n<p>我最喜歡 sublime 的地方就是它有一個資料夾結構的 sidebar，非常簡潔滑順，讓你可以在專案底下優雅地滑來滑去。 NERDTree 提供了一個相似的功能：</p>\\n<figure class=\"text-center\"><img class=\"lazy img-fluid\" data-src=\"https://cdn-images-1.medium.com/max/1600/1*WHM-fIOepmnZxNnHLY7T6w.png\"><figcaption class=\"imageCaption\">NERDTree example</figcaption></figure><p>Vim 預設是不支援滑鼠的，所以如果想用滑鼠滾目錄的話，在 .vimrc 中加入</p>\\n<pre>set mouse=a   \" 開啟 mouse-reporting 功能<br>let g:NERDTreeMouseMode=3  \" optional: 單鍵點擊就可以打開資料夾/檔案</pre>\\n<h4>Instant Markdown</h4>\\n<p>網址：<a href=\"https://github.com/suan/vim-instant-markdown\" data-href=\"https://github.com/suan/vim-instant-markdown\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">https://github.com/suan/vim-instant-markdown</a></p>\\n<p>前面提到我一開始是先用做筆記的方式來練 vim 手感，筆記都用 <a href=\"https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet\" data-href=\"https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">markdown</a> 格式寫，很好的地方是 只要在 .vimrc 裡面加上 <code class=\"markup--code markup--p-code\">syntax enable</code> 就可以自動有 syntax hightlighting，反而勝過用 word 寫還要自己調自行顏色等等的麻煩。</p>\\n<p>Instant Markdown 則是更進一步，讓你一邊寫一邊就可以看到它實際被 render 出來的樣子。滿好玩的。</p>\\n<figure class=\"text-center\"><img class=\"lazy img-fluid\" data-src=\"https://cdn-images-1.medium.com/max/1600/1*n7TAoSCzfXesSlV3rdcEDA.png\"><figcaption class=\"imageCaption\">Instant Markdown live rendering</figcaption></figure><h4>CtrlP</h4>\\n<p>網址：<a href=\"https://github.com/ctrlpvim/ctrlp.vim\" data-href=\"https://github.com/ctrlpvim/ctrlp.vim\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">https://github.com/ctrlpvim/ctrlp.vim</a></p>\\n<p>Sublime Text 有一個非常強的功能：fuzzy search。按下 Ctrl+P (Windows)/Cmd+P(Mac) 打下任何關鍵字，演算法就會馬上計算，去你當前目錄裡面搜相符程度最高的檔案給你，非常便利的一項工具。比如說我今天想開 posts_controller.rb 這個檔案，我只要打開 Cmd+P，隨意打個 post con 它就會出現在選項第一個了。</p>\\n<p>Vim 的 CtrlP 就是這個功能。CtrlP 設定好之後，在 .vimrc 中加入下面三行</p>\\n<pre>let g:ctrlp_map = '&lt;c-p&gt;'<br>let g:ctrlp_cmd = 'CtrlP'<br>let g:ctrlp_working_path_mode = 'ra'</pre>\\n<p>就可以開始用了。</p>\\n<figure class=\"text-center\"><img class=\"lazy img-fluid\" data-src=\"https://cdn-images-1.medium.com/max/1600/1*hMOfY1gVKos3GwXgmxe0ww.png\"><figcaption class=\"imageCaption\">CtrlP example</figcaption></figure><p>只是雖然功能是有的，還是有些限制，比如說目前還不支援空白（也就是說不能打 <code class=\"markup--code markup--p-code\">post con</code>）不管怎麼樣，這已經是一個很厲害的工具了。</p>\\n<p>這邊有一個 hack（<a href=\"https://ruby-china.org/topics/25295\" data-href=\"https://ruby-china.org/topics/25295\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">來自這裡</a>），CtrlP 預設使用 grep 來搜索，我們可以把它改成下面的 ack，會讓表現更好。在 .vimrc 加上：</p>\\n<pre>if executable('ag')<br>  \" Use Ag over Grep<br>  set grepprg=ag\\\\ --nogroup\\\\ --nocolor<br>  \" Use ag in CtrlP for listing files.<br>  let g:ctrlp_user_command = 'ag %s -l --nocolor -g \"\"'<br>  \" Ag is fast enough that CtrlP doesn't need to cache<br>  let g:ctrlp_use_caching = 0<br>endif</pre>\\n<h4>Ack.vim</h4>\\n<p>網址：<a href=\"https://github.com/mileszs/ack.vim\" data-href=\"https://github.com/mileszs/ack.vim\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">https://github.com/mileszs/ack.vim</a></p>\\n<p>簡言之就是一個升級版的 grep。在 sublime 裡面就是 Ctrl+Shift+F 目錄搜索的功能。這個更好的是還可以整合 <a href=\"https://github.com/ggreer/the_silver_searcher\" data-href=\"https://github.com/ggreer/the_silver_searcher\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">The Silver Searcher</a>（比 ack 更加輕量化/速度更快），只要在 .vimrc 中加入</p>\\n<pre><code class=\"markup--code markup--pre-code\">let g:ackprg = 'ag --nogroup --nocolor --column'</code></pre>\\n<p>就好了。真的很強大。</p>\\n<figure class=\"text-center\"><img class=\"lazy img-fluid\" data-src=\"https://cdn-images-1.medium.com/max/1600/1*lmaNf1Ka7a71T0RyTJfECw.png\"><figcaption class=\"imageCaption\">ack.vim + the silver searcher example</figcaption></figure><h4>Nerd Commenter</h4>\\n<p>網址：<a href=\"https://github.com/scrooloose/nerdcommenter\" data-href=\"https://github.com/scrooloose/nerdcommenter\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">https://github.com/scrooloose/nerdcommenter</a></p>\\n<p>這是一個讓你輕鬆處理 comment 的工具。原本我是用 <a href=\"https://github.com/tomtom/tcomment_vim\" data-href=\"https://github.com/tomtom/tcomment_vim\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">tcomment</a>，但是它讓我的 vim key mapping 變得很亂，加上了很多我絕對用不到的快捷鍵（快捷鍵污染 — 不 OK），所以後來就捨棄 tcomment 改用 Nerd Commenter。Nerd Commenter 的優點是它預設所有 mapping 都是用 &lt;leader&gt; 來管理，對我而言乾淨整潔多了，而且可以跟其他插件的快捷鍵一起管理。</p>\\n<h4>還有很多</h4>\\n<p>除了這邊提到的，還有很多像是 <a href=\"https://github.com/tpope/vim-fugitive\" data-href=\"https://github.com/tpope/vim-fugitive\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">vim-fugitive</a>, <a href=\"https://github.com/vim-ruby/vim-ruby\" data-href=\"https://github.com/vim-ruby/vim-ruby\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">vim-ruby</a>, <a href=\"http://%28https://github.com/ervandew/supertab%29\" data-href=\"http://(https://github.com/ervandew/supertab)\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">supertab</a>, <a href=\"https://github.com/easymotion/vim-easymotion\" data-href=\"https://github.com/easymotion/vim-easymotion\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">vim-easymotion</a>, <a href=\"https://github.com/valloric/youcompleteme\" data-href=\"https://github.com/valloric/youcompleteme\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">youcompleteme</a> 提供許多便利好用的功能。當然，插件一定會一定程度影響到 vim 的反應時間，所以有需要的再裝就好，不然就跟那些一次所有東西都包給你的 IDE 沒有什麼差別了是吧。比如說對現在的我而言，最常使用到 vim 的是拿來寫簡單的 C 跟 markdown files，寫 Ruby 的話我會用 Rubymine 或是 Sublime Text，所以基本上沒有裝什麼 language-specific 的插件。</p>\\n<h3>四、好（神）資源</h3>\\n<p>下面列出我學習 vim 以來搜刮到的好資源，全部都很推薦，尤其新手一定會受益良多：</p>\\n<h4><a href=\"https://segmentfault.com/a/1190000000445598\" data-href=\"https://segmentfault.com/a/1190000000445598\" class=\"markup--anchor markup--h4-anchor\" rel=\"nofollow noopener\" target=\"_blank\">Vim 的哲學</a></h4>\\n<p>這是一個系列，事實上是寫這篇文章時偶然發現的，寫得真好。裡面除了教你從頭開始熟悉 Vim 之外，也有很多很棒的分享，就算不是 vim 新手一定也會有收穫的。</p>\\n<h4><a href=\"https://danielmiessler.com/study/vim/\" data-href=\"https://danielmiessler.com/study/vim/\" class=\"markup--anchor markup--h4-anchor\" rel=\"nofollow noopener\" target=\"_blank\">Learn Vim for the Last Time</a></h4>\\n<p>雖然滿長的，但是是滿好的入門教材。</p>\\n<h4><a href=\"https://vim.fandom.com/\" data-href=\"https://vim.fandom.com/\" class=\"markup--anchor markup--h4-anchor\" rel=\"nofollow noopener\" target=\"_blank\">Vim Fandom</a></h4>\\n<p>基本上這個不太需要介紹，因為你只要常用 google 搜 vim 相關的資源就會常常看到這個網站。總之這是一個算是滿厲害的論壇吧，基本上帶著問題進來絕對不會空手而返的。</p>\\n<h4><a href=\"https://github.com/mhinz/vim-galore\" data-href=\"https://github.com/mhinz/vim-galore\" class=\"markup--anchor markup--h4-anchor\" rel=\"nofollow noopener\" target=\"_blank\">Vim Galore</a></h4>\\n<p>一個非常詳細，從頭開始帶你暸解 vim 的指引。很厲害也很實用。</p><h4>進階資源</h4>\\n<p>下面是進階一點的資源，給那些真的有心要把 vim 磨成自己專屬的 IDE 的一個參考：</p>\\n<ul>\\n<li name=\"fb50\" id=\"fb50\" class=\"graf graf--li graf-after--p\"><a href=\"https://github.com/yangyangwithgnu/use_vim_as_ide\" data-href=\"https://github.com/yangyangwithgnu/use_vim_as_ide\" class=\"markup--anchor markup--li-anchor\" rel=\"nofollow noopener\" target=\"_blank\">所需即所獲：像 IDE 一樣使用 vim</a></li>\\n<li name=\"8a24\" id=\"8a24\" class=\"graf graf--li graf-after--li graf--trailing\"><a href=\"https://ruby-china.org/topics/25295\" data-href=\"https://ruby-china.org/topics/25295\" class=\"markup--anchor markup--li-anchor\" rel=\"nofollow noopener\" target=\"_blank\">手把手將 Vim 打造成開發 Ruby 和 Rails 的強大 IDE</a></li>\\n</ul><h3>忠告：見好就收，適可而止</h3>\\n<p>Vim 是一個越挖會陷越深的坑，寫這篇的時候每次順手查個引用資料都會再度被拉走，等回過神來半小時又過去了……當然，前期開始學的時候需要一點耐心，而當你有基本掌握 vim 的能力的時候，就會越來越享受它的威力，然後開始花大把大把的時間在你的 .vimrc 裡面（唉）。總之，這個年代久遠的編輯器在現在一個比一個強悍的 IDE 出現還能歷久不衰，並且在每次「哪個 IDE 最強」的論戰中一定會被捧出來，絕對是有它的原因的。</p>\\n<p>好了不說了，我要繼續修我的 .vimrc 了。</p><p>文章同步發表於 <a href=\"https://medium.com/@jinghua.shih\">Medium</a>。",
        "status": 1,
        "description": "Vim 是一個語言，不（只）是一個編輯器。",
        "created_at": "2019-04-14T08:07:59.50605",
        "updated_at": "2019-04-14T08:34:55.567477",
        "slug": "每個開發者都應該要會用的編輯器-vim",
        "medium_url": "https://medium.com/@jinghua.shih/%E6%AF%8F%E5%80%8B%E9%96%8B%E7%99%BC%E8%80%85%E9%83%BD%E6%87%89%E8%A9%B2%E8%A6%81%E6%9C%83%E7%94%A8%E7%9A%84%E7%B7%A8%E8%BC%AF%E5%99%A8-vim-5f83349973a3"
    },
    {
        "id": 27,
        "title": "[Rails 效能優化] 資料庫索引 Database Indexing",
        "body": "<p></p>\\n<p>上篇講到 Rails 資料庫存取的 N+1 問題，並且如何使用 <code class=\"markup--code markup--p-code\">includes</code>（與它的朋友們） 下有效率指令，在這裡：<a href=\"https://jennycodes.me/posts/rails-activerecord-%E6%95%88%E8%83%BD%E5%84%AA%E5%8C%96%E4%B8%8A%E9%97%9C%E8%81%AF%E6%9F%A5%E8%A9%A2\" data-href=\"https://jennycodes.me/posts/rails-activerecord-%E6%95%88%E8%83%BD%E5%84%AA%E5%8C%96%E4%B8%8A%E9%97%9C%E8%81%AF%E6%9F%A5%E8%A9%A2\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">[Rails 效能優化] 資料庫關聯查詢</a>。這一篇不講操作層面，從設計層面來看講如何讓指令有效率的執行。</p><h3>資料庫索引（Database Index）</h3>\\n<p>一般來說，當我們想要從資料庫找符合某特定條件的資料，資料庫的標準程序是一行一行檢查，並且問自己「這是符合條件的的資料嗎？」如果是，就把資料拿出來，如果不是，就繼續檢查直到結束。江湖術語是 <a href=\"https://en.wikipedia.org/wiki/Full_table_scan\" data-href=\"https://en.wikipedia.org/wiki/Full_table_scan\" class=\"markup--anchor markup--p-anchor\" rel=\"noopener nofollow\" target=\"_blank\">Full Table Scan</a>。</p>\\n<p>可想而知，當資料量一大，資料庫要找到資料的時間就會越來越長。「有沒有方法能夠讓資料庫不用一行一行爬也可以找到想要的資料？」有的！就是索引（Index）。索引其實是一種資料結構（data structure），我們看不到，因為它通常存在我們使用的資料庫管理系統（DBSM, Database Management System）裡面。</p>\\n<h4>索引到底是如何運作的？</h4>\\n<p>大部分的 DBSM 都會預設把主鍵（Primary Key / ID）加上索引，現在假設有一個資料表（table）A，A 的 ID 欄位有被加上索引，則實際上在資料庫中，有另外一張表（我們叫它 A’）裡面儲存了 A 裡面的所有 ID，而 A’ 每一個資料（ID）都對應到 A 中的完整資料。</p>\\n<p>所以今天我們想要找 A 中一個 ID = 3 的資料，資料庫會用 Binary Search Algorithm（或是其他也很快的演算法，通常時間複雜度會是 <a href=\"https://en.wikipedia.org/wiki/Big_O_notation\" data-href=\"https://en.wikipedia.org/wiki/Big_O_notation\" class=\"markup--anchor markup--p-anchor\" title=\"Big O notation\" rel=\"nofollow noopener\" target=\"_blank\">O</a>(log(N)）在 A’ 中快速找到 ID = 3 這筆資料，然後再從這筆資料連到 A 中對應的資料。</p>\\n<p>實際情況下，A’ 這個擁有 A 的 ID 資料的儲存結構通常會以 Hash 或是 <a href=\"https://en.wikipedia.org/wiki/B-tree\" data-href=\"https://en.wikipedia.org/wiki/B-tree\" class=\"markup--anchor markup--p-anchor\" rel=\"noopener nofollow\" target=\"_blank\">B-tree</a> 實作。Hash 在搜尋不能重複的資料時，效率會比較好，因此適合用在主索引鍵（Primary Index）和唯一索引（Unique Index）；B-tree 適合用在可以允許重複資料的一般索引（Non-Unique Index）。</p>\\n<h4>非主要欄位 Non-Primary Column</h4>\\n<p>端看使用者最常使用什麼欄位來獲取資料，我們可以自己定義主鍵以外的索引，比如說 first_name；或是使用複合式索引（composite indexes），比如說 first_name + last_name。</p>\\n<h3>索引結構（Index Architecture）</h3>\\n<p>索引可以分成叢集（Clustered）與非叢集（Non-Clustered）兩種類型。</p>\\n<h4>叢集 Clustered</h4>\\n<blockquote>Clustering alters the data block into a certain distinct order to match the index, resulting in the row data being stored in order.</blockquote>\\n<p>摘錄自<a href=\"https://en.wikipedia.org/wiki/Database_index\" data-href=\"https://en.wikipedia.org/wiki/Database_index\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">維基百科</a>。</p>\\n<p>叢集索引（Clustered Index）直接修改原本的資料表順序，將資料按照要索引的欄位排，就是一個王牌的意思。如此可以讓資料搜尋非常有效率，尤其是依照順序（accessed sequentially）或是一個範圍連續資料的時候。想當然爾，一張資料表只會有一個叢集索引，通常就是主鍵欄位（primary key column）。</p>\\n<p>因為叢集索引會調整資料順序，所以它最大的特色就是實體的資料（physical data rows）跟索引表（index block/index table）中的順序會是一樣的。</p>\\n<h4>非叢集 Non-Clustered</h4>\\n<p>非叢集索引（Non-Clustered Index）是指不管資料在原本資料表中的排序，而在索引表中自己依照索引值建立排列。與叢集索引的差別是，叢集索引的排列順序就是實際上資料的排列順序，而非叢集索引的排列順序不會/無法影響到實際資料的排列順序。也因此，一個資料表中可以包含很多非叢集索引。</p>\\n<p>通常會使用非叢集索引的會是在 <code class=\"markup--code markup--p-code\">JOIN</code>, <code class=\"markup--code markup--p-code\">WHERE</code> 或是 <code class=\"markup--code markup--p-code\">ORDER BY</code> 使用的非主鍵欄位（non-primary key columns）。</p>\\n<h3>使用索引的限制</h3>\\n<p>講完了好處，接下來要講講索引的限制了。首先，索引之所以可以增加資料庫的效率，是因為它額外創造了一張表來儲存索引的資料，也就是拿空間換取時間，這也是為什麼我們不能為每個欄位都加上索引的原因。再來，我們對資料庫做的任何更動都會連動到索引表（Index Table），如果這是一張更動很頻繁的表，那就會製造額外的負擔。</p>\\n<p>所以要如何在查詢速度與儲存空間/更新成本之間找到平衡，就是設計索引時需要好好思索的。</p>\\n<p>另外，就算加了索引，也不是萬能的。我們來看兩個狀況：</p>\\n<pre>SELECT first_name FROM people WHERE last_name = ‘Shih’;</pre>\\n<p>這個例子要尋找在<code class=\"markup--code markup--p-code\">people</code> 中所有 <code class=\"markup--code markup--p-code\">last_name</code> 是 ‘Shih’ 的 <code class=\"markup--code markup--p-code\">first_name</code>資料，如果 <code class=\"markup--code markup--p-code\">last_name</code> 欄位沒有被索引，那麼就會是一個 full table scan。如果有索引，那資料庫系統就會使用 B-tree 結構來尋找，大大增加搜尋效率，很好！</p>\\n<pre>SELECT full_name FROM people WHERE full_name LIKE ‘%Shih’;</pre>\\n<p>現在假設我們是要從 <code class=\"markup--code markup--p-code\">people</code>中找到 <code class=\"markup--code markup--p-code\">full_name</code> 的結尾是 ‘Shih’ 的<code class=\"markup--code markup--p-code\">full_name</code> 資料， 這時候，就算<code class=\"markup--code markup--p-code\">full_name</code> 有索引，還是會引發 full table scan，因為<strong class=\"markup--strong markup--p-strong\">索引的預設搜尋方向是從左到右</strong>，當搜尋的字串開頭是外卡（wildcard），資料庫系統就沒有辦法使用 B-tree 了。</p>\\n<p>要解決這個困境可以增加一個 <code class=\"markup--code markup--p-code\">reverse(full_name)</code> 的索引，然後改變 SQL 查詢：</p>\\n<pre>SELECT full_name FROM people WHERE reverse(full_name) LIKE reverse(‘Shih’);</pre>\\n<p>當然，我們就要自己衡量這樣值不值得了。</p>\\n<h4>通常會加上索引的欄位</h4>\\n<ul>\\n<li name=\"1079\" id=\"1079\" class=\"graf graf--li graf-after--h4\">主鍵 Primary Key（通常是預設）</li>\\n<li name=\"c9d2\" id=\"c9d2\" class=\"graf graf--li graf-after--li\">外部鍵 Foreign Key</li>\\n<li name=\"139d\" id=\"139d\" class=\"graf graf--li graf-after--li\">常被放在查詢子句中（<code class=\"markup--code markup--li-code\">ORDER</code>, <code class=\"markup--code markup--li-code\">WHERE</code>, <code class=\"markup--code markup--li-code\">GROUP</code>）的欄位</li>\\n</ul>\\n<h3>在 Rails 的資料庫中加上索引的方法</h3>\\n<p>其實只要在 migration 檔案中加上 <code class=\"markup--code markup--p-code\">add_index(table, columns, options)</code>就好了。比如說今天我們要在 <code class=\"markup--code markup--p-code\">people</code> 資料表中為 <code class=\"markup--code markup--p-code\">full_name</code> 加上索引，那步驟如下：</p>\\n<ol>\\n<li name=\"7364\" id=\"7364\" class=\"graf graf--li graf-after--p\">新增 migration 檔案：終端機中執行 <code class=\"markup--code markup--li-code\">rails g migration AddFullNameIndexToPeople</code>（名稱隨意）</li>\\n<li name=\"60c7\" id=\"60c7\" class=\"graf graf--li graf-after--li\">目錄中找到這個新增的檔案，修改裡面的程式碼：</li>\\n</ol>\\n<pre><code class=\"markup--code markup--pre-code\">class MigrationName &lt; ActiveRecord::Migration[5.2]<br>  def change<br>    a</code>dd_index(:people, :full_name)<br>  <code class=\"markup--code markup--pre-code\">end<br>end</code></pre>\\n<p>3. 終端機中執行 <code class=\"markup--code markup--p-code\">rake db:migrate</code></p>\\n<p>輕輕鬆鬆。</p>\\n<p>更完整的用法請參考 <a href=\"https://apidock.com/rails/ActiveRecord/ConnectionAdapters/SchemaStatements/add_index\" data-href=\"https://apidock.com/rails/ActiveRecord/ConnectionAdapters/SchemaStatements/add_index\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">API dock</a>。</p><p>好的，下一篇來講 transaction!</p><p>雖然已盡能力所及地確保資料的正確性，但我恐怕還是會有不對/不精確的觀念或用字，如果願意<a href=\"https://jennycodes.herokuapp.com/contact\" data-href=\"https://jennycodes.herokuapp.com/contact\" class=\"markup--anchor markup--p-anchor\" rel=\"noopener nofollow nofollow noopener nofollow noopener\" target=\"_blank\">指正我</a>的話我會非常感激！</p><h3>參考資料</h3>\\n<p><strong class=\"markup--strong markup--p-strong\">Date, Chris J. <em class=\"markup--em markup--p-em\">An Introduction to Database Systems C.J. Date</em>. Pearson Addison-Wesley, 2004.</strong></p>\\n<div>\\n<a href=\"https://en.wikipedia.org/wiki/Database_index\" data-href=\"https://en.wikipedia.org/wiki/Database_index\" class=\"markup--anchor markup--mixtapeEmbed-anchor\" title=\"https://en.wikipedia.org/wiki/Database_index\" rel=\"nofollow\"><strong class=\"markup--strong markup--mixtapeEmbed-strong\">Database index - Wikipedia</strong><br>en.wikipedia.org</a><a href=\"https://en.wikipedia.org/wiki/Database_index\" class=\"js-mixtapeImage mixtapeImage mixtapeImage--empty u-ignoreBlock\" data-media-id=\"cdaa38c456eda3395766a853451cfb20\"></a>\\n</div>\\n<div>\\n<a href=\"https://medium.com/omarelgabrys-blog/database-indexing-and-transactions-part-9-a24781d429f8\" data-href=\"https://medium.com/omarelgabrys-blog/database-indexing-and-transactions-part-9-a24781d429f8\" class=\"markup--anchor markup--mixtapeEmbed-anchor\" title=\"https://medium.com/omarelgabrys-blog/database-indexing-and-transactions-part-9-a24781d429f8\"><strong class=\"markup--strong markup--mixtapeEmbed-strong\">Database — Indexing, Transactions &amp; Stored Procedures (Part 9)</strong><br>medium.com</a><a href=\"https://medium.com/omarelgabrys-blog/database-indexing-and-transactions-part-9-a24781d429f8\" class=\"js-mixtapeImage mixtapeImage u-ignoreBlock\" data-media-id=\"d5d4727661938c13eb7d224cc6803f2e\" data-thumbnail-img-id=\"1*LYjeWPkAz1Zmbod7FGA8tg.jpeg\" style=\"background-image: url(https://cdn-images-1.medium.com/fit/c/320/320/1*LYjeWPkAz1Zmbod7FGA8tg.jpeg);\"></a>\\n</div>\\n<div>\\n<a href=\"https://apidock.com/rails/ActiveRecord/ConnectionAdapters/SchemaStatements/add_index\" data-href=\"https://apidock.com/rails/ActiveRecord/ConnectionAdapters/SchemaStatements/add_index\" class=\"markup--anchor markup--mixtapeEmbed-anchor\" title=\"https://apidock.com/rails/ActiveRecord/ConnectionAdapters/SchemaStatements/add_index\" rel=\"nofollow\"><strong class=\"markup--strong markup--mixtapeEmbed-strong\">add_index (ActiveRecord::ConnectionAdapters::SchemaStatements) - APIdock</strong><br>apidock.com</a><a href=\"https://apidock.com/rails/ActiveRecord/ConnectionAdapters/SchemaStatements/add_index\" class=\"js-mixtapeImage mixtapeImage mixtapeImage--empty u-ignoreBlock\" data-media-id=\"327c1a17627fa5523e7453cebd00fa07\"></a>\\n</div>\\n<p><a href=\"http://www.codedata.com.tw/database/mysql-tutorial-9-table-index/\" data-href=\"http://www.codedata.com.tw/database/mysql-tutorial-9-table-index/\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">MySQL 超新手入門（9）表格與索引</a></p><p>文章同步發表於 <a href=\"https://medium.com/@jinghua.shih\">Medium</a>。",
        "status": 1,
        "description": "如何優化資料庫查詢的速度",
        "created_at": "2019-02-23T11:45:50.137104",
        "updated_at": "2019-04-06T06:05:08.894312",
        "slug": "rails-網站效能優化二資料庫索引-database-index",
        "medium_url": "https://medium.com/@jinghua.shih/rails-%E7%B6%B2%E7%AB%99%E6%95%88%E8%83%BD%E5%84%AA%E5%8C%96-%E4%BA%8C-%E8%B3%87%E6%96%99%E5%BA%AB%E7%B4%A2%E5%BC%95-database-index-bd89fa3757a"
    },
    {
        "id": 31,
        "title": "[筆記] REST 到底是什麼",
        "body": "<p></p>\\n<blockquote>2019/4/16 更新：新增了「一些常見名詞」段落。</blockquote>\\n<p>必須說，REST 真的是個有點抽象的概念，所以如果你看完這篇還是沒有懂，絕對不是你的錯，請<a href=\"https://jennycodes.me/contact\" data-href=\"https://jennycodes.me/contact\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">來告訴我</a>讓我好好反省。</p><p>本篇文章會介紹</p>\\n<blockquote>1. REST 定義</blockquote>\\n<blockquote>2. REST 特色</blockquote>\\n<blockquote>3. REST 元素</blockquote>\\n<blockquote>4. 一些常見名詞</blockquote>\\n<blockquote>5. 其它架構方法</blockquote><h3>一、REST 定義</h3>\\n<p><a href=\"https://en.wikipedia.org/wiki/Representational_state_transfer\" data-href=\"https://en.wikipedia.org/wiki/Representational_state_transfer\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">REST (REpresentational State Transfer)</a> 是一種網頁服務架構（Web Service Architecture）方法，提供電腦系統一種標準化溝通的管道。</p>\\n<p>聽起來有點抽象。直接舉例： HTTP 就是一個符合 REST 架構的實作。但是要記得，REST 是一種<strong class=\"markup--strong markup--p-strong\">風格</strong>，所以應用程式使用了 HTTP 連線不保證它就是 REST 架構。</p>\\n<blockquote>REST 雖然是個來自 WWW 的架構概念 (比 WWW 晚)，但是這兩者並不是綁在一起，有可能設計一個大型軟體系統符合 REST 但是不用 HTTP 協定也不需跟 WWW 互動，也有可能設計一個簡單的 XML+HTTP 界面使用 RPC model 而不符合 REST principles。</blockquote>\\n<p>擷取自 <a href=\"https://ihower.tw/blog/archives/1542\" data-href=\"https://ihower.tw/blog/archives/1542\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">ihower</a>。</p>\\n<h3>二、REST 特色</h3>\\n<p>符合 REST 原則的系統就是 RESTful（或是 REST-compliant）。RESTful systems 有五個主要特性/限制：<strong class=\"markup--strong markup--p-strong\">伺服器/客戶端分離、無狀態、可快取、分層、統一操作介面</strong>。</p>\\n<h4>伺服器/客戶端分離 Separation of Server and Client</h4>\\n<p>遵照 REST 設計的系統可以做到伺服器端與客戶端的實作獨立，兩者可以各自發展、互不影響，也就是說不管客戶端的程式碼再怎麼改變都不會影響到伺服器的運作，反之亦然。這是因為兩者遵循著一個溝通的格式，只要客戶端不改變傳訊息給伺服器端的方式，伺服器端也不改變傳訊息給客戶端的方式，就可以做到 seperation of concerns。</p>\\n<h4>無狀態 Stateless</h4>\\n<p>每個請求都是獨立的、自成一個個體，與前後請求無關。如此好處有很多，包含可靠（容易從錯誤中復原）、高效能與可擴充性（可以將請求交給不同伺服器處理），而元件可以被修改、更動而不會影響到系統整體的運作。</p>\\n<h4>可快取 Cacheable</h4>\\n<p>快取機制可以在 Client 或 Server 中實作。</p>\\n<h4>分層 Layered</h4>\\n<p>在發出請求的 Client 與送出回應的 Server 之間可以有好幾個 Server 中間人（稱作 Connectors，下面介紹），彼此獨立並且不會影響到 Request 與 Response。</p>\\n<h4>統一操作介面 Uniform Interface</h4>\\n<p>將操作細節抽象出來，降低耦合並提高獨立性。</p>\\n<p>這些特性是讓 REST 強大的原因，讓我們繼續看下去它是如何辦到的。</p>\\n<h3>三、REST 元素</h3>\\n<p>REST 有三個主要角色：Data Elements, Connectors, Components.</p>\\n<h4>Data Elements</h4>\\n<p><code class=\"markup--code markup--p-code\">Resource</code> 與 <code class=\"markup--code markup--p-code\">Representation</code> 是兩個 Data Elements 中比較重要的元素。</p>\\n<p>我們可以把<strong class=\"markup--strong markup--p-strong\"> </strong><code class=\"markup--code markup--p-code\"><strong class=\"markup--strong markup--p-strong\">Resource</strong></code> 想像成一個<strong class=\"markup--strong markup--p-strong\">物件</strong>的高級說法（其實也差不多是這樣）。若是熟悉物件導向程式設計（Object-Oriented Programming），<code class=\"markup--code markup--p-code\">Resource</code> 的概念也可以用 OOP 中的物件來聯想。它有自己的類型、關聯的資料、可以被我們存取與傳送。</p>\\n<p>每個 <code class=\"markup--code markup--p-code\"><strong class=\"markup--strong markup--p-strong\">Resource</strong></code> 有自己的 <code class=\"markup--code markup--p-code\">Resource Identifier</code> 與 <code class=\"markup--code markup--p-code\">Resource Metadata</code>。<code class=\"markup--code markup--p-code\">Resource Identifier</code> 是什麼？在前面加個 Uniform，再看看它的縮寫—沒錯！就是 URI (Uniform Resource Identifier)。雖然我們比較常聽到的是 URL (Uniform Resource Locator)，URI 可能比較陌生，但是兩者的概念是一樣的，都是一種識別資源的方法，而 URL 是 URI 的一種，有興趣暸解兩者關係的可以看這篇 <a href=\"https://stackoverflow.com/questions/4913343/what-is-the-difference-between-uri-url-and-urn\" data-href=\"https://stackoverflow.com/questions/4913343/what-is-the-difference-between-uri-url-and-urn\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">SO 回答</a>。</p>\\n<p><code class=\"markup--code markup--p-code\">Resource Metadata</code> 則是儲存 Source Link, Alternates 等資訊。</p>\\n<p><code class=\"markup--code markup--p-code\"><strong class=\"markup--strong markup--p-strong\">Representation</strong></code> 是表示這個資源目前的狀態，Content-Type (e.g. application/html, image/jpg) 就是一種 <code class=\"markup--code markup--p-code\">Representation</code>。<code class=\"markup--code markup--p-code\">Representation Metadata</code> 則包含了 Media Type, Last-Modified Time 等資料。</p>\\n<h4>Connectors</h4>\\n<p>REST connectors 包含五種型態：<code class=\"markup--code markup--p-code\">Client</code>, <code class=\"markup--code markup--p-code\">Server</code>, <code class=\"markup--code markup--p-code\">Cache</code>, <code class=\"markup--code markup--p-code\">Resolver</code>, <code class=\"markup--code markup--p-code\">Tunnel</code>。其中 <code class=\"markup--code markup--p-code\">Client</code> 與 <code class=\"markup--code markup--p-code\">Server</code> 是兩種主要型態。一次請求到回應的路徑是：<code class=\"markup--code markup--p-code\">Server</code> 監聽 → <code class=\"markup--code markup--p-code\">Client</code> 發出 Request → <code class=\"markup--code markup--p-code\">Server</code> 收到 → 傳回 Response。 <code class=\"markup--code markup--p-code\">Cache</code> 的機制則可以實做在 <code class=\"markup--code markup--p-code\">Client</code> 端或是 <code class=\"markup--code markup--p-code\">Server</code> 端。<code class=\"markup--code markup--p-code\">Resolver</code> 的角色像是 <code class=\"markup--code markup--p-code\">Client</code> 與 <code class=\"markup--code markup--p-code\">Server</code> 的中間人（e.g. DNS lookup），<code class=\"markup--code markup--p-code\">Tunnel</code> 則可以做強制加密等工作。</p>\\n<h4>Components</h4>\\n<p>REST components 包含四種角色：<code class=\"markup--code markup--p-code\">User Agent</code>, <code class=\"markup--code markup--p-code\">Origin Server</code>, <code class=\"markup--code markup--p-code\">Gateway</code>, <code class=\"markup--code markup--p-code\">Proxy</code>。<code class=\"markup--code markup--p-code\">User Agent</code> 就是有時候當我們要用爬蟲，會必須要註明 <code class=\"markup--code markup--p-code\">User-Agent = “Mozilla/5.0”</code> 的那個 User Agent（題外話，<a href=\"https://webaim.org/blog/user-agent-string-history/\" data-href=\"https://webaim.org/blog/user-agent-string-history/\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">這篇文章</a>很幽默的解釋了 Mozilla/5.0 的由來。）<code class=\"markup--code markup--p-code\">User Agent</code> 代表瀏覽器那一方，<code class=\"markup--code markup--p-code\">Origin Server</code> 則代表伺服器那一方。<code class=\"markup--code markup--p-code\">Gateway</code> 與 <code class=\"markup--code markup--p-code\">Proxy</code> 則是在 <code class=\"markup--code markup--p-code\">User Agent</code> 與 <code class=\"markup--code markup--p-code\">Origin Server</code> 的溝通過程中確保效率與安全性。</p>\\n<h4>三個角色間的互動</h4>\\n<p>請求流向：</p>\\n<blockquote>User-Agent (component) → (requests a representation of a resource’s state)→ Client (connector) → Server (connector) → Origin Server (component) → (sends back the response) → … → User-Agent</blockquote>\\n<ul>\\n<li name=\"8fba\" id=\"8fba\" class=\"graf graf--li graf-after--blockquote\">Components 使用 Connectors，透過一個<strong class=\"markup--strong markup--li-strong\">標準化介面</strong>來操作 Data Elements。</li>\\n<li name=\"10fd\" id=\"10fd\" class=\"graf graf--li graf-after--li\">中間可以穿插任意數量的 Connectors，但是每一層都是獨立的。</li>\\n<li name=\"aa14\" id=\"aa14\" class=\"graf graf--li graf-after--li\">Data Elements 的操作不會從 <code class=\"markup--code markup--li-code\">Resource</code> 本身，而是 <code class=\"markup--code markup--li-code\">Representation</code> (the <strong class=\"markup--strong markup--li-strong\">Representational </strong>part in REST) (e.g. HTML, XML, JPG)。Applications 只需要知道 <code class=\"markup--code markup--li-code\">Representation</code> 與 <code class=\"markup--code markup--li-code\">Action</code> (要對資源做的動作) 就夠了。</li>\\n</ul>\\n<h4>標準化介面</h4>\\n<p>REST 介面有三要素：<strong class=\"markup--strong markup--p-strong\">名詞 Noun、動詞 Verb、表徵</strong> <strong class=\"markup--strong markup--p-strong\">Content Type</strong>。</p>\\n<ul>\\n<li name=\"734a\" id=\"734a\" class=\"graf graf--li graf-after--p\">\\n<strong class=\"markup--strong markup--li-strong\">Noun</strong> 就是要操作的 <code class=\"markup--code markup--li-code\">Resource</code>，像是 <a href=\"https://jennycodes.me%29,\" data-href=\"https://jennycodes.me),\" class=\"markup--anchor markup--li-anchor\" rel=\"noopener nofollow\" target=\"_blank\">https://jennycodes.me</a>。</li>\\n<li name=\"25d5\" id=\"25d5\" class=\"graf graf--li graf-after--li\">\\n<strong class=\"markup--strong markup--li-strong\">Verb</strong> 是一組<strong class=\"markup--strong markup--li-strong\">有限的</strong>操作指令，包含 <code class=\"markup--code markup--li-code\">GET</code>、<code class=\"markup--code markup--li-code\">POST</code>、<code class=\"markup--code markup--li-code\">PUT</code>、<code class=\"markup--code markup--li-code\">DELETE</code>。</li>\\n<li name=\"a4a2\" id=\"a4a2\" class=\"graf graf--li graf-after--li\">\\n<strong class=\"markup--strong markup--li-strong\">Content Type</strong> 是一組<strong class=\"markup--strong markup--li-strong\">有限的</strong>內容格式，也就是 <code class=\"markup--code markup--li-code\">Representation</code>，像是 HTML。</li>\\n</ul>\\n<h3>四、一些常見名詞</h3>\\n<p>Base-url, Endpoint, Parameter 是幾個 REST API 常見的名詞，先解釋一下：</p>\\n<h4>Base-url</h4>\\n<p>一次 API 請求的基本盤。假設今天去餐廳外帶餐點，那 base-url 就是那家餐廳的外賣窗口，所有你想在這家餐廳點的菜都從這裡開始。</p>\\n<h4>Endpoint</h4>\\n<p>請求的資源本身。同樣以去餐廳外帶做比喻， endpoint 就是你要點的菜。</p>\\n<h4>Parameters</h4>\\n<p>你的客製化選項。比如說大辣小辣、要不要付餐具、哪個日期區間的資料 etc. 記得，這些選項必須是 API 提供者有提供的，比如說你不能要求「加香菜」到你的蛋炒飯如果店家沒有這個選項。所以記得好好閱讀 API 文件。</p>\\n<h3>五、其它架構方法</h3>\\n<p>以前最常被用來與 REST 比較的架構方法是 <a href=\"https://en.wikipedia.org/wiki/Remote_procedure_call\" data-href=\"https://en.wikipedia.org/wiki/Remote_procedure_call\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">RPC</a>，現在大概是 <a href=\"https://en.wikipedia.org/wiki/GraphQL\" data-href=\"https://en.wikipedia.org/wiki/GraphQL\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">GraphQL</a>。這篇先介紹 RPC，下一篇介紹 GraphQL</p>\\n<h4>RPC: Remote Procedure Call</h4>\\n<p>RPC 定義上來說是一個電腦程式（computer program）讓一個程序（procedure）在另一個記憶體位置（address space）（通常就是在另一台電腦或網路上）執行。同樣使用 Client-Server interaction。RPC 實作上有 <a href=\"https://en.wikipedia.org/wiki/SOAP\" data-href=\"https://en.wikipedia.org/wiki/SOAP\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">SOAP</a> 與 <a href=\"https://en.wikipedia.org/wiki/XML-RPC\" data-href=\"https://en.wikipedia.org/wiki/XML-RPC\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">XML-RPC</a>。RPC 與 REST 最大的不同是，在 Client 與物件溝通之前，它必須先擁有這個物件的知識才能進行操作。相反地，REST 則是只要知道物件的狀態就好了。多數人擁抱 REST 的原因是因為它簡單又很有威力，但同樣也因其簡單而讓人感到侷限。</p>\\n<p>總而言之，就跟世界上千千萬萬個選擇一樣：挑個當下最適合自己的就好了。</p><h4>References</h4>\\n<div>\\n<a href=\"https://blog.toright.com/posts/1399/%E6%B7%BA%E8%AB%87-rest-%E8%BB%9F%E9%AB%94%E6%9E%B6%E6%A7%8B%E9%A2%A8%E6%A0%BC-part-ii-%E5%A6%82%E4%BD%95%E8%A8%AD%E8%A8%88-restful-web-service.html\" data-href=\"https://blog.toright.com/posts/1399/%E6%B7%BA%E8%AB%87-rest-%E8%BB%9F%E9%AB%94%E6%9E%B6%E6%A7%8B%E9%A2%A8%E6%A0%BC-part-ii-%E5%A6%82%E4%BD%95%E8%A8%AD%E8%A8%88-restful-web-service.html\" class=\"markup--anchor markup--mixtapeEmbed-anchor\" title=\"https://blog.toright.com/posts/1399/%E6%B7%BA%E8%AB%87-rest-%E8%BB%9F%E9%AB%94%E6%9E%B6%E6%A7%8B%E9%A2%A8%E6%A0%BC-part-ii-%E5%A6%82%E4%BD%95%E8%A8%AD%E8%A8%88-restful-web-service.html\" rel=\"nofollow\"><strong class=\"markup--strong markup--mixtapeEmbed-strong\">淺談 REST 軟體架構風格 (Part.II) - 如何設計 RESTful Web Service？ - Soul &amp; Shell Blog</strong><br>blog.toright.com</a><a href=\"https://blog.toright.com/posts/1399/%E6%B7%BA%E8%AB%87-rest-%E8%BB%9F%E9%AB%94%E6%9E%B6%E6%A7%8B%E9%A2%A8%E6%A0%BC-part-ii-%E5%A6%82%E4%BD%95%E8%A8%AD%E8%A8%88-restful-web-service.html\" class=\"js-mixtapeImage mixtapeImage u-ignoreBlock\" data-media-id=\"cd41f21b070ffe90997645ed10252741\" data-thumbnail-img-id=\"0*aAPZCnA_dQ2gvIL4\" style=\"background-image: url(https://cdn-images-1.medium.com/fit/c/320/320/0*aAPZCnA_dQ2gvIL4);\"></a>\\n</div>\\n<div>\\n<a href=\"https://www.codecademy.com/articles/what-is-rest\" data-href=\"https://www.codecademy.com/articles/what-is-rest\" class=\"markup--anchor markup--mixtapeEmbed-anchor\" title=\"https://www.codecademy.com/articles/what-is-rest\" rel=\"nofollow\"><strong class=\"markup--strong markup--mixtapeEmbed-strong\">What is REST? | Codecademy</strong><br>www.codecademy.com</a><a href=\"https://www.codecademy.com/articles/what-is-rest\" class=\"js-mixtapeImage mixtapeImage u-ignoreBlock\" data-media-id=\"2c28a979ea318790569e4078c1386891\" data-thumbnail-img-id=\"0*bC9ckFYNgftq_ltU\" style=\"background-image: url(https://cdn-images-1.medium.com/fit/c/320/320/0*bC9ckFYNgftq_ltU);\"></a>\\n</div>\\n<div>\\n<a href=\"https://ihower.tw/blog/archives/1542\" data-href=\"https://ihower.tw/blog/archives/1542\" class=\"markup--anchor markup--mixtapeEmbed-anchor\" title=\"https://ihower.tw/blog/archives/1542\" rel=\"nofollow\"><strong class=\"markup--strong markup--mixtapeEmbed-strong\">什麼是REST跟RESTful?</strong><br>ihower.tw</a><a href=\"https://ihower.tw/blog/archives/1542\" class=\"js-mixtapeImage mixtapeImage u-ignoreBlock\" data-media-id=\"a901032818a59ce358d226fab6708ce8\" data-thumbnail-img-id=\"0*7YXEMLlftCGhHQBP.\" style=\"background-image: url(https://cdn-images-1.medium.com/fit/c/320/320/0*7YXEMLlftCGhHQBP.);\"></a>\\n</div>\\n<div>\\n<a href=\"https://en.wikipedia.org/wiki/Remote_procedure_call\" data-href=\"https://en.wikipedia.org/wiki/Remote_procedure_call\" class=\"markup--anchor markup--mixtapeEmbed-anchor\" title=\"https://en.wikipedia.org/wiki/Remote_procedure_call\" rel=\"nofollow\"><strong class=\"markup--strong markup--mixtapeEmbed-strong\">Remote procedure call - Wikipedia</strong><br>en.wikipedia.org</a><a href=\"https://en.wikipedia.org/wiki/Remote_procedure_call\" class=\"js-mixtapeImage mixtapeImage u-ignoreBlock\" data-media-id=\"10077982c79b5ee8217a4e149067b183\" data-thumbnail-img-id=\"0*Pi_nJ605Y2_ah5xl\" style=\"background-image: url(https://cdn-images-1.medium.com/fit/c/320/320/0*Pi_nJ605Y2_ah5xl);\"></a>\\n</div><p>文章同步發表於 <a href=\"https://medium.com/@jinghua.shih\">Medium</a>。",
        "status": 1,
        "description": "帶回家的訊息：REST 真的很難懂",
        "created_at": "2019-03-10T08:17:55.284921",
        "updated_at": "2019-04-16T05:20:03.420358",
        "slug": "筆記-rest-到底是什麼",
        "medium_url": "https://medium.com/@jinghua.shih/%E7%AD%86%E8%A8%98-rest-%E5%88%B0%E5%BA%95%E6%98%AF%E4%BB%80%E9%BA%BC-170ad2b45836"
    },
    {
        "id": 34,
        "title": "[Mac Setup] 讓你的開發速度大躍進的好工具們",
        "body": "<p></p>\\n<p>[2019/4/7 更新] zsh 的主題不用 spaceship 了，改用 <a href=\"https://github.com/jackharrisonsherlock/common\" data-href=\"https://github.com/jackharrisonsherlock/common\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">common</a>–推薦給像我一樣追求簡潔介面的使用者</p>\\n<p>今天不講技術，來聊聊一些對於開發者們不可或缺的好資源，讓你寫程式又愉悅又有效率！經過了新手時期，不用再忙著祈禱剛剛敲出那一堆似懂非懂的指令會成功，或是擔心程式下一秒就會爆炸，就會開始有餘裕來找碴—漸漸看某些東西不順眼—並且想辦法優化，比如說一些常用但又很長的 terminal 指令（grep 我在說你）。做為一個優秀的工程師，能不冗就絕對不會冗，能用 0.1 秒就打完的指令絕對……會想辦法把它自動化完成。你說省下那 0.1 秒要做什麼？當然是拿來思索存在的本質還有人生的意義啊。所以今天就來分享我一路走來覺得讓人生變得充實又完整的那些工具們，讓你寫程式有如神助而且還會看起來很厲害！</p>\\n<p>必須感謝同事 Leslie 的不間斷啟發（各種 vim 跟 terminal 的真人版 tip of the day）與主管彥廷的好榜樣（還有耐心地忍受我之前中古世紀的開發環境）。以下內容其實大部分是在進公司實習這一個多月來收集到的好東西。感恩再感恩。</p>\\n<p>分成幾個部分：</p>\\n<blockquote>[STEP 0]</blockquote>\\n<blockquote>[STEP 1] iTerm2</blockquote>\\n<blockquote>[STEP 2] Zsh + Oh My Zsh</blockquote>\\n<blockquote>[STEP 2.1] AutoJump</blockquote>\\n<blockquote>[STEP 2.2] AutoSuggestions</blockquote>\\n<blockquote>[STEP 3] Sublime Text</blockquote>\\n<blockquote>([STEP 4] Vim)</blockquote>\\n<p>本來有寫到 Vim 的，但是打著打著就發現事態不妙（篇幅越來越長），加上 Vim 有各種好插件必須娓娓道來，大概自己就能單獨成篇，所以就請它下篇再登場了。</p>\\n<h3>開始之前</h3>\\n<p>先介紹兩個集大成的網頁：<a href=\"https://github.com/jaywcjlove/awesome-mac\" data-href=\"https://github.com/jaywcjlove/awesome-mac\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">Awesome Mac</a> 與 <a href=\"https://sourabhbajaj.com/mac-setup/\" data-href=\"https://sourabhbajaj.com/mac-setup/\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">Mac OS Setup Guide</a>。前者是各種你想得到跟想不到的工具大集合，第一次進去可能會有點迷失，要小心。後者是手把手帶你走過一些開發者常使用的設定，我今天要講的它裡面其實也都有講到，非常建議先去看看這個網站，等等會講到的也會有一部份是來自於它。</p>\\n<h4>[STEP -1] Remap Your Keyboard like a Pro</h4>\\n<p>如果你常常使用電腦指令，就會發現明明 <code class=\"markup--code markup--p-code\">Control</code> 鍵如此常用，卻是放在鍵旁上一個很不符合人體工學的邊陲位置—每次要使用它，都要特別拐一下小拇指才能按到，這當然是不被允許的，所以請到 System Preferences → Keyboard → Modify Keys 把 <code class=\"markup--code markup--p-code\">Caps Lock</code> 與 <code class=\"markup--code markup--p-code\">Control</code> 的位置對調，你會發現人生豁然開朗。</p>\\n<h4>[STEP 0] 下載 Homebrew</h4>\\n<p>[網站] <a href=\"https://brew.sh/index_zh-tw\" data-href=\"https://brew.sh/index_zh-tw\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">https://brew.sh/</a></p>\\n<p>[安裝方式]</p>\\n<pre># command line</pre>\\n<pre>/usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\"</pre>\\n<p>如果你還沒有下載 Homebrew 的話，就是現在了。它是一個為 Mac 設計的套件管理工具（Package Manager），等等絕大部分的軟體都會用 homebrew 來下載。</p>\\n<p>準備好了，預備備——開始！</p>\\n<h3>[STEP 1] iTerm2</h3>\\n<p>[網站] <a href=\"https://www.iterm2.com/\" data-href=\"https://www.iterm2.com/\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener nofollow noopener\" target=\"_blank\">https://www.iterm2.com/</a></p>\\n<p>[安裝方式]</p>\\n<pre>brew cask install iterm2</pre>\\n<p>Iterm2 取代 Mac 內建的 terminal，可以做到 terminal 可以做到的事情<a href=\"https://www.iterm2.com/features.html\" data-href=\"https://www.iterm2.com/features.html\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">還有更多</a>，比如說酷炫的 hotkey window （但功能還是有限制比如說在裡面開 vim 就不行）或是各種客製化配色—可以在 <a href=\"https://github.com/mbadolato/iTerm2-Color-Schemes\" data-href=\"https://github.com/mbadolato/iTerm2-Color-Schemes\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">iterm2-color-scheme</a> 這裡選一個自己看得最順眼的。我是用 Spacedust。</p>\\n<p>這邊強烈推薦去下載字型 <a href=\"https://github.com/IBM/plex\" data-href=\"https://github.com/IBM/plex\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">IBM Plex Mono</a> (14pt, Light)。前面介紹的 Mac Setup Guide 是推薦使用 <a href=\"https://github.com/adobe-fonts/source-code-pro\" data-href=\"https://github.com/adobe-fonts/source-code-pro\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">Source Code Pro</a>，可以兩個都下載來看看哪個自己比較喜歡（或是不講究的話其實也可以省略）。連結裡面都有在 Mac OS 裡面安裝的方式，裝到電腦之後到 iTerm2 → Preferences → Profile → Default → Text → Change Font 去設定。</p>\\n<h3>[STEP 2] Zsh + Oh My Zsh</h3>\\n<p>[安裝方式]</p>\\n<pre><strong class=\"markup--strong markup--pre-strong\"># Install Zsh<br></strong>brew install zsh</pre>\\n<pre><strong class=\"markup--strong markup--pre-strong\"># Make Zsh your default shell</strong><br>sudo sh -c \"echo $(which zsh) &gt;&gt; /etc/shells\" <br>chsh -s $(which zsh)</pre>\\n<pre><strong class=\"markup--strong markup--pre-strong\"># Install Oh My Zsh<br></strong>sh -c \"$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)\"</pre>\\n<p>[Oh My Zsh 網站] <a href=\"https://ohmyz.sh/\" data-href=\"https://ohmyz.sh/\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener nofollow noopener\" target=\"_blank\">https://ohmyz.sh/</a></p>\\n<p>iTerm2 + Zsh + Oh My Zsh 是一個經典套餐。</p>\\n<p>Mac 預設的 shell 是 <a href=\"https://en.wikipedia.org/wiki/Bash_%28Unix_shell%29\" data-href=\"https://en.wikipedia.org/wiki/Bash_(Unix_shell)\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">bash (Bourne Again Shell)</a>。可想而知在它之前有一個 shell 叫做 <a href=\"https://en.wikipedia.org/wiki/Bourne_shell\" data-href=\"https://en.wikipedia.org/wiki/Bourne_shell\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">Bourne Shell</a>—說到這個就想岔開話題一下，你們知不知道一個常用的檔案格式 <a href=\"https://yaml.org/\" data-href=\"https://yaml.org/\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">yaml (.yml)</a> 的全名是什麼？ <strong class=\"markup--strong markup--p-strong\">Yet Another Markup Language。</strong>如此瀟灑。（注：<a href=\"https://en.wikipedia.org/wiki/Markup_language\" data-href=\"https://en.wikipedia.org/wiki/Markup_language\" rel=\"nofollow noopener\" target=\"_blank\">Markup Language</a> 叫做標記式語言–<a href=\"https://developer.mozilla.org/zh-TW/docs/Learn/Getting_started_with_the_web/HTML_basics\" data-href=\"https://developer.mozilla.org/zh-TW/docs/Learn/Getting_started_with_the_web/HTML_basics\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">HTML</a> 就是其中一種）至於後來他們又把自己改稱為 <strong class=\"markup--strong markup--p-strong\">Y</strong>AML <strong class=\"markup--strong markup--p-strong\">A</strong>in’t a <strong class=\"markup--strong markup--p-strong\">M</strong>arkup <strong class=\"markup--strong markup--p-strong\">L</strong>anguage 就是另外一個故事了。</p>\\n<p>對於我（與其他許多開發者）而言，使用 Z Shell 的最大好處就是很容易客製化，而且有強大的 framework （像是 Oh My Zsh）讓你管理與設定非常方便。</p>\\n<p>裝完之後馬上可以看出差別，預設的主題 <code class=\"markup--code markup--p-code\">robbyrussell</code>就已經很不錯了，<a href=\"https://github.com/robbyrussell/oh-my-zsh/wiki/Themes\" data-href=\"https://github.com/robbyrussell/oh-my-zsh/wiki/Themes\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">主題區</a>有超過一百種主題讓你自己挑，而換主題的方式簡單到只需要在 ~/.zshrc 中把</p>\\n<pre> ZSH_THEME=\"robbyrussell\" # default</pre>\\n<p>換成</p>\\n<pre>ZSH_THEME=\"your-theme\" </pre>\\n<p>就好了。</p>\\n<p>如果在裡面的都不喜歡，<a href=\"https://github.com/robbyrussell/oh-my-zsh/wiki/External-themes\" data-href=\"https://github.com/robbyrussell/oh-my-zsh/wiki/External-themes\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">External Themes</a> 這一區再大方加碼更多主題讓你挑，跟上面那區的差別只是這區的主題要用之前需要先下載（不在 default bundle 裡面）。</p>\\n<p>我原本用 <a href=\"https://github.com/denysdovhan/spaceship-prompt\" data-href=\"https://github.com/denysdovhan/spaceship-prompt\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">spaceship</a>，後來改用 <a href=\"https://github.com/jackharrisonsherlock/common\" data-href=\"https://github.com/jackharrisonsherlock/common\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">common</a>，兩個都介紹一下。</p>\\n<p><a href=\"https://github.com/denysdovhan/spaceship-prompt\" data-href=\"https://github.com/denysdovhan/spaceship-prompt\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\"><strong class=\"markup--strong markup--p-strong\">[spaceship]</strong></a></p>\\n<p>它最大的好處是你可以自己決定 prompt 要呈現的內容、順序、連接詞/符號，同樣直接在 ~/.zshrc 裡面設定。</p>\\n<p>Spaceship 安裝方式：</p>\\n<pre># command line</pre>\\n<pre># 先把 repo 複製到資料夾<br>git clone https://github.com/denysdovhan/spaceship-prompt.git \"$ZSH_CUSTOM/themes/spaceship-prompt\"</pre>\\n<pre># 再 symlink<br>ln -s \"$ZSH_CUSTOM/themes/spaceship-prompt/spaceship.zsh-theme\" \"$ZSH_CUSTOM/themes/spaceship.zsh-theme\"</pre>\\n<p>一些我自己在 .zshrc 裡面的相關設定</p>\\n<pre># PROMPT SETTINGS</pre>\\n<pre># Decide what are displayed in what order in the prompt.<br>SPACESHIP_PROMPT_ORDER=(          <br>  dir<br>  git<br>)</pre>\\n<pre># further tuning<br>SPACESHIP_TIME_SHOW=true<br>SPACESHIP_DIR_PREFIX=\"\"<br>SPACESHIP_GIT_SUFFIX=\"\"<br>SPACESHIP_GIT_SYMBOL=\"\"          <br>SPACESHIP_GIT_BRANCH_PREFIX=\"\"   <br>SPACESHIP_GIT_BRANCH_SUFFIX=\" \"  <br>SPACESHIP_GIT_STATUS_SHOW=false</pre>\\n<p>我的目標是乾淨整潔的 terminal，所以這邊我把很多 spaceship 預設會顯示在 prompt 裡面的項目都拿掉了，只剩下兩個我覺得最重要的，然後下面再接再厲修整（把更多東西去掉）讓顯示的項目更乾淨。結果長這樣：</p>\\n<figure class=\"text-center\"><img class=\"lazy\" data-src=\"https://cdn-images-1.medium.com/max/800/1*o-Pe1cgLiQXZHuHx2mqqgg.png\"><figcaption>interface of zsh theme “spaceship”</figcaption></figure><p><a href=\"https://github.com/jackharrisonsherlock/common\" data-href=\"https://github.com/jackharrisonsherlock/common\" rel=\"nofollow noopener\" target=\"_blank\"><strong class=\"markup--strong markup--p-strong\">[common]</strong></a></p>\\n<p>common 安裝方式</p>\\n<pre># command line<br>wget -O $ZSH_CUSTOM/themes/common.zsh-theme https://raw.githubusercontent.com/jackharrisonsherlock/common/master/common.zsh-theme</pre>\\n<p>記得也要改指定主題 <code class=\"markup--code markup--p-code\">ZSH_THEME=\"common\"</code>。</p>\\n<p>它不用什麼設定就跟我想要的差不多了，而且把 git 的資訊顯示在右邊：</p>\\n<figure class=\"text-center\"><img class=\"lazy\" data-src=\"https://cdn-images-1.medium.com/max/800/1*YxE-dg_7Lv6DRodjFVDUCQ.png\"><figcaption>interface of zsh theme “common”</figcaption></figure>\\n<p>這邊我自己有去修了一下原始碼，把 prompt 的字體改成粗體：</p>\\n<pre># $ZSH_CUSTOM/theme/common.zsh-theme:32</pre>\\n<pre>common_current_dir() {<br>  echo -n \"%{%B%}\" # set bold<br>  echo -n \"%{$fg[blue]%}%c \"<br>  echo -n \"%{%b%}\" # unset bold<br>}</pre>\\n<p>我的 .zshrc 有上傳到 <a href=\"https://github.com/jing-jenny-shih/dotfiles\" data-href=\"https://github.com/jing-jenny-shih/dotfiles\" class=\"markup--anchor markup--p-anchor\" rel=\"noopener nofollow\" target=\"_blank\">github</a>，有興趣的可以自己去看。</p>\\n<h4>[STEP 2.1] AutoJump</h4>\\n<p>[網站] <a href=\"https://github.com/wting/autojump\" data-href=\"https://github.com/wting/autojump\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener nofollow noopener\" target=\"_blank\">https://github.com/wting/autojump</a></p>\\n<p>[安裝方式]</p>\\n<pre># command line<br><code class=\"markup--code markup--pre-code\">brew install autojump</code></pre>\\n<pre># in ~/.zshrc<br>[ -f /usr/local/etc/profile.d/autojump.sh ] &amp;&amp; . /usr/local/etc/profile.d/autojump.sh</pre>\\n<p>這也是一個 must-have––太方便了。裝了這個之後，從此你再也不會記得檔案的正確路徑XD 以前要進入一個資料夾，都要一層一層的 cd 過去，或是專門設一個環境變數來呼叫，裝了 Autojump 之後，你只要打</p>\\n<pre>j [directory keyword] </pre>\\n<p>它就會去搜歷史紀錄，直接幫你比對找到那個你心中渴望卻懶得打出路徑的資料夾！</p>\\n<p>比如說我存放 jennycodes 網站專案的資料夾叫做 jennycodes (duh)，絕對路徑是 ~/Developer/Rails/jennycodes：</p>\\n<figure class=\"text-center\"><img class=\"lazy\" data-src=\"https://cdn-images-1.medium.com/max/1600/1*We3xAVK-6J8K90CLdlQsUw.png\"><figcaption class=\"imageCaption\">autojump magic!</figcaption></figure><p>酷吧！</p>\\n<h4>[STEP 2.2] AutoSuggestions</h4>\\n<p>[網站] <a href=\"https://github.com/zsh-users/zsh-autosuggestions\" data-href=\"https://github.com/zsh-users/zsh-autosuggestions\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">https://github.com/zsh-users/zsh-autosuggestions</a></p>\\n<p>[安裝方式]</p>\\n<pre># command line<br>git clone https://github.com/zsh-users/zsh-autosuggestions ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-autosuggestions</pre>\\n<pre># in ~/.zshrc<br>plugins=(zsh-autosuggestions)</pre>\\n<pre># [optional] press 'Ctrl-k' to accept suggestion (default is -&gt;)<br>bindkey '^k' autosuggest-accept</pre>\\n<p>這也是另一個大大提升效率的小工具—同樣從你過往執行過的命令去猜你現在想要打出來的字串，非常聰明：</p>\\n<figure class=\"text-center\"><img class=\"lazy\" data-src=\"https://cdn-images-1.medium.com/max/1600/1*UX_quVug2D98Pt916edQkA.png\"></figure><p>如果你看到它確實猜到你想打的東西，那就可以快樂地按下右方向鍵接受建議，或是更上一層樓像我一樣設定使用 <code class=\"markup--code markup--p-code\">Ctrl-k</code> 來接受。（為什麼不用 <code class=\"markup--code markup--p-code\">→</code>？因為 <code class=\"markup--code markup--p-code\">→</code> 很遠啊）</p>\\n<h3>[STEP 3] Sublime Text</h3>\\n<p>[網站] <a href=\"https://www.sublimetext.com\" data-href=\"https://www.sublimetext.com\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">https://www.sublimetext.com</a></p>\\n<p>[安裝方式] 直接點進網站下載</p>\\n<p>Sublime Text 是一個很強大的免費文字編輯器。一般現代編輯器的功能它都有，最近一版還整合了 Git，可以直接在編輯介面裡面操做 Git。除了必須定期關掉叫你買 pro 版的提示之外，使用者體驗非常良好。</p>\\n<p>基本上下載完就可以直接用了，但是很建議依照<a href=\"https://ashleynolan.co.uk/blog/launching-sublime-from-the-terminal\" data-href=\"https://ashleynolan.co.uk/blog/launching-sublime-from-the-terminal\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">這篇文章</a>的指示來讓你可以直接從 terminal 打開 sublime。而讓你的人生更加容易的小技巧是到你的 .zshrc 裡面加上這兩行指令：</p>\\n<pre>alias sl='sublime'<br>alias sll='sublime .'</pre>\\n<p>沒有意外的話，你會很常用到 <code class=\"markup--code markup--p-code\">sll</code>，不客氣。</p>\\n<p>在 Sublime Text → Preferences → Settings 裡面可以調整一些預設值，貼出我調整的部分供參考</p>\\n<pre># Sublime Text Settings<br>{<br> \"fallback_encoding\": \"BIG-5\",<br> \"font_size\": 14,<br> \"highlight_modified_tabs\": true,<br> \"ignored_packages\":[],            # default: [\"Vintage\"]<br> \"tab_size\": 2,<br> \"translate_tabs_to_spaces\": true<br>}</pre>\\n<p>稍微解釋一下，第四行是「要忽略的套件」，原本預設是 [“Vintage”]，那是一個讓你在 sublime text 中模擬 Vim (下一篇的主角！) 的套件。把 <code class=\"markup--code markup--p-code\">“ignored_packages”</code> 的值變成空的意思就是把 Vintage Mode 打開，也就是把 Vim 模擬功能打開，這個等我們看完下一篇之後就知道為什麼要這樣做了。 <code class=\"markup--code markup--p-code\">“tab_size”: 2</code> 則是把 tab 的字元數設定為 2 （預設是 4），因為開發 Ruby 習慣用 2；<code class=\"markup--code markup--p-code\">“translate_tabs_to_spaces”: true</code>是把 tab 變成空白字元（而不是 tab），避免程式碼因為縮排方式不一致而出錯。</p>\\n<p>另外，<a href=\"https://packagecontrol.io/\" data-href=\"https://packagecontrol.io/\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">sublime packages</a> 裡面也可以找到很多很不錯的套件，像是經典的 html 產生器 <a href=\"https://packagecontrol.io/packages/Emmet\" data-href=\"https://packagecontrol.io/packages/Emmet\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">Emmet</a> 或是 <a href=\"https://packagecontrol.io/packages/SublimeLinter\" data-href=\"https://packagecontrol.io/packages/SublimeLinter\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">Sublime Linter</a>。Happy Hunting!</p><h3>先這樣</h3>\\n<p>寫這個實在是太有趣了，邊寫也順便自己重新整理了一次自己個人電腦的環境，下一篇要介紹的 Vim 更加有趣，敬請期待！</p>\\n<p>這篇會不定期更新，慢慢加入我未來將會發現的更多開發好資源，如果你有什麼你覺得值得分享的套件或是設定，歡迎<a href=\"https://jennycodes.me/contact\" data-href=\"https://jennycodes.me/contact\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">來跟我說</a>！分享讓世界更美好：）</p><p>文章同步發表於 <a href=\"https://medium.com/@jinghua.shih\">Medium</a>。",
        "status": 1,
        "description": "iTerm2, Oh My Zsh, Sublime Text",
        "created_at": "2019-04-06T01:30:48.928074",
        "updated_at": "2019-04-15T12:37:12.077597",
        "slug": "mac-setup-讓你的開發速度大躍進",
        "medium_url": "https://medium.com/@jinghua.shih/mac-setup-%E8%AE%93%E4%BD%A0%E7%9A%84%E9%96%8B%E7%99%BC%E9%80%9F%E5%BA%A6%E5%A4%A7%E8%BA%8D%E9%80%B2-cd07fa327aaf"
    },
    {
        "id": 36,
        "title": "[Operating System] Process Synchronization",
        "body": "<br>\\n<blockquote> Warning: this is more of a note than an well-formed article. Be prepared! </blockquote>\\n\\n<h3 id=\"content\">Content</h3>\\n\\n<ol>\\n<li>Some Background\\n\\n\\n<ul>\\n<li>Concurrency</li>\\n\\n<li>Race Condition</li></ul>\\n</li>\\n\\n<li>The Critical Section Problem</li>\\n\\n<li>Three Requirements for a Valid Solution\\n\\n\\n<ul>\\n<li>Mutual Exclusion</li>\\n\\n<li>Progress</li>\\n\\n<li>Bounded Waiting</li></ul>\\n</li>\\n\\n<li>Peterson's Solution: an example</li>\\n\\n<li>Hardware-based Solutions\\n\\n\\n<ul>\\n<li><code>test_and_set()</code> instruction</li>\\n\\n<li><code>compare_and_swap()</code> instruction</li></ul>\\n</li>\\n\\n<li>Software-based Solutions\\n\\n\\n<ul>\\n<li>Mutex Locks</li>\\n\\n<li>Semaphores</li></ul>\\n</li>\\n\\n<li>Implementation Obstacles\\n\\n\\n<ul>\\n<li>Deadlocks</li>\\n\\n<li>Starvation</li>\\n\\n<li>Priority Inversion</li></ul>\\n</li>\\n\\n<li>Classic Problems of Synchronization(the three tests to pass)\\n\\n\\n<ul>\\n<li>The Bounded-Buffer Problem</li>\\n\\n<li>The Reader-Writer Problem</li>\\n\\n<li>The Dining Philosophers Problem</li></ul>\\n</li>\\n\\n<li>Monitors: The High-Level Synchronization Construct\\n\\n\\n<ul>\\n<li>The condition Construct</li>\\n\\n<li>Example: Solving The Dining Philosophers Problem</li>\\n\\n<li>Resource Allocator</li>\\n\\n<li>Java Monitors</li></ul>\\n</li>\\n\\n<li>[OS Synchronization Example] Windows</li>\\n\\n<li>[OS Synchronization Example] Linux\\n\\n\\n<ul>\\n<li>Preemptive Kernel vs Nonpreemptive Kernel</li></ul>\\n</li>\\n\\n<li>[OS Synchronization Example] Solaris</li>\\n\\n<li>[User-Level Synchronization Example] Pthreads</li>\\n</ol>\\n\\n<p>Okay. It does seem a lot. Have faith–we will make it.</p>\\n\\n<h3 id=\"01somebackground\">01 Some Background</h3>\\n\\n<ul>\\n<li>Processes can execute <a href=\"https://en.wikipedia.org/wiki/Parallel_computing\">in parallel</a> or  <a href=\"https://en.wikipedia.org/wiki/Concurrency_(computer_science)\">concurrently</a>.\\n\\n\\n<ul>\\n<li>Concurrent execution means that one process may only partially complete execution before the CPU is give to another process.</li>\\n\\n<li>Prallel execution means 1+ processes can run simultaneously on separate processing cores.</li></ul>\\n</li>\\n\\n<li>When they do so, they are risking <strong>data inconsistency</strong> if they access a shared data at the same time, thus impact the integrity of data.</li>\\n\\n<li><a href=\"https://en.wikipedia.org/wiki/Race_condition\">Race Condition</a> is a typical situation that causes data inconsistency.</li>\\n\\n<li>How does race condition occur?</li>\\n</ul>\\n\\n<ol>\\n<li>Several processes access and manipulate the same data concurrently.</li>\\n\\n<li>The outcome of the execution depends on the particular order.</li>\\n</ol>\\n\\n<ul>\\n<li>How to avoid race condition?\\n\\n\\n<ul>\\n<li>Ensure that only one process at a time can be manipulating the shared data.</li></ul>\\n</li>\\n</ul>\\n\\n<h3 id=\"02thecriticalsectionproblem\">02 The Critical Section Problem</h3>\\n\\n<ul>\\n<li><p>Critical section is a segment of code in a process. The system ensures that when a process is executing in its critical section, no other processes can execute in their critical section. That is, no two processes are executing in their critical sections at the same time.</p></li>\\n\\n<li><p>The critical section problems is to design a protocol that the processes can use to cooperate.</p></li>\\n\\n<li><p>The general structure of a typical process P:</p>\\n\\n<pre><code class=\"c language-c\">do {\\n// entry section\\n// critical section\\n// exit section\\n// remainder section\\n} while(true);\\n</code></pre></li>\\n</ul>\\n\\n<h3 id=\"03threerequirementsforavalidsolution\">03 Three Requirements for a Valid Solution</h3>\\n\\n<p>Any valid solution would need to meet the following three requirement:</p>\\n\\n<h4 id=\"mutualexclusion\">Mutual Exclusion</h4>\\n\\n<blockquote>\\n  <p>If process P is executing in its critical section, then no other processes can be executing in their critical sections.</p>\\n</blockquote>\\n\\n<h4 id=\"progress\">Progress</h4>\\n\\n<blockquote>\\n  <p>If no process is executing in its critical section and some processes wish to enter their critical sections, then only those processes that are not executing in their remainder sections can participate in deciding which will enter its critical section next, and this selection cannot be postponed indefinitely.</p>\\n</blockquote>\\n\\n<p>That is, when there is an availability, a process must be selected, and the process cannot be executing in its remainder section.</p>\\n\\n<h4 id=\"boundedwaiting\">Bounded Waiting</h4>\\n\\n<blockquote>\\n  <p>There exist a bound, or limit, on the number of times that other processes are allowed to enter their critical sections after as process has made a request to enter its critical section and before that request is granted.</p>\\n</blockquote>\\n\\n<p>This one is the hardest to meet. It requires that we need to guarantee that no process should wait indefinitely(we call it starvation) for permission to execute its critical section.</p>\\n\\n<h3 id=\"04petersonssolutonanexample\">04 Peterson's Solution: an example</h3>\\n\\n<ul>\\n<li><p>Peterson's solution is a classic software-based solution to the critical-section problem.</p></li>\\n\\n<li><p>But note that there are no guarantees that Peterson's solution will work correctly on modern computer architectures, because of the way they perform basic machine-language instructions such as <code>load</code> and <code>store</code>.</p></li>\\n\\n<li><p>This solution is restricted to <strong>two</strong> processes that alternate execution between their critical sections and remainder sections.</p></li>\\n\\n<li><p>Data Items that the processes share:</p>\\n\\n<p><ul>\\n<li><code>int turn</code>  --> whose turn it is to enter its critical section</li></p>\\n\\n<p><li><code>boolean flag[2]</code>  --> indicate if a process is ready to enter its critical section</li></ul>\\n\\n<p></p></li></p>\\n\\n<p><li><p>The structure of process Pi in Peterson's solution(assuming there are process Pi and Pj):</p></p>\\n\\n<pre><code class=\"c language-c\">do {\\nflag[i] = true;  // entry section\\nturn = j;\\nwhile (flag[j] &amp;&amp; turn == j);\\n\\n// critical section\\n\\nflag[i] = false; // exit section\\n\\n// remainder section\\n} while(true);\\n</code></pre>\\n\\n<p></li></p>\\n\\n<p><li><p>Steps(for process Pi):</p></li>\\n</ul></p>\\n\\n<ol>\\n<li>Pi sets <code>flag[i]</code> to be true and <code>turn</code> to j --> if the other process wishes to enter its critical section, it can do so.</li>\\n\\n<li>If both processes execute at the same time, only one assignment will last(the other will be overwritten).</li>\\n\\n<li>The eventual value of turn determines which process will enter its critical section first.</li>\\n\\n<li>If the other process is executing its critical section (i.e. <code>turn</code> == j) Pi will wait.</li>\\n\\n<li>When the waiting (the <code>while</code> part) is over, Pi enters its critical section.</li>\\n\\n<li>After execution Pi sets its flag to false, signaling it is out of its critical section.</li>\\n\\n<li>Pi executes in the remainder section.</li>\\n</ol>\\n\\n<ul>\\n<li>Does this solution meet all the requirements? Yes.</li>\\n</ul>\\n\\n<h3 id=\"05hardwarebasedsolutions\">05 Hardware-based Solutions</h3>\\n\\n<ul>\\n<li>Some simple hardware instructions that are available on many systems.</li>\\n\\n<li>Hardware features can make any programming task easier and imporve system efficiency.</li>\\n\\n<li>In a <strong>single-processor environment</strong>, we just need to prevent interrupts while a shared variable was being modified.\\n--> so the current sequence of instruction can execute in order without preemption.</li>\\n\\n<li>In a <strong>multiprocessor environment</strong>, however, disabling interrupts is not a good choice because</li>\\n</ul>\\n\\n<ol>\\n<li>It is time consuming, because the message is passed to all processors.</li>\\n\\n<li>It impacts efficiency, because message passing delays entry into each critical section.</li>\\n</ol>\\n\\n<ul>\\n<li>Many modern computer systems provide special <strong>harware instructions</strong> that allow us to do some tasks automically(as one uninterruptible unit), as follows:</li>\\n</ul>\\n\\n<ol>\\n<li><p>test and modify the content of a word --> <code>test_and_set()</code></p>\\n\\n<ul>\\n<li>importance: if the machine supports this instruction, then we can implement mutual exclusion by declaring a boolean variable <code>lock</code> and initialize it to <code>false</code> as shown below.</li>\\n\\n<li>Definition:</li></ul>\\n\\n<pre><code class=\"c language-c\">boolean test_and_set(boolean *target) {\\n  boolean rv = *target;\\n  *target = true;\\n\\n  return rv;\\n}\\n</code></pre>\\n\\n<ul>\\n<li>Mutual-Exclusion Implementation with <code>test_and_set()</code> instruction:\\n(note: this implementation does not satisfy the bounded-waiting requirement)</li></ul>\\n\\n<pre><code class=\"c language-c\">do {\\n  while (test_and_set(&amp;lock))\\n    ; // do nothing\\n\\n  // critical section\\n\\n  lock = false;\\n\\n  // remainder section\\n} while (true);\\n</code></pre>\\n\\n<ul>\\n<li>Bounded-Waiting Mutual Exclusion with <code>test_and_set()</code>:</li></ul>\\n\\n<pre><code class=\"c language-c\">// the common data structure:\\nboolean waiting[n];\\nboolean lock;\\n\\ndo {\\n  waiting[i] = true;\\n  key = true;\\n  while (waiting[i] &amp;&amp; key)\\n    key = test_and_set(&amp;lock);\\n  waiting[i] = false;\\n\\n  // critical section\\n\\n  j = (i + 1) % n;\\n  while((j != i) &amp;&amp; !waiting[j])\\n    j = (j = 1) % n;\\n\\n  if (j == i)\\n    lock = false;\\n  else\\n    waiting[j] = false;\\n\\n  // remainder section\\n} while (true);\\n</code></pre></li>\\n\\n<li><p>swap the contents of two words --> <code>compare_and_swap()</code></p>\\n\\n<ul>\\n<li>Always returns the original value of the variable <code>value</code>.</li>\\n\\n<li>Provides mutual exclusion:</li></ul>\\n\\n<ol>\\n<li>Declare and initialize a global variable(<code>lock</code>) to 0.</li>\\n\\n<li>The first process, P1, invokes <code>compare_and_swap()</code> and sets <code>lock</code> to 1.</li>\\n\\n<li>P1 enters critical section, because the original value of <code>lock</code> was equal to the expected value of 0.</li>\\n\\n<li>Meanwhile, other processes are prevented from entering their critical section because <code>lock</code> is not 0 now.</li>\\n\\n<li>P1 exits critical section, sets <code>lock</code> back to 0.</li>\\n\\n<li>Another process enters its critical section.</li></ol>\\n\\n<ul>\\n<li>Definition</li></ul>\\n\\n<pre><code class=\"c language-c\">int compare_and_swap(int *value, int expected, int new_value) {\\n  int temp = *value;\\n\\n  if (*value == expected)\\n    *value = new_value;\\n\\n  return temp;\\n}\\n</code></pre>\\n\\n<ul>\\n<li>Mutual-Exclusion implementation with <code>compare_and_swap()</code> instruction:\\n(note: this implementation does not satisfy the bounded-waiting requirement)</li></ul>\\n\\n<pre><code class=\"c language-c\">do {\\n  while (compare_and_swap(&amp;lock, 0, 1) != 0)\\n    ; // do nothing\\n\\n  // critical section\\n\\n  lock = 0;\\n\\n  // remainder section\\n} while (true);\\n</code></pre></li>\\n</ol>\\n\\n<h3 id=\"06softwarebasedsolutions\">06 Software-based Solutions</h3>\\n\\n<ul>\\n<li>The hardware-based solutions are complicated as well as generally inaccessible to application programmers.</li>\\n\\n<li>So operating-systems designers build software tools to solve the critical section problem.</li>\\n\\n<li>Generally there are two kinds of the tools:\\n\\n\\n<ul>\\n<li>mutex lock (mutex = mutual exclusion)</li>\\n\\n<li>semaphore</li></ul>\\n</li>\\n</ul>\\n\\n<h4 id=\"mutexlocks\">Mutex Locks</h4>\\n\\n<ul>\\n<li><p>The process must <code>acquire()</code> the lock before entering a critical section, and <code>release()</code> the lock on exiting the critical section.</p>\\n\\n<ul>\\n<li>structure:</li></ul>\\n\\n<pre><code class=\"c language-c\">do {\\n// acquire lock\\n\\n// critical section\\n\\n// release lock\\n\\n// remainder section\\n} while (true)\\n</code></pre></li>\\n\\n<li><p>A mutex lock uses a boolean variable <code>available</code> to indicate if the lock is available or not.</p></li>\\n\\n<li><p>Definition:</p>\\n\\n<pre><code class=\"c language-c\">acquire() {\\nwhile (!available)\\n  ; // busy wait\\navailable = false;\\n}\\n\\nrelease() {\\navailable = true;\\n}\\n</code></pre></li>\\n\\n<li><p>Calls to <code>acquire()</code> or <code>release()</code> must be performed atomically. So mutex locks are often implemented with on of the hardware mechanisms described above.</p></li>\\n</ul>\\n\\n<h4 id=\"spinlocksthebusywaitingmutexlock\">Spinlocks: The Busy Waiting Mutex Lock</h4>\\n\\n<ul>\\n<li>While a process is in its critical section, any other process that tries ot enter its critical section must loop continuously (in its call to <code>acquire()</code>).</li>\\n\\n<li>The process 'spins' while waiting for the lock to become available.</li>\\n\\n<li>Disadvantage: For a real multiprogramming system(where a single CPU is shared among many rocesses), busy waiting wastes CUP cycles.</li>\\n\\n<li>Advangate: no context switch is required.</li>\\n</ul>\\n\\n<h4 id=\"semaphores\">Semaphores</h4>\\n\\n<ul>\\n<li><p>Behaves simiparly to a mutex lock but more sophisticated for process synchronization.</p></li>\\n\\n<li><p>A <strong>semaphore</strong> S is an integer variable that is accessed only through two standard atomic opeartions(apart from initialization): <code>wait()</code> and <code>signal()</code>.</p>\\n\\n<ul>\\n<li>Definitions:</li></ul>\\n\\n<pre><code class=\"c language-c\">wait(S) {\\nwhile (S &lt;= 0)\\n  ; //busy wait\\nS--;\\n}\\n\\nsignal(S) {\\nS++;\\n}\\n</code></pre></li>\\n\\n<li><p>When one process midifies the semaphore value, no other process can simultaneously modify that same semaphore value.</p></li>\\n\\n<li><p>binary vs counting semaphors</p>\\n\\n<p><ul>\\n<li>[binary semaphore] values can range between 0 and 1.</li></p>\\n\\n<p><li>behaves like a mutex lock.</li></p>\\n\\n<p><li>[counting semaphor] values can range over an unrestricted doain.</li></p>\\n\\n<p><li>useful to control access to a given resource consisting of a finite number of instances.</li></p>\\n\\n<p><li>The semaphore is initialized to the number of resources available.</li></p>\\n\\n<p><li>If a process wishes to use a resource, it performs a <code>wait()</code>–decrementing the count.</li></p>\\n\\n<p><li>When the process releases the resource, it performs a <code>signal()</code>–incrementing the count.</li></ul>\\n\\n<p></p></li></p>\\n\\n<p><li><p>Implementation without Busy Waiting</p></p>\\n\\n<ul>\\n<li>Make the process <strong>block itself</strong> instead of busy waiting.</li>\\n\\n<li>The block operation places a process into a waiting queue associated with the semaphores, and the state of the process is switched to the waiting state.</li>\\n\\n<li>The put-to-wait process should be restarted (<code>wakeup()</code>) and put back to the ready queue  when someone issues  a <code>signal()</code> operation.</li>\\n\\n<li>Structure of a Semaphore Implementation</li></ul>\\n\\n<pre><code class=\"c language-c\">typedef struct {\\nint value;\\nstruct process *list;\\n} semaphore;\\n\\nwait(semaphore *S) {\\nS-&gt;value--;\\nif (S-&gt;value &lt; 0) {\\n  // add this process to S-&gt;list\\n  ...\\n  block();\\n}\\n}\\n\\nsignal(semaphore *S) {\\nS-&gt;value++;\\nif (S-&gt;value &lt;=0 ) {\\n  // remove a process P from S-&gt;list;\\n  ...\\n  wakeup(P);\\n}\\n}\\n</code></pre>\\n\\n<ul>\\n<li>When a process ust wait on a semaphore, it is added to the list of processes.</li>\\n\\n<li>The <code>block()</code> and <code>wakeup()</code> operations are basic system calls (provided by the operating system).</li>\\n\\n<li>If a semaphore is negative, its magnitude is the number of processes waiting on the semaphore.</li>\\n\\n<li>Implementation of the waiting list:</li>\\n\\n<li>can be a link field in each PCB–<a href=\"https://en.wikipedia.org/wiki/Process_control_block\">Process Control Block</a>.</li>\\n\\n<li>Each semaphore contains an integer value and a pointer to a list of PCBs.</li>\\n\\n<li>can use any queueing strategy, like FIFO.</li>\\n\\n<li>Busy waiting still exists: This implementation moves busy waiting from the entry section to the critical sections of the <code>wait()</code> and <code>signal()</code> opeartions.</li>\\n\\n<li>Since these sections are short(if properly coded), the critical section is almost never occupied.</li></ul>\\n\\n<p></li>\\n</ul></p>\\n\\n<h3 id=\"07implementationobstacles\">07 Implementation Obstacles</h3>\\n\\n<ul>\\n<li>Deadlocks\\n\\n\\n<ul>\\n<li>occurs when 2+ processes are waiting indefinitely for an event that caon be caused only by one of the waiting processes.</li>\\n\\n<li>That is, processes that wait on each other will result in a deadlock.</li>\\n\\n<li>Related Problem:</li>\\n\\n<li>indefinite blocking / starvation: processes wait indefinitely within the semaphore</li></ul>\\n</li>\\n\\n<li>Priority Inversion\\n\\n\\n<ul>\\n<li>occurs when a higher-priority process needs to read or modify kernel data that are currently being accessed by a lower-priority process.</li>\\n\\n<li>Since the lower-priority process is lower-priority(duh), it will be preempted by a process with a higher priority.</li>\\n\\n<li>Thus the waiting higher-priority process may wait for a long time because the lower-priority process keeps being preempted.</li>\\n\\n<li>This problem occurs only in systems with 2+ priorities.</li>\\n\\n<li>Solution: 'priority-inheritance protocol'</li>\\n\\n<li>Al processes that are accessing resources needed by a higher-priority process inherit the higher priority until they are finished with the resources.</li>\\n\\n<li>Example: <a href=\"http://www.knusbaum.com/mars/Authoritative_Account\">The Mars Pathfinder</a></li></ul>\\n</li>\\n</ul>\\n\\n<h3 id=\"08classicproblemsofsynchronizationthethreeteststopass\">08 Classic Problems of Synchronization (the three tests to pass)</h3>\\n\\n<ul>\\n<li>These three synchronization problems are examples of a large class of concurrency-control problems.</li>\\n\\n<li>They are used for testing nearly every newly proposed synchronization scheme.</li>\\n</ul>\\n\\n<h4 id=\"theboundedbufferproblem\">The Bounded-Buffer Problem</h4>\\n\\n<ul>\\n<li>commonly used to illustrate the power of synchronization primitives.</li>\\n\\n<li>the producer-consumer problem</li>\\n\\n<li>data structure:</li>\\n</ul>\\n\\n<pre><code class=\"c language-c\">int n;\\nsemaphore mutex = 1;\\nsemaphore empty = n;\\nsemaphore full = 0;\\n</code></pre>\\n\\n<ul>\\n<li>structure of the producer process:</li>\\n</ul>\\n\\n<pre><code class=\"c language-c\">do {\\n  // produce an item in next_produced\\n\\n  wait(empty);\\n  wait(mutex);\\n\\n  // add next_produced to the buffer\\n\\n  signal(mutex);\\n  signal(full);\\n} while (true);\\n</code></pre>\\n\\n<ul>\\n<li>structure of the consumer process:</li>\\n</ul>\\n\\n<pre><code class=\"c language-c\">do {\\n  wait(full);\\n  wait(mutex);\\n\\n  // remove an item from buffer to next_consumed\\n\\n  signal(mutex);\\n  signal(empty);\\n\\n  // consume the item next_consumed\\n} while (true);\\n</code></pre>\\n\\n<h4 id=\"thereaderswritersproblem\">The Readers-Writers Problem</h4>\\n\\n<ul>\\n<li><p>Frequently occurs in database management (database shared among several concurrent processes).</p></li>\\n\\n<li><p>Some processes only wants to read the data (readers), others want to update (writers).</p></li>\\n\\n<li><p>[The First Readers-Writers Problem] requires that no reader be kept waiting unless a writer has already obtained permission to use the shared object.</p></li>\\n\\n<li><p>[The Second Readers-Writers Problem] requires that the writer perform its write asap once it is ready.</p></li>\\n\\n<li><p>A solution to either problem may result in starvation.</p>\\n\\n<p><ul>\\n<li>The first problem, writers may starve.</li></p>\\n\\n<p><li>The second problem, readers may starve.</li></ul>\\n\\n<p></p></li></p>\\n\\n<p><li><p>solution to the first readers-writers problem:</p></p>\\n\\n<pre><code class=\"c language-c\">// data structure shared by the reader processes\\nsemaphore rw_mutex = 1;\\nsemaphore mutex = 1;\\nint read_count = 0;\\n\\n// data structure of a writer process\\ndo {\\nwait(rw_mutex);\\n\\n// perform writing\\n\\nsignal(rw_mutex);\\n} while (true);\\n\\n// data structure of a reader process\\ndo {\\nwait(mutex);\\nread_count++;\\nif (read_count == 1)\\n  wait(rw_mutex);\\nsignal(mutex);\\n\\n// perform reading\\n\\nwait(mutex);\\nread_count--;\\nif (read_count == 0)\\n  signal(rw_mutex);\\nsignal(mutex);\\n} while (true);\\n</code></pre>\\n\\n<ul>\\n<li>The <code>rw_mutex</code> semaphore is shared by both the reader and the writer.</li>\\n\\n<li>The <code>mutex</code> semaphore is used to ensure mutual exclusion when the variable <code>read_count</code> is updated.</li></ul>\\n\\n<p></li></p>\\n\\n<p><li><p>Reader-writer locks are most useful in applications where</p></p>\\n\\n<p><ul>\\n<li>it is easy to indentify which processes only read shared data and which processes only write shared data.</li></p>\\n\\n<p><li>readers > writers. Because reader-writer locks genrally require more overhead to establish than semaphores or mutex locks.So it has to be worth it.</li></ul></p>\\n\\n<p></li>\\n</ul></p>\\n\\n<h4 id=\"thediningphilosopherproblem\">The Dining Philosopher Problem</h4>\\n\\n<ul>\\n<li><p>a representation of the need to allocate several resources among several processes in a deadlock-free and starvation-free manner.</p></li>\\n\\n<li><p>Let each chopstick be a semaphore? Deadlocks could happen.</p>\\n\\n<pre><code class=\"c language-c\">semaphore chopstick[5];\\n\\ndo {\\nwait(chopstick[i]);\\nwait(chopstick[i+1 % 5]);\\n\\n// eat for awhile\\n\\nsignal(chopstick[i]);\\nsignal(chopstick[i+1 % 5]);\\n\\n// think for awile\\n} while (true);\\n</code></pre></li>\\n\\n<li><p>possible remedies:</p></li>\\n</ul>\\n\\n<ol>\\n<li>Allow at most (n-1) philosophers to be sitting simultaneously at the table.</li>\\n\\n<li>Asymmetric Solution: ann odd-numbered philosopher picks up first her left chopstick first, and an even-numbered philosopher picks up her right chopsticks first.</li>\\n\\n<li>Allow a philosopher to pick up her chopsticks only if both choopsticks are available (so she must pick them up in a critical section).\\n--> example in the next chapter.</li>\\n</ol>\\n\\n<h3 id=\"09monitorsthehighlevelsynchronizationconstruct\">09 Monitors: The High-Level Synchronization Construct</h3>\\n\\n<ul>\\n<li><p>(for heedless programmers that have a tendency to mess up semaphores.)</p></li>\\n\\n<li><p>To reduce unintended errors, we introduce a high-level synchronization primitives–monitors with condition varialbles, that take care of semaphores for us.</p></li>\\n\\n<li><p>Underneath, the OS may implement monitors using semaphores and mutex locks.</p></li>\\n\\n<li><p>A function defined within a monitor can access only only those variables declared locally within the monitor and its formal parameters.</p></li>\\n\\n<li><p>The monitor construct ensures that only one process at a time is active within the monitor.\\n--> so programmers does not need to code this synchronization construct explicitly.</p></li>\\n\\n<li><p>syntax:</p>\\n\\n<pre><code class=\"c language-c\">monitor monitor_name\\n{\\n// shared variable declarations\\n...\\n\\n  function P1(...) {\\n    ...\\n  }\\n  function P2(...) {\\n    ...\\n  }\\n  ...\\n  function Pn(...) {\\n    ...\\n  }\\n\\n  initialization_code(...) {\\n    ...\\n  }\\n}\\n</code></pre></li>\\n\\n<li><p>example:</p></li>\\n</ul>\\n\\n<pre><code class=\"c language-c\">monitor sharedcounter {\\n  int counter;\\n  function add() { counter++; }\\n  function sub() { counter--; }\\n  init() { counter = 0; }\\n}\\n</code></pre>\\n\\n<ul>\\n<li>Implicitly, a monitor\\n\\n\\n<ul>\\n<li>defines a mutex lock in the shared variables section.</li>\\n\\n<li>defines mutexes around each function.</li></ul>\\n</li>\\n</ul>\\n\\n<h4 id=\"conditionvariables\">Condition Variables</h4>\\n\\n<ul>\\n<li>Provide additional mechanisms to monitors.\\n\\n\\n<ul>\\n<li>eg. signalling mechanism.</li></ul>\\n</li>\\n\\n<li>A condition variable x in a monitor allows two operations on itself:\\n\\n\\n<ul>\\n<li><code>x.wait()</code>: suspends the calling process until another process calls <code>x.signal()</code></li>\\n\\n<li><code>x.signal()</code>: resumes exactly 1 suspended process. If none, then no effect.</li>\\n\\n<li>This is unlike the semaphore's signalling operation, which preserves state in terms of the value of the semaphore.</li>\\n\\n<li>eg. If a process Y calls <code>x.signal()</code> on a conditional variable x before process Z calls <code>x.wait()</code>, then Z will wait.</li>\\n\\n<li>On the other hand, if Y calls <code>signal(mutex)</code> on a binary semaphore mutex(initialized to 0) before process Z calls <code>wait(mutex)</code>, then Z will not wait, because the semaphore remembers Y's signalling.</li></ul>\\n</li>\\n\\n<li>What happens when a process P calls <code>x.signal()</code> to wake up a process Q waiting on x?\\n\\n\\n<ul>\\n<li>[Signal-and-Wait] Hoare semantics; P waits for either Q to leave the monitor or another condition variable.</li>\\n\\n<li>[Signal-and-Continue] Mesa semantics; Q waits for either P to leave the monitor or another condition variable.</li></ul>\\n</li>\\n</ul>\\n\\n<h4 id=\"monitorbasedsolutiontothediningphilosophersproblem\">Monitor-based solution to the Dining Philosophers Problem</h4>\\n\\n<ul>\\n<li><p>key 1: pick up 2 chopsticks only if both are free.</p>\\n\\n<p><ul>\\n<li>That is, a philosopher moves to her eating state only if both neighbors are not in their eating states.</li></p>\\n\\n<p><li>so we need to define a state for each philosopher.</li></ul>\\n\\n<p></p></li></p>\\n\\n<p><li><p>key 2: If one neighbor is eating, and the philosopher is hungry, ask that neighbor to <code>signal()</code> when she's done.</p></p>\\n\\n<p><ul>\\n<li>so the states of each philosopher are thinking, hungry, eating.</li></p>\\n\\n<p><li>and we need condition variables to do the signalling.</li></ul></p>\\n\\n<p></li></p>\\n\\n<p><li><p>avoids deadlock</p></li></p>\\n\\n<p><li><p>implementation:</p></li>\\n</ul></p>\\n\\n<pre><code class=\"c language-c\">monitor DiningPhilosophers\\n{\\n  enum { THINKING, HUNGRY, EATING } state[5];\\n  condition self[5];\\n\\n  void pickup(int i) {\\n    state[i] = HUNGRY;\\n    test(i);\\n    if (state[i] != EATING)\\n      self[i].wait();  // if unable to eat, go to waitlist.\\n  }\\n\\n  void putdown(int i) {\\n    state[i] = THINKING;\\n    test((i + 4) % 5);\\n    test((i + 1) % 5);\\n  }\\n\\n  void test(int i) {\\n    if ((state[(i + 4) % 5] != EATING) &amp;&amp;\\n      (state[i] == HUNGRY) &amp;&amp;\\n      (state[(i + 1) % 5] != EATING)) {\\n      state[i] = EATING;\\n      self[i].signal();  // no effect during pickup(),\\n                        // but is important during putdown()\\n    }\\n  }\\n\\n  initialization_code() {\\n    for (int i = 0; i &lt; 5; i++)\\n      state[i] = THINKING;\\n  }\\n}\\n</code></pre>\\n\\n<h4 id=\"resumingprocesseswithinamonitor\">Resuming Processes within a Monitor</h4>\\n\\n<ul>\\n<li>If there are 2+ processes waiting to be signalled on a condition x, how to pick?</li>\\n\\n<li>The <strong>Conditional Wait</strong> construct: <code>x.wait(c)</code>\\n\\n\\n<ul>\\n<li><code>c</code> is a <strong>priority number</strong>, stored with the name of the process.</li>\\n\\n<li>When <code>x.signal()</code> is executed, the process with the smallest <code>c</code> is resumed next.</li></ul>\\n</li>\\n\\n<li>ResourceAllocator, an example:</li>\\n</ul>\\n\\n<pre><code class=\"c language-c\">monitor ResourceAllocator\\n{\\n  boolean busy;\\n  condition x;\\n\\n  void acquire(int time) {\\n    if (busy)\\n      x.wait(time); // resumption priority is decided by\\n                    // submitted estimated 'time'.\\n      busy = true;\\n  }\\n\\n  void release() {\\n    busy = false;\\n    x.signal();\\n  }\\n\\n  initialization_code() {\\n    busy = false;\\n  }\\n}\\n</code></pre>\\n\\n<h4 id=\"javamonitors\">Java Monitors</h4>\\n\\n<ul>\\n<li>Java provides  a monitor-like concurrency mechanism for thread synchronization.</li>\\n\\n<li>Every object in Java has associated with a single lock.</li>\\n\\n<li>When a method is declared <code>synchronized</code>, calling the method requires owning the lock for the object.</li>\\n\\n<li>If the lock is already in use by another thread, the requesting thread will be put into <code>entry set</code> for the object's lock.</li>\\n\\n<li>Java's <code>wait()</code> and <code>notify()</code> is similar to a monitor's <code>wait()</code> and <code>signal()</code>.</li>\\n\\n<li>More Java API support can be found in the <code>java.util.concurrent</code> package.</li>\\n\\n<li>example:</li>\\n</ul>\\n\\n<pre><code class=\"java language-java\">public class SimpleClass {\\n  public synchronized void safeMethod() {\\n    // implementation of method\\n  }\\n}\\n</code></pre>\\n\\n<h3 id=\"10ossynchronizationexamplewindows\">10 [OS Synchronization Example] Windows</h3>\\n\\n<p>The Windows operating system is a <strong>multithreaded kernel that provides support for real-time applications and multiple processors</strong>.</p>\\n\\n<h4 id=\"synchronizationinsidethekernel\">Synchronization inside the Kernel</h4>\\n\\n<ul>\\n<li>On a single-processor system, Windows kernel temporarily masks interrupts for all interrupt handlers when accessing a global resource.</li>\\n\\n<li>On a multiprocessor system, Windows uses <strong>spinlocks</strong> to protect global resources (for short code segments).</li>\\n\\n<li>The kernel ensures that a thread will never be preempted while holding a spinlock (for efficiency).</li>\\n</ul>\\n\\n<h4 id=\"synchronizationoutsidethekernel\">Synchronization outside the Kernel</h4>\\n\\n<ul>\\n<li>Windows provides <strong>dispatcher objects</strong>.</li>\\n\\n<li>Dispatcher object types:\\n\\n\\n<ul>\\n<li>[mutex locks]</li>\\n\\n<li>[semaphores]</li>\\n\\n<li>[timers] used to notify 1+ thread(s) that a specified amount of time has expired.</li>\\n\\n<li>[events] similar to condition variables.</li></ul>\\n</li>\\n\\n<li>Dispatcher object states:\\n\\n\\n<ul>\\n<li>[signaled state] means the object is available.</li>\\n\\n<li>[nonsignaled state] means the object is not available.</li></ul>\\n</li>\\n\\n<li><strong>Critical Section Object</strong> is a user-mode mutex that can often be acquired and released without kernel intervention.\\n\\n\\n<ul>\\n<li>It first uses a spinlock to wait.</li>\\n\\n<li>If the spin is to long, the acquiring thread will allocate a kernel mutex and yield its CPU.</li>\\n\\n<li>particularly efficient because the lernel mutex is allocated only when there is contention for the object.</li>\\n\\n<li>In practice, there is very little conention.</li></ul>\\n</li>\\n</ul>\\n\\n<h3 id=\"11ossynchronizationexamplelinux\">11 [OS Synchronization Example] Linux</h3>\\n\\n<ul>\\n<li><code>atomic_t</code>: the simplet synchronization technique within the Linux kernel.\\n\\n\\n<ul>\\n<li>All math operations using atomic integers are performed without interruption.</li>\\n\\n<li>particularly efficient when an integer variable, like a counter, needs to be updated, because atomic operations do not require the overhead of locking mechanisms.</li></ul>\\n</li>\\n\\n<li><code>mutex_lock()</code> and <code>mutex_unlock()</code> are used to enter and leave a critical section.\\n\\n\\n<ul>\\n<li>A task is put to a sleeping state if the lock is unavailable.</li></ul>\\n</li>\\n\\n<li>Spinlocks and semaphores (and the reader-writer versions of these two locks) are provided.</li>\\n\\n<li>On SMP(Symmetric MultiProcessing) machines, spinlock is the fundamental locking mechanism.</li>\\n\\n<li>On a single-processor system, the kernel disables kernel preemption.</li>\\n</ul>\\n\\n<h4 id=\"kernelpreemption\">Kernel Preemption</h4>\\n\\n<ul>\\n<li>A preemptive kernel allows a process to be preempted while it is running in kernel mode.</li>\\n\\n<li>A nonpreemptive kernel lets a process run until it exits kernel mode, blocks, or voluntarily yields control of the CPU.</li>\\n</ul>\\n\\n<h3 id=\"12ossynchronizationexamplesolaris\">12 [OS Synchronization Example] Solaris</h3>\\n\\n<ul>\\n<li>Critical Section Control Options: adaptive mutex locks, condition variables, semaphores, reader-writer locks, and turnstiles.</li>\\n</ul>\\n\\n<h4 id=\"adaptivemutex\">Adaptive Mutex</h4>\\n\\n<ul>\\n<li>It starts as a standard semaphore implemented as a spinlock.</li>\\n\\n<li>If the data are locked\\n\\n\\n<ul>\\n<li>if the lock-holding thread is running on another CPU --> the requesting thread spins.</li>\\n\\n<li>if the lock-holding thread is not running --> the requesting thread blocks (going to sleep until awakened).</li></ul>\\n</li>\\n\\n<li>Adaptive mutex is only used for short code segments (&lt; a few hundred instructions).\\n\\n\\n<ul>\\n<li>If longer than that, condition variables and semaphores are used.</li>\\n\\n<li>Or the spin-waiting method will be exceedingly inefficient.</li></ul>\\n</li>\\n</ul>\\n\\n<h4 id=\"readerwriterlock\">Reader-Writer Lock</h4>\\n\\n<ul>\\n<li>best used for data that are accessed frequently in a read-only manner.</li>\\n\\n<li>efficient because multiple threads can read concurrently(whereas semaphores always serializes access to the data)</li>\\n\\n<li>relatively to implement, so used only on long sections of code.</li>\\n</ul>\\n\\n<h4 id=\"turnstile\">Turnstile</h4>\\n\\n<ul>\\n<li>A turnstile is a queue structure containing threads blocked on a lock.</li>\\n\\n<li>used to order the list of threads waiting to acquire either an adaptive mutex or a reader-writer lock.</li>\\n\\n<li>The kernel maintains a list of free turnstiles.</li>\\n\\n<li>The kernel thread, not the synchronized object, is associated with the turnstile.\\n\\n\\n<ul>\\n<li>This is more efficient than having a turnstile for each object</li>\\n\\n<li>because a thread can be blocked only on one object at a time</li></ul>\\n</li>\\n\\n<li><strong>Priority Inheritance Protocol</strong>\\n\\n\\n<ul>\\n<li>is used to prevent a priority inversion.</li>\\n\\n<li>If a lower-priority thread currently holds a lock on which a higher-priority thread is blocked, the thread with the lower priority wil temporarily inherit the priority of the higher-priority thread.</li></ul>\\n</li>\\n\\n<li>The kernel's locking mechanisms are implemented for user-level threads as well.\\n\\n\\n<ul>\\n<li>so the same type of locks are available inside and outside the kernel.</li>\\n\\n<li>but user-level thread-locking mechanisms do not provide priority inheritance.</li></ul>\\n</li>\\n</ul>\\n\\n<h3 id=\"13userlevelsynchronizationexamplepthreads\">13 [User-Level Synchronization Example] Pthreads</h3>\\n\\n<ul>\\n<li>The synchronization methods discussed above are synchronization within the kernel.</li>\\n\\n<li>The Pthreads API is available for programmers at the user level and it is not part of any particular kernel.</li>\\n\\n<li>Mechanisms provided: mutex locks, condition variables, read-write locks.</li>\\n</ul>\\n\\n<h4 id=\"mutexlocks-1\">Mutex Locks</h4>\\n\\n<ul>\\n<li><p>the fundamental synchronization technique used with Pthreads.</p></li>\\n\\n<li><p><code>pthread_mutex_t</code>: data type for mutex locks.</p></li>\\n\\n<li><p>example:</p>\\n\\n<pre><code class=\"c language-c\">#include &lt;pthread.h&gt;\\n\\npthread_mutex_t mutex;\\n\\n// Create the mutex lock.\\n// Initialized the mutex to its default attributes.\\npthread_mutex_init(&amp;mutex, NULL);\\n\\n\\n// protecting a critical section with mutex locks:\\n\\npthread_mutex_lock(&amp;mutex);\\n\\n// critical section\\n\\npthread_mutex_unlock(&amp;mutex);\\n</code></pre></li>\\n\\n<li><p>Many systems that implement Pthreads also provide semaphores, which belong to the POSIX SEM extension.</p>\\n\\n<p><ul>\\n<li>Two types of semaphores specified by POSIX: named and unnamed.</li></p>\\n\\n<p><li>A <strong>named semaphores</strong> has an actual name in the file system and can be shared by multiple urelated processes.</li></p>\\n\\n<p><li>An <strong>unnamed semaphores</strong> can be used only by threads of the same process.</li></ul>\\n\\n<p></p></li></p>\\n\\n<p><li><p>All mutex and semaphores functions return 0 with correct operation.</p></li></p>\\n\\n<p><li><p>Other extensions to the Pthreads API are available, including spinlocks.</p></p>\\n\\n<p><ul>\\n<li>But not all extensions are considered portable from one implementation to another.</li></ul></p>\\n\\n<p></li>\\n</ul></p>",
        "status": 1,
        "description": "a seriously digested note on process synchronization",
        "created_at": "2019-04-21T10:10:52.652219",
        "updated_at": "2019-05-15T12:31:11.341967",
        "slug": "operating-system-process-synchronization",
        "medium_url": ""
    },
    {
        "id": 39,
        "title": "[Database] Transaction and Concurrency Control",
        "body": "<p></p>\\n<p><a href=\"https://jennycodes.me/posts/operating-system-process-synchronization\" data-href=\"https://jennycodes.me/posts/operating-system-process-synchronization\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">A while ago</a> we were introduced to process synchronization in operating systems. Today let us look at the concurrency control in database management systems. We often find ourselves producing errors more speedily when we try to juggle multiple things at once, or when we try to work with others on the same task without adequate communications. It happens that computers are just like us. Disasters come if we try to enjoy (exploit) their powerful resources without thinking carefully how to orchestrate them that guarantees no conflicts.</p>\\n<p>As a powerful and considerate framework, Rails of course has built-in methods that let us handle our model objects (which are linked to database objects) with more ease. The built-in <code class=\"markup--code markup--p-code\">transaction</code> method provided by <a href=\"https://github.com/rails/rails/tree/master/activerecord\" data-href=\"https://github.com/rails/rails/tree/master/activerecord\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">ActiveRecord</a>, for example, escorts our data’s integrity through a series of operations. For example:</p>\\n<pre><code class=\"markup--code markup--pre-code u-paddingRight0 u-marginRight0\">ActiveRecord::Base.transaction <strong class=\"markup--strong markup--pre-strong\">do</strong><br>  A.withdraw(300)<br>  B.deposit(300)<br><strong class=\"markup--strong markup--pre-strong\">end</strong></code></pre>\\n<p>Wrapping the operations in the transaction block guarantees if something unfortunately goes wrong, the worst case scenario would be a <strong class=\"markup--strong markup--p-strong\">rollback</strong>–undo all already-processed operations in the transaction, and the records in the database will keep their original states like nothing ever happened.</p>\\n<p>This example demonstrates a transfer event: this is what goes behind the curtain when A is transferring $300 to B. If for some reason the connection breaks in the middle of the transaction, say when<code class=\"markup--code markup--p-code\">A.withdraw(300)</code> is done but not yet <code class=\"markup--code markup--p-code\">B.deposit(300)</code>, then when exiting the transaction block <code class=\"markup--code markup--p-code\">A.withdraw(300)</code> will be undone.</p>\\n<p>A brief note on the usage of this <code class=\"markup--code markup--p-code\">transaction</code> method: we can actually use it on various objects, not necessarily as an ActiveRecord class method. I’ll leave a <a href=\"https://api.rubyonrails.org/classes/ActiveRecord/Transactions/ClassMethods.html\" data-href=\"https://api.rubyonrails.org/classes/ActiveRecord/Transactions/ClassMethods.html\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">reference</a> here so we can enjoy all the detailed usage in our own time.</p>\\n<p>But diligent as we are, knowing how to properly call a method clearly cannot satisfy us. How is this apparently highly abstracted function implemented? To answer that, let us first understand how transactions work in the database level.</p>\\n<h3>Concurrency Control: An Overview</h3>\\n<p>In the context of database systems, a <strong class=\"markup--strong markup--p-strong\">transaction</strong> is a set of database operations induced by a single user or application that should be considered as one undividable unit of work. For a database management system to have a valid transaction mechanism, it is important that it has the <a href=\"https://en.wikipedia.org/wiki/ACID_%28computer_science%29\" data-href=\"https://en.wikipedia.org/wiki/ACID_(computer_science)\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">ACID (Atomicity, Consistency, Isolation, Durability)</a> properties.</p>\\n<p>A <strong class=\"markup--strong markup--p-strong\">transaction manager</strong> in the database management system takes responsibility for coordinating transaction executions. When new, to-be-executed transactions come, the transaction manager will put them in a <strong class=\"markup--strong markup--p-strong\">scheduler</strong>.</p>\\n<h4>Serial Schedule and Serializable Schedule</h4>\\n<p>There are two types of a scheduler, <strong class=\"markup--strong markup--p-strong\">serial schedule</strong> and <strong class=\"markup--strong markup--p-strong\">serializable schedule. </strong>Yes, they do seem like synonyms but are in fact more like antonyms.</p>\\n<p>In a serial schedule, all statements of the same transaction are executed consecutively, without any interleave with statements from a different transaction.</p>\\n<p>On the other hand, serializable schedules have two characteristics: (1) they are non-serial schedules, which allow concurrent executions of different transactions (2) they still produce correct results.</p>\\n<h4>The Goal</h4>\\n<p>With a serial schedule, the ACID properties can be easily achieved. However, in our current world where <a href=\"https://medium.com/from-the-scratch/dont-be-confused-between-concurrency-and-parallelism-eac8e703943a\" data-href=\"https://medium.com/from-the-scratch/dont-be-confused-between-concurrency-and-parallelism-eac8e703943a\" class=\"markup--anchor markup--p-anchor\" target=\"_blank\">parallelism and concurrency</a> is the norm, using a serial schedule would seriously under-exploit the potential these hardware technologies provide.</p>\\n<p>So we aim at serializable schedules, which have the integrity of a serial schedule as well as the advantage of efficiency.</p>\\n<p>The study of<strong class=\"markup--strong markup--p-strong\"> concurrency control, </strong>then, is to coordinate transactions that execute simultaneously in a way that guarantees these transactions do not cause any data inconsistencies from mutual interference.</p>\\n<h3>Typical Concurrency Problems</h3>\\n<p>Any design in the field of concurrency control would be tested against these five typical interference problems:</p>\\n<ol>\\n<li name=\"9770\" id=\"9770\" class=\"graf graf--li graf-after--p\">The Lost Update Problem</li>\\n<li name=\"fd52\" id=\"fd52\" class=\"graf graf--li graf-after--li\">The Uncommitted Dependency Problem</li>\\n<li name=\"eb47\" id=\"eb47\" class=\"graf graf--li graf-after--li\">The Inconsistent Analysis Problem</li>\\n<li name=\"2f15\" id=\"2f15\" class=\"graf graf--li graf-after--li\">Non-repeatable Read</li>\\n<li name=\"fa64\" id=\"fa64\" class=\"graf graf--li graf-after--li\">Phantom Read</li>\\n</ol>\\n<p>Let us look at them one by one.</p>\\n<h4>Lost Update Problem</h4>\\n<p>happens when two transactions access and update the same data simultaneously, and the result of one is overwritten by another. For example, both transaction T1 and T2 is adding 3 to a variable x, whose original value is 0. The operations in both transactions are as follows:</p>\\n<ol>\\n<li name=\"637b\" id=\"637b\" class=\"graf graf--li graf-after--p\">Read the value of x.</li>\\n<li name=\"0e6c\" id=\"0e6c\" class=\"graf graf--li graf-after--li\">Add 3 to the value.</li>\\n<li name=\"c291\" id=\"c291\" class=\"graf graf--li graf-after--li\">Assign it back to x.</li>\\n</ol>\\n<p>Now, in a concurrent environment, what might happen is T1 and T2 read the value of x, which is 0, at the same time. They both add 3 to that value and return. When all operations are done, our x now has the value 3, when it should have been 6.</p>\\n<p>This problem results in an inconsistent database state.</p>\\n<h4>Uncommitted Dependency Problem (Dirty Read Problem)</h4>\\n<p>Suppose today we have a data that is being updated and eventually rolled back in a transaction. A <strong class=\"markup--strong markup--p-strong\">dirty read</strong> occurs when another transaction, running concurrently, reads that data at the exact point when it is updated but not yet rolled back.</p>\\n<p>This problem results in either an inconsistent database or incorrect query result, depending on what of that dirty-reading transaction is.</p>\\n<h4>Inconsistent Analysis Problem</h4>\\n<p>Inconsistent analysis happens when a transaction reads a data which another transaction is still updating. It is almost the same problem with lost update, except that the final database state is actually consistent, because that other transaction does not modify the data. Nevertheless, the query result is still incorrect.</p>\\n<h4>Non-repeatable Read</h4>\\n<p>Non-repeatable read occurs when a transaction reads the same row multiple times but obtains different subsequent values, because another transaction is updating the row at the same time.</p>\\n<h4>Phantom Read</h4>\\n<p>Phantom read is a problem when a transaction is executing <code class=\"markup--code markup--p-code\">insert</code> or <code class=\"markup--code markup--p-code\">delete</code> operations on <em class=\"markup--em markup--p-em\">a set of rows</em> that are being read by another transaction.</p>\\n<p>In the following sections, we will discuss how the different solutions respond to these problems.</p>\\n<h3>Locking: Techniques in Practice</h3>\\n<p>To protect the integrity of data during transaction, <a href=\"https://en.wikipedia.org/wiki/Record_locking\" data-href=\"https://en.wikipedia.org/wiki/Record_locking\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">locking</a> is a popular strategy. Since concurrency is really a big, as well as inevitable, deal, you can see pretty much the same struggle and similar responses across different areas of computer science, for example <a href=\"https://jennycodes.me/posts/operating-system-the-dining-philosophers-problem\" data-href=\"https://jennycodes.me/posts/operating-system-the-dining-philosophers-problem\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">The Dining Philosophers Problem</a>.</p>\\n<p>The basic concept of locking is this: when an operation attempts to access a database object, it would first have to acquire a lock on that object. If currently the lock is unavailable, the operation waits until it gets the lock. Then the operation can be executed with safety and everybody is happy.</p>\\n<p>In the case of database transaction, we use two types of locks: <strong class=\"markup--strong markup--p-strong\">exclusive locks</strong> and <strong class=\"markup--strong markup--p-strong\">shared locks</strong>.</p>\\n<h4>Exclusive Locks (x-locks; write-locks)</h4>\\n<p>An <strong class=\"markup--strong markup--p-strong\">exclusive lock</strong> is also called a <strong class=\"markup--strong markup--p-strong\">x-lock</strong> or a <strong class=\"markup--strong markup--p-strong\">write-lock</strong>. If a transaction acquires an exclusive lock, that transaction has the sole privilege to interact with that specific database object until it releases the lock.</p>\\n<h4>Shared Locks (s-locks; read-locks)</h4>\\n<p>A shared lock, also called a s-lock or a read-lock, guarantees that no other transactions will <strong class=\"markup--strong markup--p-strong\">update</strong> the same database object for as long as the lock is held, but others transactions are still allowed to <strong class=\"markup--strong markup--p-strong\">read</strong> from the object.</p><h4>Jobs of a Locking Manager</h4>\\n<p>When we invoke a transaction, the database management system will implicitly handle the request and release processes on behalf of the transaction. In these requests, read operations will induce s-locks and write operations will induce x-locks. A commit or rollback releases the lock.</p>\\n<p>The roles involved in implicit locking are the <strong class=\"markup--strong markup--p-strong\">transaction manager </strong>(introduced above) and the <strong class=\"markup--strong markup--p-strong\">locking manager</strong>. The locking manager interacts with the transaction manager and has the following responsibilities:</p>\\n<ul>\\n<li name=\"433f\" id=\"433f\" class=\"graf graf--li graf-after--p\">implementation of a <em class=\"markup--em markup--li-em\">locking protocol</em>\\n</li>\\n<li name=\"0662\" id=\"0662\" class=\"graf graf--li graf-after--li\">management of a <em class=\"markup--em markup--li-em\">lock table</em>, which contains information about which locks are currently held by which transaction, which transactions are waiting to acquire certain locks, etc</li>\\n<li name=\"c80b\" id=\"c80b\" class=\"graf graf--li graf-after--li\">avoiding <em class=\"markup--em markup--li-em\">starvation</em>, where some transactions wait endlessly for the required exclusive locks</li>\\n</ul>\\n<h3>The Two-Phase Locking Protocol (2PL)</h3>\\n<p>A locking protocol is a set of rules that determine what locks can be granted in what situation. The <strong class=\"markup--strong markup--p-strong\">two-phase locking protocol</strong>, a.k.a 2PL, is one of the most well-known locking protocol in a standalone database context. Its rules are as follows:</p>\\n<ol>\\n<li name=\"6870\" id=\"6870\" class=\"graf graf--li graf-after--p\">Before a transaction can read a database object, it should acquire a shared lock on that object.</li>\\n<li name=\"2ec8\" id=\"2ec8\" class=\"graf graf--li graf-after--li\">The lock manager determines whether requested locks do not cause any conflicts and can be granted, based on the <em class=\"markup--em markup--li-em\">compatibility matrix</em>. Transactions whose locking requests cannot be granted are put on hold until the request can be granted.</li>\\n<li name=\"93fb\" id=\"93fb\" class=\"graf graf--li graf-after--li\">For each transaction, acquiring and releasing locks occurs in two phases: the <strong class=\"markup--strong markup--li-strong\">growth phase</strong> and the <strong class=\"markup--strong markup--li-strong\">shrink phase</strong>. In the growth phase, new locks can be acquired but no locks can be released. In the shrink phase, locks are gradually released, and no additional locks can be acquired.</li>\\n</ol>\\n<p>These are the general concepts, but there are several variants that differ in when exactly to move to the next phase.</p>\\n<h4>Variants of the 2PL</h4>\\n<ul>\\n<li name=\"4109\" id=\"4109\" class=\"graf graf--li graf-after--h4\">\\n<strong class=\"markup--strong markup--li-strong\">Basic 2PL</strong>: A transaction can enter the shrink phase before it has attained the “committed” state. With basic 2PL, the lost update problem is successfully solved, but the uncommitted dependency problem still exists, which would invoke <em class=\"markup--em markup--li-em\">cascading rollbacks</em>.</li>\\n<li name=\"fca8\" id=\"fca8\" class=\"graf graf--li graf-after--li\">\\n<strong class=\"markup--strong markup--li-strong\">Static 2PL (conservative 2PL)</strong>: A transaction acquires all its locks right at the start of the transaction. Since it is not always possible to predict which locks will be required, the transaction would grab all the locks that <em class=\"markup--em markup--li-em\">may</em> be needed.</li>\\n<li name=\"4c57\" id=\"4c57\" class=\"graf graf--li graf-after--li\">\\n<strong class=\"markup--strong markup--li-strong\">Rigorous 2PL</strong>: The transaction holds all its locks until committed.</li>\\n</ul>\\n<p>Although the 2PL provides a fairly robust locking guideline, we cannot neglect its negative impact on transaction throughput, because the level of transaction isolation offered by 2PL is quite stringent. To optimize the efficiency, let us first try to understand different isolation levels. Afterwards, we will look at the concept of <strong class=\"markup--strong markup--p-strong\">lock granularity</strong> and the <strong class=\"markup--strong markup--p-strong\">Multiple Granularity Locking Protocol</strong> (the MGL protocol).</p>\\n<h3>Isolation Levels</h3>\\n<p>Most Database Management Systems allow different isolation levels, most commonly <strong class=\"markup--strong markup--p-strong\">read uncommitted</strong>, <strong class=\"markup--strong markup--p-strong\">read committed</strong>, <strong class=\"markup--strong markup--p-strong\">repeatable read</strong>, and <strong class=\"markup--strong markup--p-strong\">serializable</strong>.</p>\\n<ol>\\n<li name=\"ed12\" id=\"ed12\" class=\"graf graf--li graf-after--p\">\\n<strong class=\"markup--strong markup--li-strong\">Read Uncommitted</strong>: The lowest isolation level. It just happily assumes concurrency conflicts do no occur or have no impact whatsoever. This level is only safe for read-only transactions.</li>\\n<li name=\"25e0\" id=\"25e0\" class=\"graf graf--li graf-after--li\">\\n<strong class=\"markup--strong markup--li-strong\">Read Committed</strong>: It uses long-term (transaction level) write locks + short-term (operation level) read locks, and guarantees that no transactions can read any data that are still being updated by another yet-uncommitted transaction. It resolves the lost update and the uncommitted dependency problem, but would fail the test of inconsistent analysis problem, non-repeatable reads and phantom reads.</li>\\n<li name=\"fb8c\" id=\"fb8c\" class=\"graf graf--li graf-after--li\">\\n<strong class=\"markup--strong markup--li-strong\">Repeatable Read</strong>: It uses long-term locks for both write and read, offering solutions to all problems except phantom reads.</li>\\n<li name=\"dd76\" id=\"dd76\" class=\"graf graf--li graf-after--li\">\\n<strong class=\"markup--strong markup--li-strong\">Serializable</strong>: The strongest isolation level. It roughly corresponds to an implementation of 2PL.</li>\\n</ol>\\n<h3>Lock Granularity</h3>\\n<p>Supposedly we can put a lock on any database objects, which can be a tuple, a column, a table, a table space or a disk block. On the one hand, locking at a fine-grained level (e.g., an individual tuple) has the least negative impact on throughput. On the other hand, if many tuples are involved in the transaction, locking each individual tuple causes a huge overhead.</p>\\n<p>To guarantee an optimized lock granularity for transactions, many database management systems now implement the <a href=\"https://en.wikipedia.org/wiki/Multiple_granularity_locking\" data-href=\"https://en.wikipedia.org/wiki/Multiple_granularity_locking\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\"><strong class=\"markup--strong markup--p-strong\">Multiple Granularity Locking (MGL) Protocol</strong></a>.</p>\\n<h4>Multiple Granularity Locking Protocol</h4>\\n<p>The purpose of this protocol is to guarantee serializability when locks can be placed at multiple granularity levels. It ensures that if two (or more) database objects are interrelated hierarchically, the respective transactions that acquired locks on these objects cannot conflict with one another.</p>\\n<p>Before introducing its rules, there are some additional types of locks (besides x-locks and s-locks) that needs our attention. They are</p>\\n<ul>\\n<li name=\"8a7d\" id=\"8a7d\" class=\"graf graf--li graf-after--p\">\\n<strong class=\"markup--strong markup--li-strong\">Intention Shared Lock (is-lock)</strong>: only conflicts with x-locks</li>\\n<li name=\"117a\" id=\"117a\" class=\"graf graf--li graf-after--li\">\\n<strong class=\"markup--strong markup--li-strong\">Intention Exclusive Lock (ix-lock)</strong>: conflicts with both x-locks and s-locks</li>\\n<li name=\"2caf\" id=\"2caf\" class=\"graf graf--li graf-after--li\">\\n<strong class=\"markup--strong markup--li-strong\">Shared and Intention Exclusive Lock (six-lock)</strong>: conflicts with all except is-lock</li>\\n</ul>\\n<p>This is how the game is played: an intention lock is placed on all coarser-grained objects encompassing x, to ensure that locks are held (or granted later) on coarser-grained database objects that (1) encompass object x (2) may conflict with the lock type requested on x.</p>\\n<h4>Rules of the MGL Protocol</h4>\\n<ol>\\n<li name=\"66e5\" id=\"66e5\" class=\"graf graf--li graf-after--h4\">All compatibilities are respected as represented in the compatibilities matrix.</li>\\n<li name=\"e8f4\" id=\"e8f4\" class=\"graf graf--li graf-after--li\">An initial lock should be placed on the root of the hierarchy.</li>\\n<li name=\"1077\" id=\"1077\" class=\"graf graf--li graf-after--li\">Before a transaction Ti can acquire an s-lock or an is-lock on an object x, it should acquire an is-lock or an ix-lock on the parent of x.</li>\\n<li name=\"7575\" id=\"7575\" class=\"graf graf--li graf-after--li\">Before Ti can acquire an x-lock, six-lock, or an ix-lock on an object x, it should acquire an ix-lock or a six-lock on the parent of x.</li>\\n<li name=\"7a2f\" id=\"7a2f\" class=\"graf graf--li graf-after--li\">Ti can only acquire additional locks if it hasn’t released any locks yet (cf. 2PL).</li>\\n<li name=\"d746\" id=\"d746\" class=\"graf graf--li graf-after--li\">Before Ti can release a lock on x, it should have released all locks on all children of x.</li>\\n</ol>\\n<p>Right. If we don’t really know what just happened, take this home: the MGL protocol introduces the concept of intentional locks, and all the locks are acquired top-down, but released bottom-up in the hierarchy. This maximizes the transaction efficiency while still ensuring integrity of the database objects involved.</p>\\n<p>That’s it. The concurrency and locking problems are really a mesmerizing topic to be delightfully overwhelmed, isn’t it!</p><p>文章同步發表於 <a href=\"https://medium.com/@jinghua.shih\">Medium</a>。",
        "status": 1,
        "description": "concurrency control in database",
        "created_at": "2019-05-15T12:15:27.952191",
        "updated_at": "2019-05-15T12:15:27.952191",
        "slug": "database-transaction-and-concurrency-control",
        "medium_url": "https://medium.com/@jinghua.shih/database-transaction-and-concurrency-control-abb7fd16c507"
    },
    {
        "id": 82,
        "title": "[Performance Optimization] Writing Better Ruby Tests for SQL Queries",
        "body": "<p>The second episode of PicCollage's server performance optimization journey! After finding a way to <a href=\"https://jennycodes.me/posts/performance-speedup-customizing-graphql-tracing-on-newrelic\">instrument NewRelic so that requests coming from GraphQL are separated by query</a>, we are now able to see the performance details by query, and identify any elements that are doing more harm than good. Quickly enough, there's this particular query that stood out for us, because it triggers 26 trips to cache store everytime a request is sent for it.</p>\\r\\n\\r\\n<p>26 trips to cache store for one request-that's a lot. The fact that it's to fetch the caches (as opposed to making database queries) still doesn't justify it. Our mission, then, is to <strong>reduce those 26 cache queries down to 1, while making sure we are still caching all the database queries and heavy calculations</strong>.</p>\\r\\n<h3 id=\"inspecting-database-queries\">Inspecting Database Queries</h3>\\r\\n<p>But this article is not about how we refactored our code to allow a better caching strategy at the top level of GraphQL (that'd be in another article), but something that's just as important as how we did it. That is, how we <em>test</em> it. </p>\\r\\n\\r\\n<p>How do we make sure a chunk of our code triggers the right amount of queries to database and/or cache store? Especially with the convenience of <a href=\"https://en.wikipedia.org/wiki/Object-relational_mapping\">ORM (Object-Relational Mapping)</a>, it's easy to lose count of the actual queries we make to the database with our code (see the famous and semi-related <a href=\"https://www.sitepoint.com/silver-bullet-n1-problem/\">n+1 queries problem</a>). </p>\\r\\n\\r\\n<p>In short, the database queries we are actually sending do not have a one-to-one relationship with the lines of code we write with our Active Record objects. To fetch the query count, therefore, we need to assert against something other than the times we invoke <code>SomeModel.find(some_id)</code> or <code>SomeModel.where(some_condition)</code>. We need to find a way to assert against something more precise.</p>\\r\\n<h3 id=\"the-instrumentation-api\">The Instrumentation API</h3>\\r\\n<p>As it turns out, <a href=\"https://github.com/rails/rails/tree/master/activesupport\">Active Support</a>, one of the core libraries that Rails depends on, has this nice thing called <a href=\"https://edgeguides.rubyonrails.org/active_support_instrumentation.html\"><strong>Instrumentation</strong></a>. This instrumentation API enables us to create <em>hooks</em> (events) and measure those hooks by subscription. The hooks can be certain actions inside an application or another piece of Ruby code. </p>\\r\\n\\r\\n<p>As a thoughtful framework as it is, <a href=\"https://edgeguides.rubyonrails.org/active_support_instrumentation.html#rails-framework-hooks\">Rails provides several hooks</a> already by default, including <a href=\"https://edgeguides.rubyonrails.org/active_support_instrumentation.html#sql-active-record\">sql queries</a> and <a href=\"https://edgeguides.rubyonrails.org/active_support_instrumentation.html#cache-read-active-support\">cache read events</a>. What does that mean? We can leverage this existing API to build our own database/cache query counter!</p>\\r\\n<h3 id=\"our-database-cache-query-counter\">Our Database/Cache Query Counter</h3>\\r\\n<p>I'm not going to dive into the details of Instrumentation API details here because the documentation already explains it quite well. If not, the code snippet below will do the explanation.</p>\\r\\n\\r\\n<script src=\"https://gist.github.com/jenny-codes/f641fcb4529a5c5b0a75113d8da24de0.js\"></script>\\r\\n\\r\\n<p>The class <code>TestHelper</code> has two test helper methods: <code>assert_db_queries</code> and <code>assert_cache_queries</code>. The logic translate as follows:</p>\\r\\n\\r\\n<p>For <code>assert_db_queries</code>, we subscribe to the event <code>'sql.active_record'</code>, and provide the API with two other arguments: what to do when this event happen (callback), and within what scope this event should be looked out for. The first argument is our <code>counter_f</code> lambda, inside which we collect both the query names (<code>queries</code>) and the actual hits (<code>actual_hits</code>). The second argument is our test code, example of which is in the <code>ExampleTest</code> class. At the end, we assert that the actual hits equal to our expected hits (also provided when invoking the method).</p>\\r\\n\\r\\n<p><code>assert_cache_queries</code> is pretty much the same as <code>assert_db_queries</code>, only differing in the event name (<code>'cache_read.active_support'</code>) and the keys in the payload.</p>\\r\\n\\r\\n<p>A refresher on <a href=\"https://www.rubydoc.info/gems/minitest/Minitest%2FAssertions:assert_equal\">Rails testing API</a>: the third argument in <code>assert_equal</code> method is the custom error message that will be printed if the assertion fails. Here we provide it with the actual queries sent. Super helpful. Strongly recommended.</p>\\r\\n\\r\\n<p>Also, the two methods are designed as such that you can pass in an additional <code>debug: true</code> option to always print out the actual queries regardless of the result of assertion.</p>\\r\\n<h3 id=\"that-39-s-it\">That's it</h3>\\r\\n<p>These two setups turned out to be a great help in our effort to get a clearer picture of our application's interaction with the database and cache store. One step forward in our performance optimization journey!</p>\\r\\n\\r\\n<p>Of course, wrapping them into test methods is just one example of how we can take advantage of Instrumentation API. Tweak it however you want. Happy exploring!</p>\\r\\n<h3 id=\"acknowledgement\">Acknowledgement</h3>\\r\\n<p>The credit for discovering this useful mechanism goes to Jaime. Thank you Jaime for writing the initial version 7 years ago :)</p>\\r\\n<h3 id=\"references\">References</h3>\\r\\n<ul>\\r\\n<li><a href=\"http://api.rubyonrails.org/classes/ActiveSupport/Notifications.html\">http://api.rubyonrails.org/classes/ActiveSupport/Notifications.html</a></li>\\r\\n<li><a href=\"https://edgeguides.rubyonrails.org/active_support_instrumentation.html\">https://edgeguides.rubyonrails.org/active_support_instrumentation.html</a></li>\\r\\n<li><a href=\"http://stackoverflow.com/questions/5490411/counting-the-number-of-queries-performed\">http://stackoverflow.com/questions/5490411/counting-the-number-of-queries-performed</a></li>\\r\\n</ul>\\r\\n",
        "status": 1,
        "description": "with Active Support Instrumentation",
        "created_at": "2020-03-09T00:30:46.263509",
        "updated_at": "2020-03-09T00:53:11.333066",
        "slug": "performance-optimization-writing-better-ruby-tests-for-sql-queries",
        "medium_url": ""
    },
    {
        "id": 30,
        "title": "[筆記] Threads in Ruby (2)",
        "body": "<p></p>\\n<p>上一篇說到 Ruby MRI 的 GIL (Global Interpreter Lock) 特性讓 Ruby 是 single-threaded，這篇來講 Ruby on Rails 中 threads 的狀況。</p>\\n<h3>進一步檢視 GIL 的運作</h3>\\n<p>雖然 GIL 讓 Ruby 的平行作業（parallelism）變得有點困難，它其實並沒有完全阻止。GIl 存在的目的是保護 interpreter 的內在狀態，所以它只適用於 Ruby 的運算。舉例來說，I/O 操作就不會被 GIL 阻擋，像是 Ruby 的 PostgreSQL library 是用 C 語言寫的，所以呼叫資料庫操作的時候就會釋放 GIL。</p>\\n<p>猜猜下面程式碼會幾秒跑完？</p>\\n<figure class=\"text-center\"><script src=\"https://gist.github.com/jenny-codes/7d6b6fb335a61d8bb67aa71211bded8e.js\"></script><figcaption class=\"imageCaption\"><a href=\"https://gist.github.com/jenny-codes/7d6b6fb335a61d8bb67aa71211bded8e\" data-href=\"https://gist.github.com/7d6b6fb335a61d8bb67aa71211bded8e.git\" class=\"markup--anchor markup--figure-anchor\" rel=\"nofollow noopener\" target=\"_blank\">https://gist.github.com/7d6b6fb335a61d8bb67aa71211bded8e.git</a></figcaption></figure><p>答案是一秒！也就表示，資料庫操作的時候 parallelism 是可以發生的。但這同時表示，我們會失去 GIL 對於 context switch 的保護。</p>\\n<h3>(Check-and-Act) Race Condition</h3>\\n<p>一個 GIL 無法防止的經典狀況是 <a href=\"https://en.wikipedia.org/wiki/Race_condition\" data-href=\"https://en.wikipedia.org/wiki/Race_condition\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">Race Condition</a>。Ruby 的 thread scheduling 演算法可以在任意時間切換不同的 thread，所以無法保證它存取資料的順序。比如說今天同時開了兩個 thread (T1 &amp; T2)，都是先確認一個 <code class=\"markup--code markup--p-code\">money_is_sent</code> 的變值是否為真，是的話就結束，否的話就執行 <code class=\"markup--code markup--p-code\">send_money</code> 函式，然後把 <code class=\"markup--code markup--p-code\">money_is_sent</code> 設為真。有可能發生的情況是，程式在執行到 T1 的 send_money 之後，發生了 context switch，換到 T2，這時候 <code class=\"markup--code markup--p-code\">money_is_sent</code> 還沒被更新，所以 <code class=\"markup--code markup--p-code\">send_money</code> 會再被執行一次。多給一次錢，這不是我們想要發生的狀況，是吧？</p>\\n<p>解法是 <a href=\"https://ruby-doc.org/core-2.5.0/Mutex.html\" data-href=\"https://ruby-doc.org/core-2.5.0/Mutex.html\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">Mutex (Mutual Exclusion)</a>。</p>\\n<h3>Mutual Exclusion</h3>\\n<p>Mutex 就像是自己設計的 GIL，保護自己的程式碼區塊。只要定義一個<code class=\"markup--code markup--p-code\">Mutex</code> 然後呼叫 <code class=\"markup--code markup--p-code\">synchronize</code> 方法就可以確保一個區塊的完整程式碼被執行完控制權才會被釋放。</p>\\n<figure class=\"text-center\"><script src=\"https://gist.github.com/jenny-codes/2e3147cd595badab6a16a0067ec822d5.js\"></script><figcaption class=\"imageCaption\"><a href=\"https://gist.github.com/jenny-codes/2e3147cd595badab6a16a0067ec822d5\" data-href=\"https://gist.github.com/jenny-codes/2e3147cd595badab6a16a0067ec822d5\" class=\"markup--anchor markup--figure-anchor\" rel=\"nofollow noopener\" target=\"_blank\">https://gist.github.com/jenny-codes/2e3147cd595badab6a16a0067ec822d5</a></figcaption></figure><p>如此一來就可以避免 involuntary context switch 的情況發生。</p>\\n<p>值得注意的是，想要防止干擾的程式碼要放在同一個 Mutex object 中（用同一個 Mutex object 的 synchronize 方法來管理），如果不同的區段使用不同的 lock，那就沒有用了。</p>\\n<h3>Happy ever after, then?</h3>\\n<p>有了 Mutex 我們就可以放心 multithread 了嗎？當然不。下一篇來介紹 deadlock（還有它的解法）。</p><p>雖然已盡能力所及地確保資料的正確性，但我恐怕還是會有不對/不精確的觀念或用字，如果願意<a href=\"https://jennycodes.herokuapp.com/contact\" data-href=\"https://jennycodes.herokuapp.com/contact\" class=\"markup--anchor markup--p-anchor\" rel=\"noopener nofollow nofollow noopener nofollow noopener nofollow noopener nofollow noopener nofollow noopener\" target=\"_blank\">指正我</a>的話我會非常感激！</p>\\n<h4>References</h4>\\n<div>\\n<a href=\"https://dev.to/enether/working-with-multithreaded-ruby-part-i-cj3\" data-href=\"https://dev.to/enether/working-with-multithreaded-ruby-part-i-cj3\" class=\"markup--anchor markup--mixtapeEmbed-anchor\" title=\"https://dev.to/enether/working-with-multithreaded-ruby-part-i-cj3\" rel=\"nofollow\"><strong class=\"markup--strong markup--mixtapeEmbed-strong\">Working with Multithreaded Ruby Part I</strong><br>dev.to</a><a href=\"https://dev.to/enether/working-with-multithreaded-ruby-part-i-cj3\" class=\"js-mixtapeImage mixtapeImage u-ignoreBlock\" data-media-id=\"de1f2ce49721cce99751c27aa644addc\" data-thumbnail-img-id=\"0*4jgmx4I1IdZAN9Yj\" style=\"background-image: url(https://cdn-images-1.medium.com/fit/c/320/320/0*4jgmx4I1IdZAN9Yj);\"></a>\\n</div><p>文章同步發表於 <a href=\"https://medium.com/@jinghua.shih\">Medium</a>。",
        "status": 1,
        "description": "Mutex",
        "created_at": "2019-03-05T13:42:30.48766",
        "updated_at": "2020-02-02T05:19:30.311282",
        "slug": "筆記-threads-in-ruby-2",
        "medium_url": "https://medium.com/@jinghua.shih/%E7%AD%86%E8%A8%98-threads-in-ruby-2-1ce404485a4e"
    },
    {
        "id": 32,
        "title": "GraphQL in Ruby on Rails",
        "body": "<p></p>\\n<blockquote>GraphQL is a query language for your API, and a server-side runtime for executing queries by using a type system you define for your data.</blockquote>\\n<p>（節錄自 <a href=\"https://graphql.org/learn/\" data-href=\"https://graphql.org/learn/\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">GraphQL</a>）。</p>\\n<p>GraphQL 是一種新型態的 API（<a href=\"https://en.wikipedia.org/wiki/Application_programming_interface\" data-href=\"https://en.wikipedia.org/wiki/Application_programming_interface\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">Application Programming Interface</a>） 查詢方式，是 Facebook 在 2012 年開始使用，2015 年推出的。時至今日，已經有越來越多<a href=\"https://graphql.org/users/\" data-href=\"https://graphql.org/users/\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">厲害公司</a>使用它，是個當紅寵兒來著。那在 GraphQL 出現以前大家都是怎麼度過每一天的呢？GraqhQL 到底改變了什麼？</p>\\n<p>GraphQL 顛覆/改進的是 REST（REsourceful State Transfer）架構。REST 是以往主流的資料傳輸規範。其實 GraphQL 也算是基於 REST 架構改良而成，所以如果要暸解 GraphQL，先把 REST 弄懂絕對值回票價！而暸解了 REST 之後就更能夠體會 GraphQL 之所以強大的原因了。</p>\\n<p>由於 GraphQL 的服務可以被任意語言使用，這篇文章的例子會用 Ruby 來實作，並且介紹 GraphQL 在 Ruby on Rails 中的應用。</p>\\n<p>我們先直接從例子來看看 GraphQL 與 REST 這兩者的不同。</p>\\n<h3>Resources</h3>\\n<p>Resource 是 REST 中很重要的觀念。每一個 Resource 都會有個 Identifier (通常就是 URL)，我們利用這個 Identifier 加上一個動作（比如說 <code class=\"markup--code markup--p-code\">GET</code> 或是 <code class=\"markup--code markup--p-code\">POST</code>）來操作 Resource。</p>\\n<p>假設今天我們想要拿到一個 user 的資料，使用 REST 可能會是以下的情況：</p>\\n<pre># REST QUERY<br>GET /user/1    # retrieve user data where user id is 1</pre>\\n<pre># REST RESPONSE (IN JSON)<br>{<br>  \"username\": \"jennycodes\",<br>  \"website\": {<br>    \"url\": \"https://jennycodes.me\",<br>    \"quality\": \"quite high\"<br>  }<br>  \"phone\": \"...\"<br>  ...(omitted)<br>}</pre>\\n<p>當我們呼叫了 <code class=\"markup--code markup--p-code\">GET /user/1</code>，我們得到一組預先被定義好的資料，通常會稱呼它 <code class=\"markup--code markup--p-code\">the user endpoint</code>。用去餐廳吃飯做比較，REST 就是提供套餐（事先規劃好的 API endpoint），顧客只能選擇要哪個套餐（我要第幾個 User 的資料），並且一次只能選擇一個，想要一次點兩種套餐（一次 query 中請求多個資源）？不行。而且選好之後你就是拿到一組固定的東西，如果我今天只想吃單純的一盤蛋炒飯，我只能點蛋炒飯套餐再自己把小菜跟飲料去掉。今天我想吃蛋炒飯＋紅蘿蔔蛋炒飯，我只能分兩次點，而且還是只能點套餐。今天我只想知道 User 1 的 username 跟 website quality，我就要自己從拿回來的這一包 response 自己去把資訊挑出來。</p>\\n<p>如果是 GraphQL，則會長這樣：</p>\\n<pre># GraphQL QUERY<br>GET /graphql?query={ user(id: \"1\") { username, website { quality } } }</pre>\\n<pre># GraphQL RESPONSE <br>{<br>  \"username\": \"jennycodes\",<br>  \"website\": {<br>    \"quality\": \"quite high\",<br>  }<br>}</pre>\\n<p>差別在哪？我在 query 裡面指明了我想要哪些資料（User 1 的 username 與 website quality），而 GraphQL 回傳給我的也就只包含了那些資料。前一個例子中的 response 雖然也給了我這些資料，但是它還包含了其他我不想知道的訊息，讓我還要對拿回來的東西自己加工處理，這個例子中的 response 就都是我想要的。回到餐廳的比喻，GraphQL 是提供單點，顧客可以自由搭配。今天我只想吃蛋炒飯，我就只點蛋炒飯；今天我想吃一盤蛋炒飯加上一盤紅蘿蔔蛋炒飯，也可以直接在同一個 query 裡面點完，想要什麼點什麼。酷吧。</p>\\n<h3>GraphQL 三要素</h3>\\n<p>從上面的簡單小例子應該可以稍微領略到 GraqhQL 的威力了。用一個直觀又彈性的查詢就可以得到我們想要的回應，溝通從來沒有如此輕鬆無障礙💪🏿 所以 GraqhQL 到底是怎麼做到的呢？我們先來認識 GraqhQL 的三個基本要素：<code class=\"markup--code markup--p-code\">Schema</code>, <code class=\"markup--code markup--p-code\">Type</code> 與 <code class=\"markup--code markup--p-code\">Query</code>。</p>\\n<h4>Schema</h4>\\n<blockquote>GraphQL query language is basically about selecting fields on objects.</blockquote>\\n<p>節錄自 <a href=\"https://graphql.org/learn/schema/#type-system\" data-href=\"https://graphql.org/learn/schema/#type-system\" class=\"markup--anchor markup--p-anchor\" rel=\"noopener nofollow\" target=\"_blank\">GraphQL</a>。</p>\\n<p>使用 GraphQL 其實就是找到物件（object），從物件中選取屬性（field）的過程。要如何知道哪些屬性是我們可以選的？回傳值的型態會是什麼？那些 sub-object （website）又有哪些欄位可以選擇？這就是 Schema 登場的時候了。</p>\\n<p>Schema 其實跟資料庫的 Schema 是相同的概念，它定義了 GraphQL query 基本的行為與架構，還有設定。以下是一個最基本的 Schema（使用 Ruby, as promised）。</p>\\n<pre># app/graphql/graphql_schema.rb</pre>\\n<pre>class Schema &lt; GraphQL::Schema<br>  query QueryType<br>end</pre>\\n<p>這邊單純是將 query（進入 GraphQL 的起手式，下面說明）指向 QueryType 這個類別。如果想要看更詳細的模板請繼續看下去。</p>\\n<h4>Type</h4>\\n<blockquote>[Object types] just represent a kind of object you can fetch from your service, and what fields it has.</blockquote>\\n<p>節錄自 <a href=\"https://graphql.org/learn/schema/#type-system\" data-href=\"https://graphql.org/learn/schema/#type-system\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">GraphQL</a>。</p>\\n<p>GraphQL 中的 Type 其實就像是資料庫裡面的資料表（data table）。在 Ruby 中它大概長這樣：</p>\\n<pre># app/graphql/types/user_type.rb<br>class Types::UserType &lt; Types::BaseObject<br>  description \"A User\"<br>  field :username, String<br>  field :phone, String<br>  field :website, Types::WebsiteType<br>end</pre>\\n<pre># app/graphql/types/user_type.rb<br>class Types::WebsiteType &lt; Types::BaseObject<br>  description \"Website of various qualities\"<br>  field :url, String, null: false<br>  field :quality, String<br>end</pre>\\n<p>是不是跟 Rails ActiveRecord::Schema 的資料表 syntax 超級像。</p>\\n<h4>Query</h4>\\n<p>大多數在 Schema 中的 Type 都是一般的 Object Type，但是有一種 Type 地位與眾不同：Root Type。Root Type 是 GraphQL query 的進入點（entry point），分成三種：Query, Mutation, Subscription。其中 Query 是必須要有的，其它兩種是自由選擇。假設我們看到客戶端發送這個請求</p>\\n<pre>GET /graphql?query={ user(id: \"1\") { username, website { quality } } }</pre>\\n<p>如果這個請求是合法的，這表示在伺服器端一定會有類似的宣告：</p>\\n<pre># app/graphql/types/query_type.rb<br><br>class QueryType &lt; GraphQL::Schema::Object<br>  description \"The query root of this schema\"</pre>\\n<pre>  field :user, UserType, null: true do <br>    description \"Find a user by ID\"<br>    argument :id, ID, required: true<br>  end</pre>\\n<pre>  # implementation<br>  def user(id:)<br>    Post.find(id)<br>  end<br>end</pre>\\n<p>在 QueryType 類別中我們定義一個名為 user 的進入點，它會去找 UserType，把適當的參數傳進去（id: 1），然後拿回資料。</p>\\n<p>所以說，在 GraphQL 中，Query 就是那本菜單，讓客戶知道可以怎麼點菜（怎麼查詢），還有拿回來的菜色是什麼（回傳值長什麼樣子）。</p>\\n<h3>GraphQL in Rails</h3>\\n<p>基本上，現在 GraphQL 跟很多語言都整合的很好了。Rails 中也可以直接使用 <a href=\"https://github.com/rmosolgo/graphql-ruby\" data-href=\"https://github.com/rmosolgo/graphql-ruby\" class=\"markup--anchor markup--p-anchor\" rel=\"noopener nofollow\" target=\"_blank\">graphql-ruby</a> gem 來實作。像是以下 generator</p>\\n<pre><code class=\"markup--code markup--pre-code\">$ rails generate graphql:install</code></pre>\\n<p>會做到：</p>\\n<ul>\\n<li name=\"0b63\" id=\"0b63\" class=\"graf graf--li graf-after--p\">在<code class=\"markup--code markup--li-code\">app/graphql/</code>建立相關資料夾。</li>\\n<li name=\"5ccf\" id=\"5ccf\" class=\"graf graf--li graf-after--li\">增加 schema definition。</li>\\n<li name=\"a4db\" id=\"a4db\" class=\"graf graf--li graf-after--li\">增加 base type classes。</li>\\n<li name=\"1b7b\" id=\"1b7b\" class=\"graf graf--li graf-after--li\">加上一個<code class=\"markup--code markup--li-code\">Query</code> type definition。</li>\\n<li name=\"3a3d\" id=\"3a3d\" class=\"graf graf--li graf-after--li\">增加 route 和 controller 來執行 queries。</li>\\n<li name=\"c44d\" id=\"c44d\" class=\"graf graf--li graf-after--li\">安裝 <code class=\"markup--code markup--li-code\"><a href=\"https://github.com/rmosolgo/graphiql-rails\" data-href=\"https://github.com/rmosolgo/graphiql-rails\" class=\"markup--anchor markup--li-anchor\" rel=\"noopener nofollow\" target=\"_blank\">graphiql-rails</a></code>。</li>\\n</ul>\\n<p>就跟 scaffold 一樣幫你省下一堆功夫，同時也讓你能夠快速上手使用它。很建議可以自己 rails new 一個新專案來試試 GraphQL，邊做邊學，會比較有感。而且這些 generator 都幫你做好了，不用白不用。</p>\\n<h4>必須要裝的 GraphiQL</h4>\\n<p>有沒有看到剛剛使用 <code class=\"markup--code markup--p-code\">$ rails generate graphql:install</code>自動產生的功能最後一條是「安裝 graphiql-rails」？除了自己開一個專案來實際玩玩之外，一定要做的事情就是去裝 <a href=\"https://github.com/graphql/graphiql\" data-href=\"https://github.com/graphql/graphiql\" class=\"markup--anchor markup--p-anchor\" rel=\"noopener nofollow\" target=\"_blank\">GraphiQL</a>。詳細到底有多好用就等你自己去發掘了！</p>\\n<h3>比較詳細的 Schema 樣板</h3>\\n<p>剛剛例子裡的 schema 是最簡單的那種，這邊提供一個詳細一點的模板讓有心人參考。</p>\\n<figure class=\"text-center\"><script src=\"https://gist.github.com/jenny-codes/0e340f08454ec233bb9a2411d7c44e35.js\"></script><figcaption class=\"imageCaption\"><a href=\"https://gist.github.com/jenny-codes/0e340f08454ec233bb9a2411d7c44e35\" data-href=\"https://gist.github.com/jenny-codes/0e340f08454ec233bb9a2411d7c44e35\" class=\"markup--anchor markup--figure-anchor\" rel=\"nofollow noopener\" target=\"_blank\">https://gist.github.com/jenny-codes/0e340f08454ec233bb9a2411d7c44e35</a></figcaption></figure><p>我們來一個個研究。</p>\\n<h4>Default Limits</h4>\\n<p>每個 field 都有一個 <a href=\"https://graphql-ruby.org/queries/complexity_and_depth\" data-href=\"https://graphql-ruby.org/queries/complexity_and_depth\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">complexity value</a> 我們可以定義。然後在 Schema 我們定義 max_complexity 來預防太複雜的 query。</p>\\n<p>而 max_depth 則是防止太多層的 nested_query。因為 GraphQL 的 query 是客戶端可以自己決定的，當結構變得複雜可能會出現一個包了很多層的 query（e.g. 用戶一號的網站的讀者的朋友的手機的電信公司的董事長的情人的眼鏡的價錢）。看得出來，定義一個適當的最高層數限制是好的。</p>\\n<h4>Root Type</h4>\\n<p>前面介紹了 Root Type 中的 Query，而 Mutation 與 Subscription 又是什麼呢？基本上，Query 用來查詢資料，Mutation 用來操作（新增、修改等等），而 Subscription 則是拿來實現聊天室這種即時請求用的。</p>\\n<h4>Plugins</h4>\\n<p>我們使用 use 關鍵字添加 plugins 為 schema 增加新的行為（而省掉不必要的 api 負擔），比如說<a href=\"https://graphql-ruby.org/queries/tracing#monitoring\" data-href=\"https://graphql-ruby.org/queries/tracing#monitoring\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">整合 NewRelic</a> 可以用<code class=\"markup--code markup--p-code u-paddingRight0 u-marginRight0\">use(GraphQL<strong class=\"markup--strong markup--p-strong\">::</strong>Tracing<strong class=\"markup--strong markup--p-strong\">::</strong>NewRelicTracing)</code>。</p>\\n<h4>Introspection</h4>\\n<p>GraphQL schema 有一個內建的<a href=\"https://graphql-ruby.org/schema/introspection.html\" data-href=\"https://graphql-ruby.org/schema/introspection.html\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\"> Introspection System</a>，讓我們知道這個 schema 的架構。</p>\\n<h3>先一個暫時的結尾</h3>\\n<p>其實這篇文章只是一個淺淺的起頭而已，還有一些像是 resolve type 等等概念沒有講。我們且戰且走，找個時間再來把這篇好好更新。</p>\\n<h3>References</h3>\\n<div>\\n<a href=\"https://graphql.org/\" data-href=\"https://graphql.org/\" class=\"markup--anchor markup--mixtapeEmbed-anchor\" title=\"https://graphql.org/\" rel=\"nofollow\"><strong class=\"markup--strong markup--mixtapeEmbed-strong\">GraphQL: A query language for APIs.</strong><br>graphql.org</a><a href=\"https://graphql.org/\" class=\"js-mixtapeImage mixtapeImage u-ignoreBlock\" data-media-id=\"279af7c5b9dadad843c4ce9775754191\" data-thumbnail-img-id=\"0*tnHdoc1eIWPLvii_\" style=\"background-image: url(https://cdn-images-1.medium.com/fit/c/320/320/0*tnHdoc1eIWPLvii_);\"></a>\\n</div>\\n<div>\\n<a href=\"https://graphql-ruby.org\" data-href=\"https://graphql-ruby.org\" class=\"markup--anchor markup--mixtapeEmbed-anchor\" title=\"https://graphql-ruby.org\" rel=\"nofollow\"><strong class=\"markup--strong markup--mixtapeEmbed-strong\">GraphQL - Welcome</strong><br>graphql-ruby.org</a><a href=\"https://graphql-ruby.org\" class=\"js-mixtapeImage mixtapeImage u-ignoreBlock\" data-media-id=\"29ad68106c886fd99afa61d25abde914\" data-thumbnail-img-id=\"0*WWcEGuffUFKUUzPx\" style=\"background-image: url(https://cdn-images-1.medium.com/fit/c/320/320/0*WWcEGuffUFKUUzPx);\"></a>\\n</div><p>文章同步發表於 <a href=\"https://medium.com/@jinghua.shih\">Medium</a>。",
        "status": 1,
        "description": "來看看 GraphQL 與它在 Rails 中的實作",
        "created_at": "2019-03-19T13:01:48.075437",
        "updated_at": "2020-02-02T05:19:30.347412",
        "slug": "graphql-in-ruby-on-rails",
        "medium_url": "https://medium.com/@jinghua.shih/graphql-in-ruby-on-rails-27195c1a2587"
    },
    {
        "id": 37,
        "title": "[Operating System] The Dining Philosophers Problem",
        "body": "<p></p>\\n<p>Last week we are introduced to some concepts of synchronization in operating systems. The main challenge is to ensure data integrity when multiple threads/tasks are running concurrently.</p>\\n<p>There are several classic situations in regard of this endeavor. Among them one particular question caught my attention. It is the dining philosophers problem.</p>\\n<h3>The Dining Philosophers Scenario</h3>\\n<figure class=\"text-center\"><img class=\"lazy img-fluid\" data-src=\"https://cdn-images-1.medium.com/max/1600/1*9zF4eD9-KhyMVmxEoSQENQ.jpeg\"><figcaption class=\"imageCaption\"><a href=\"https://upload.wikimedia.org/wikipedia/commons/d/d9/Dining-philosophers.jpg\" data-href=\"https://upload.wikimedia.org/wikipedia/commons/d/d9/Dining-philosophers.jpg\" class=\"markup--anchor markup--figure-anchor\" rel=\"nofollow noopener\" target=\"_blank\">https://upload.wikimedia.org/wikipedia/commons/d/d9/Dining-philosophers.jpg</a></figcaption></figure><ol>\\n<li name=\"b091\" id=\"b091\" class=\"graf graf--li graf-after--figure\">Five philosophers are sitting at a rounded dining table.</li>\\n<li name=\"44f1\" id=\"44f1\" class=\"graf graf--li graf-after--li\">There is one chopstick between each pair of adjacent philosophers.</li>\\n<li name=\"5292\" id=\"5292\" class=\"graf graf--li graf-after--li\">Philosophers are either thinking or eating.</li>\\n<li name=\"23f2\" id=\"23f2\" class=\"graf graf--li graf-after--li\">Whenever a philosopher wishes to eat, she first needs to find two chopsticks.</li>\\n<li name=\"2ae1\" id=\"2ae1\" class=\"graf graf--li graf-after--li\">If the hungry philosopher does not have two chopsticks (i.e. one or two of her neighbors already picked up the chopstick) she will have to wait until both chopsticks are available.</li>\\n<li name=\"3a42\" id=\"3a42\" class=\"graf graf--li graf-after--li\">When a philosopher finishes eating, she puts down both chopsticks to their original places, and resumes thinking.</li>\\n<li name=\"5028\" id=\"5028\" class=\"graf graf--li graf-after--li\">There is an infinite amount of food on their plate, so they only need to worry about the chopsticks.</li>\\n</ol>\\n<p>There are a few conditions:</p>\\n<ol>\\n<li name=\"defb\" id=\"defb\" class=\"graf graf--li graf-after--p\">Philosophers are either thinking or eating. They do not talk to each other.</li>\\n<li name=\"072e\" id=\"072e\" class=\"graf graf--li graf-after--li\">Philosophers can only fetch chopsticks placed between them and their neighbors.</li>\\n<li name=\"3e2b\" id=\"3e2b\" class=\"graf graf--li graf-after--li\">Philosophers cannot take their neighbors’ chopsticks away while they are eating.</li>\\n<li name=\"84f4\" id=\"84f4\" class=\"graf graf--li graf-after--li\">Hopefully no philosophers should starve to death (i.e. wait over a certain amount of time before she acquires both chopsticks).</li>\\n</ol>\\n<h3>The Real Situation</h3>\\n<p>As we probably have guessed, this is not just a problem of possible homicide of philosophers. The failures these philosophers may experience are the difficulties that arise in real computer programming when multiple programs need exclusive access to shared resources. It is about how to design a discipline of behavior-or more specifically, a concurrent algorithm-with the following three situation to avoid:</p>\\n<ol>\\n<li name=\"0f25\" id=\"0f25\" class=\"graf graf--li graf-after--p\">deadlocks</li>\\n<li name=\"1ac2\" id=\"1ac2\" class=\"graf graf--li graf-after--li\">resource starvation (livelock)</li>\\n<li name=\"a3f0\" id=\"a3f0\" class=\"graf graf--li graf-after--li\">Data Corruption</li>\\n</ol>\\n<h4>Deadlocks</h4>\\n<blockquote><em class=\"markup--em markup--blockquote-em\">In an operating system, a deadlock occurs when a process or thread enters a waiting state because a requested system resource is held by another waiting process, which in turn is waiting for another resource held by another waiting process.</em></blockquote>\\n<p><em class=\"markup--em markup--p-em\">— </em><a href=\"https://en.wikipedia.org/wiki/Deadlock\" data-href=\"https://en.wikipedia.org/wiki/Deadlock\" class=\"markup--anchor markup--p-anchor\" rel=\"noopener nofollow\" target=\"_blank\"><em class=\"markup--em markup--p-em\">Wikipedia</em></a></p>\\n<p>Basically, when a deadlock occurs, the program halts because no progress is available anymore. Think about what would happen if we instruct the philosophers as such (when they stops thinking and wishes to eat):</p>\\n<ol>\\n<li name=\"a039\" id=\"a039\" class=\"graf graf--li graf-after--p\">If both adjacent chopsticks are available, pick them up and eat (for sure).</li>\\n<li name=\"f0f2\" id=\"f0f2\" class=\"graf graf--li graf-after--li\">If there is only one adjacent chopstick available at the time, pick up that chopstick while waiting for the other chopstick to become available.</li>\\n<li name=\"cbb4\" id=\"cbb4\" class=\"graf graf--li graf-after--li\">If there are no chopsticks available, wait until any becomes available.</li>\\n</ol>\\n<p>This is a simple and intuitive solution, but also a dangerous one. When all five philosophers pick up their left chopstick at the same time, they will wait indefinitely because each is waiting for another to put down their chopsticks.</p>\\n<h4>Resource Starvation (Livelock)</h4>\\n<blockquote><em class=\"markup--em markup--blockquote-em\">Resource starvation is a problem encountered in concurrent computing where a process is perpetually denied necessary resources to process its work.</em></blockquote>\\n<p><em class=\"markup--em markup--p-em\">— </em><a href=\"https://en.wikipedia.org/wiki/Starvation_%28computer_science%29\" data-href=\"https://en.wikipedia.org/wiki/Starvation_(computer_science)\" class=\"markup--anchor markup--p-anchor\" rel=\"noopener nofollow\" target=\"_blank\"><em class=\"markup--em markup--p-em\">Wikipedia</em></a></p>\\n<p>The term <strong class=\"markup--strong markup--p-strong\">starving</strong> is quite self-explanatory. If we are not careful with our algorithm, the schedule may result in a situation where one philosopher is constantly bypassed for getting both chopsticks.</p>\\n<p><strong class=\"markup--strong markup--p-strong\">Finite Bypass</strong> is what we want. It means that there exists a limit of bypass counts for any process before being allowed access to the shared resource. If an algorithm is starvation-free, it has finite bypass.</p>\\n<h4>Data Corruption</h4>\\n<blockquote><em class=\"markup--em markup--blockquote-em\">Data corruption refers to errors in computer data that occur during writing, reading, storage, transmission, or processing, which introduce unintended changes to the original data.</em></blockquote>\\n<p><em class=\"markup--em markup--p-em\">— </em><a href=\"https://en.wikipedia.org/wiki/Data_corruption\" data-href=\"https://en.wikipedia.org/wiki/Data_corruption\" class=\"markup--anchor markup--p-anchor\" rel=\"noopener nofollow\" target=\"_blank\"><em class=\"markup--em markup--p-em\">Wikipedia</em></a></p>\\n<p>In our case, this is not a big concern. The closest thing to a data corruption here would be a scheduling that allows a philosopher to snatch her neighbors’ chopsticks while they are eating. That leaves the unfortunate neighbors in an undefined state of ‘half-full’ or ‘70% full’, which will cause unexpected results in the system.</p>\\n<h3>Some Solutions</h3>\\n<p>There are some established, brilliantly-designed solutions. We look at three of them: resource hierarchy solution, arbitrator solution, and Chandy/Misra solution.</p>\\n<h4>Resource Hierarchy Solution</h4>\\n<p>Dijkstra (the creator of this classic situation) proposed this solution. The idea is this:</p>\\n<ol>\\n<li name=\"5b3a\" id=\"5b3a\" class=\"graf graf--li graf-after--p\">Each resource (in this case, the chopsticks) is assigned a partial order.</li>\\n<li name=\"107f\" id=\"107f\" class=\"graf graf--li graf-after--li\">All resources will be requested in order. That is, if a unit of work (a philosopher) needs chopstick #1 and #2, she needs to acquire chopstick #1 first and then #2.</li>\\n<li name=\"608a\" id=\"608a\" class=\"graf graf--li graf-after--li\">The order in which the unit of work releases the resources does not matter. I.e. It does not matter if the philosopher puts down chopstick #1 or #2 first.</li>\\n</ol>\\n<p>This design guarantees deadlock-free. Its logic precludes the situation where all five philosophers pick up their chopsticks simultaneously. If four philosophers have already picked up one chopstick, only the highest-numbered chopstick will remain on the table, so the fifth philosopher cannot pick up any chopstick.</p>\\n<p>One major limitations to this solution is that it requires the list of resources be completely known in advance. If a unit of work finds out it needs a resource numbered 2 while holding resource #4 and #5, it would have to release the two resources first, acquire #2, and re-acquire #4 and #5. It could cause troubles in efficiency.</p>\\n<h4>Arbitrator Solution</h4>\\n<p>The idea of this solution is to introduce a third party that monitors the usage of resources. In this case, we would properly call it a waiter. The principles are as follows:</p>\\n<ol>\\n<li name=\"fd17\" id=\"fd17\" class=\"graf graf--li graf-after--p\">When a unit of work wishes to access a resource, it asks the arbitrator for permission first. That is, when a philosopher wishes to eat, she first asks the waiter.</li>\\n<li name=\"7a9a\" id=\"7a9a\" class=\"graf graf--li graf-after--li\">The arbitrator gives one permission at a time.</li>\\n<li name=\"0810\" id=\"0810\" class=\"graf graf--li graf-after--li\">Only the unit that has the permission can access shared resources.</li>\\n<li name=\"13c9\" id=\"13c9\" class=\"graf graf--li graf-after--li\">Releasing a resource does not need permissions.</li>\\n</ol>\\n<p>There are two major setbacks for this solution. First of all, a new central entity is introduced, which would require additional resources. Also, it results in <strong class=\"markup--strong markup--p-strong\">reduced parallelism</strong>: if a philosopher is eating and one of their neighbors requests the chopsticks, all other philosophers must wait until this request has been fulfilled even if their chopsticks are still on the table.</p>\\n<h4>Chandy/Misra Solution</h4>\\n<p>K.Mani Chandy and J.Misra introduced this solution in 1984.</p>\\n<ol>\\n<li name=\"456c\" id=\"456c\" class=\"graf graf--li graf-after--p\">Chopsticks have two state: clean and dirty. All chopsticks are initialized to dirty.</li>\\n<li name=\"169a\" id=\"169a\" class=\"graf graf--li graf-after--li\">The chopsticks are allocated to the philosophers with the lower id in the pair at the first place (no chopsticks on the table).</li>\\n<li name=\"e5b7\" id=\"e5b7\" class=\"graf graf--li graf-after--li\">When a philosopher wishes to eat, she must obtain the chopsticks from her neighbors. If she does not have the chopsticks, she sends a request message to the neighbor who has them.</li>\\n<li name=\"ba8c\" id=\"ba8c\" class=\"graf graf--li graf-after--li\">When a philosopher with a chopstick receives a request message:</li>\\n</ol>\\n<ul>\\n<li name=\"83ac\" id=\"83ac\" class=\"graf graf--li graf-after--li\">If the fork is clean, the philosopher keeps it.</li>\\n<li name=\"0a5a\" id=\"0a5a\" class=\"graf graf--li graf-after--li\">If the fork is dirty, the philosopher cleans it and sends the fork over.</li>\\n</ul>\\n<p>5. After eating, the philosopher’s chopsticks become dirty. If another philosopher has previously requested one of the chopsticks, the philosopher cleans and sends it.</p>\\n<p>Some strengths of this Algorithm:</p>\\n<ul>\\n<li name=\"36bc\" id=\"36bc\" class=\"graf graf--li graf-after--p\">It allows for arbitrary agents to contend for an arbitrary number of resources.</li>\\n<li name=\"e7bd\" id=\"e7bd\" class=\"graf graf--li graf-after--li\">It is completely distributed and requires no central authority.</li>\\n<li name=\"6042\" id=\"6042\" class=\"graf graf--li graf-after--li\">It allows for a large degree of concurrency.</li>\\n<li name=\"8499\" id=\"8499\" class=\"graf graf--li graf-after--li\">It solves the starvation problem: the clean / dirty states act as a way of giving preference to the most ‘starved’ processes.</li>\\n</ul>\\n<p>As amazing as it seems, this design actually violates the rule of ‘philosophers do not talk to each other’, though.</p>\\n<h3>Implementation Options</h3>\\n<h4>Mutex Locks</h4>\\n<p>There are a couple of mechanisms that implement locks. Mutex (mutual exclusion) is the fundamental synchronization technique. The idea is simple: whenever a work unit accesses the <strong class=\"markup--strong markup--p-strong\">critical section</strong>, it first needs a lock that guarantees no one else at this time is accessing the critical section. When the work unit exits the critical section, it returns the lock for other work units to access.</p>\\n<p>In the dining philosopher problem, we can implement an algorithm with mutexes that guarantee the philosophers not to be interrupted when they are changing their states (e.g. the process of picking up chopsticks).</p>\\n<p>Pthread API usage:</p>\\n<pre><code class=\"markup--code markup--pre-code\">#include&lt;pthread.h&gt; </code></pre>\\n<pre><code class=\"markup--code markup--pre-code\">// Declare a mutex <br>pthread_mutex_t mutex; </code></pre>\\n<pre><code class=\"markup--code markup--pre-code\">// Initialize the mutex <br>pthread_mutex_init(&amp;mutex, NULL); </code></pre>\\n<pre><code class=\"markup--code markup--pre-code\">// Lock the mutex <br>pthread_mutex_lock(&amp;mutex); </code></pre>\\n<pre><code class=\"markup--code markup--pre-code\">// Critical section goes here <br>... </code></pre>\\n<pre><code class=\"markup--code markup--pre-code\">// Unlock the mutex <br>pthread_mutex_unlock(&amp;mutex); </code></pre>\\n<pre><code class=\"markup--code markup--pre-code\">// Clean up the mutex <br>pthread_mutex_destroy(&amp;mutex);</code></pre>\\n<h4>Semaphores</h4>\\n<p>The usage of semaphores is very similar to using mutex locks. Instead of the binary operation in mutex locks (holding lock &lt;-&gt; releasing lock), semaphores function on the idea of ‘number of resources’. Each semaphore is initialized to a number, indicating how many resources associated with that semaphore are available at that moment. When we use <code class=\"markup--code markup--p-code\">sem_wait()</code> the number associated with that semaphore will decrease by one. When we use <code class=\"markup--code markup--p-code\">sem_post()</code> the number associated with that semaphore will increase by one.</p>\\n<p>Semaphores and mutex lock are interchangeable if there are only one resource associated with it (which will make it a binary semaphore).</p>\\n<p>Pthread API usage:</p>\\n<pre><code class=\"markup--code markup--pre-code\">#include &lt;semaphore.h&gt; </code></pre>\\n<pre><code class=\"markup--code markup--pre-code\">// Create a semaphore <br>sem_t mutex; </code></pre>\\n<pre><code class=\"markup--code markup--pre-code\">// Initialize the semaphore to its default attributes, <br>// and the number of resources to 1. <br>sem_init(&amp;mutex, 0, 1); </code></pre>\\n<pre><code class=\"markup--code markup--pre-code\">// Acquire the semaphore <br>sem_wait(&amp;mutex); </code></pre>\\n<pre><code class=\"markup--code markup--pre-code\">// Critical section goes here <br>... </code></pre>\\n<pre><code class=\"markup--code markup--pre-code\">// Releasing the semaphore <br>sem_post(&amp;mutex);</code></pre>\\n<h3>Implementation using Pthread API with C</h3>\\n<p>In addition to the <a href=\"https://linux.die.net/man/3/pthread_mutex_lock\" data-href=\"https://linux.die.net/man/3/pthread_mutex_lock\" class=\"markup--anchor markup--p-anchor\" rel=\"noopener nofollow\" target=\"_blank\">built in mutex locks</a>, I also used <strong class=\"markup--strong markup--p-strong\">condition variable</strong>. In case we accidentally forgot what is a condition variable introduced in <a href=\"https://jennycodes.me/posts/operating-system-process-synchronization\" data-href=\"https://jennycodes.me/posts/operating-system-process-synchronization\" class=\"markup--anchor markup--p-anchor\" rel=\"noopener nofollow\" target=\"_blank\">last week’s note</a>, here is a brief review:</p>\\n<h4>Condition Variable</h4>\\n<p>In short, a condition variable enables a mutex lock to wait for a certain condition to become true before resuming execution. When the execution encounters a condition variable, it will pause and pass over the processor to another (waiting) thread, until someone ‘signals’ that conditional variable to keep going. In other context it may be seen in a <a href=\"https://en.wikipedia.org/wiki/Monitor_%28synchronization%29\" data-href=\"https://en.wikipedia.org/wiki/Monitor_(synchronization)\" class=\"markup--anchor markup--p-anchor\" rel=\"noopener nofollow\" target=\"_blank\">monitor</a>. Since Pthread does not provide monitor functionality, we would instead associate condition variables onto the mutex itself (why should it be associated with a mutex lock? to prevent race condition.) Let’s look at the basic usage of <a href=\"http://www.cs.kent.edu/~ruttan/sysprog/lectures/multi-thread/pthread_cond_init.html\" data-href=\"http://www.cs.kent.edu/~ruttan/sysprog/lectures/multi-thread/pthread_cond_init.html\" class=\"markup--anchor markup--p-anchor\" rel=\"noopener nofollow\" target=\"_blank\">condition variables from Pthread API</a> first:</p>\\n<pre><code class=\"markup--code markup--pre-code\">#include&lt;pthread.c&gt; </code></pre>\\n<pre><code class=\"markup--code markup--pre-code\">// Note: suppose a pthread mutex lock named 'mutex' has already been created and initialized. </code></pre>\\n<pre><code class=\"markup--code markup--pre-code\">// Create a condition variable <br>pthread_cond_t condition; </code></pre>\\n<pre><code class=\"markup--code markup--pre-code\">// Initialize the condition variable to its default attributes<br>pthread_cond_init(&amp;condition, NULL); </code></pre>\\n<pre><code class=\"markup--code markup--pre-code\">// Enter a critical section <br>pthread_mutex_lock(&amp;mutex); </code></pre>\\n<pre><code class=\"markup--code markup--pre-code\">// some work <br>... </code></pre>\\n<pre><code class=\"markup--code markup--pre-code\">// Start to wait for a condition to become true <br>while (some_condition != true) <br>  pthread_cond_wait(&amp;condition, &amp;mutex); </code></pre>\\n<pre><code class=\"markup--code markup--pre-code\">// some more work <br>... </code></pre>\\n<pre><code class=\"markup--code markup--pre-code\">// (in some other process) Issue a signal<br>pthread_cond_signal(&amp;condition); </code></pre>\\n<pre><code class=\"markup--code markup--pre-code\">// Exit a critical section <br>pthread_mutex_unlock(&amp;mutex); </code></pre>\\n<pre><code class=\"markup--code markup--pre-code\">// Clean up the condition variable pthread_cond_destroy(&amp;condition[i]);</code></pre>\\n<p>From the usage example above we learnt that</p>\\n<ol>\\n<li name=\"9296\" id=\"9296\" class=\"graf graf--li graf-after--p\">Condition variables are used inside a critical section(or else it would not be needed anyway).</li>\\n<li name=\"c649\" id=\"c649\" class=\"graf graf--li graf-after--li\">Condition variables are generally used in a while loop, that serves to check if a condition becomes true.</li>\\n</ol>\\n<h4>The Implementation</h4>\\n<p>is here: <a href=\"https://github.com/jing-jenny-shih/operating-systems/blob/master/06-synchronization/dining_philosophers.c\" data-href=\"https://github.com/jing-jenny-shih/operating-systems/blob/master/06-synchronization/dining_philosophers.c\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">https://github.com/jing-jenny-shih/operating-systems/blob/master/06-synchronization/dining_philosophers.c</a></p>\\n<p>The only thing to note is that <code class=\"markup--code markup--p-code\">pthread_cond_destory</code> would not have any effect if there is no condition variable that is currently blocked. The rest should be quite self-explanatory. Happy coding!</p><h3>REFERENCES</h3>\\n<ul>\\n<li name=\"e61a\" id=\"e61a\" class=\"graf graf--li graf-after--h3\"><a href=\"https://c-program-example.com/2012/02/c-program-to-solve-dining-philosophers-problem.html\" data-href=\"https://c-program-example.com/2012/02/c-program-to-solve-dining-philosophers-problem.html\" class=\"markup--anchor markup--li-anchor\" rel=\"nofollow noopener\" target=\"_blank\">https://c-program-example.com/2012/02/c-program-to-solve-dining-philosophers-problem.html</a></li>\\n<li name=\"e906\" id=\"e906\" class=\"graf graf--li graf-after--li graf--trailing\"><a href=\"http://pubs.opengroup.org/onlinepubs/007908799/xsh/pthreadcondwait.html\" data-href=\"http://pubs.opengroup.org/onlinepubs/007908799/xsh/pthreadcondwait.html\" class=\"markup--anchor markup--li-anchor\" rel=\"nofollow noopener\" target=\"_blank\">http://pubs.opengroup.org/onlinepubs/007908799/xsh/pthread<em class=\"markup--em markup--li-em\">cond</em>wait.html</a></li>\\n</ul><p><em class=\"markup--em markup--p-em\">Originally published at </em><a href=\"https://jennycodes.me/posts/operating-system-the-dining-philosophers-problem\" data-href=\"https://jennycodes.me/posts/operating-system-the-dining-philosophers-problem\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\"><em class=\"markup--em markup--p-em\">https://jennycodes.me</em></a><em class=\"markup--em markup--p-em\">.</em></p><p>文章同步發表於 <a href=\"https://medium.com/@jinghua.shih\">Medium</a>。",
        "status": 1,
        "description": "synchronization, mutex locks and semaphores",
        "created_at": "2019-05-02T01:36:08.572102",
        "updated_at": "2019-05-15T12:24:25.904601",
        "slug": "operating-system-the-dining-philosophers-problem",
        "medium_url": "https://medium.com/@jinghua.shih/operating-system-the-dining-philosophers-problem-6f35f210a4e2"
    },
    {
        "id": 45,
        "title": "Design Patterns 設計模式來吧！",
        "body": "<p>在繼續<a href=\"https://jennycodes.me/posts/security-ddos-distributed-denial-of-service-attack\">完成資訊安全系列文章</a>之前，先插入一個這兩個月在（玩）做的計畫／挑戰／比賽：iThome 主辦的 IT 鐵人賽！</p>\\n<p>當初知道這個挑戰就躍躍欲試，於是在公司裡拉了大概 10 個工程師組成了團隊一起參賽。開了幾次會，決定參賽主題、合作形式、流程等等，就如火如荼地開始了，而前幾天剛剛結束比賽，總共完成了 32 篇文章，主題是什麼呢？如果你還沒有猜到的話，登登，就是 design patterns 設計模式！</p>\\n<p>話不多說，直接送上文章連結： </p>\\n<p><a href=\"https://ithelp.ithome.com.tw/users/20120812/ironman/2697\">https://ithelp.ithome.com.tw/users/20120812/ironman/2697</a></p>\\n<p>Enjoy!</p>\\n",
        "status": 1,
        "description": "32 篇優質好文一次呈現",
        "created_at": "2019-10-24T12:12:34.904627",
        "updated_at": "2020-02-10T12:05:35.945469",
        "slug": "design-patterns",
        "medium_url": ""
    },
    {
        "id": 42,
        "title": "[Networking] the OSI Model",
        "body": "<p>In <a href=\\\\\"https://jennycodes.me/posts/%E5%BE%9E%E9%BB%9E%E4%B8%80%E5%80%8B-url-%E5%88%B0%E7%9C%8B%E5%88%B0%E9%A0%81%E9%9D%A2%E4%B8%AD%E9%96%93%E7%99%BC%E7%94%9F%E4%BA%86%E4%BB%80%E9%BA%BC%E4%BA%8B%E4%B8%8A%E9%9B%86\\\\\" data-href=\\\\\"https://jennycodes.me/posts/從點一個-url-到看到頁面中間發生了什麼事上集\\\\\" class=\\\\\"markup--anchor markup--p-anchor\\\\\" rel=\\\\\"nofollow noopener\\\\\" target=\\\\\"_blank\\\\\">a former attempt</a> (actually <a href=\\\\\"https://jennycodes.me/posts/%E5%BE%9E%E9%BB%9E%E4%B8%80%E5%80%8B-url-%E5%88%B0%E7%9C%8B%E5%88%B0%E9%A0%81%E9%9D%A2%E4%B8%AD%E9%96%93%E7%99%BC%E7%94%9F%E4%BA%86%E4%BB%80%E9%BA%BC%E4%BA%8B%E4%B8%8B%E9%9B%86\\\\\" data-href=\\\\\"https://jennycodes.me/posts/從點一個-url-到看到頁面中間發生了什麼事下集\\\\\" class=\\\\\"markup--anchor markup--p-anchor\\\\\" rel=\\\\\"nofollow noopener\\\\\" target=\\\\\"_blank\\\\\">two</a>) I explained the request-to-response journey from a user clicking a URL to seeing a web page displaying on the screen. Those two articles focus on the web server–how the request is handled inside, and how web servers interact with others. But that was just part of the story. How exactly are the data handled? How are they generated, encoded, transported, decoded, and presented? This article, therefore, is another attempt to walk through the clicking-a-url-to-seeing-a-result process again, with the focus on data processing. To be able to do that, we will use the help of <strong class=\\\\\"markup--strong markup--p-strong\\\\\">the Open System Interconnection (OSI) model</strong> to understand the ideas and concepts that are going to be messy (we will soon see) in a structured and understandable way. Hopefully.</p><h3>OSI: The Open System Interconnection Model</h3><blockquote>The <strong class=\\\\\"markup--strong markup--blockquote-strong\\\\\">OSI model</strong> is a conceptual model that characterizes and standardizes the communication functions of a telecommunication or computing system without regard to its underlying internal structure and technology. –Wikipedia</blockquote><p>Basically, what the OSI model does is constructing a “language”, or custom, for networks to transfer data. It describes how computers should behave so that we can make sure the data we want to send and receive are properly and correctly done. Some features and characteristics of the OSI model:</p><ol><li name=\\\\\"d10f\\\\\" id=\\\\\"d10f\\\\\" class=\\\\\"graf graf--li graf-after--p\\\\\">There are seven layers in this model. From bottom (where the actual data transfer occurs) to top (closest to the end user) are <strong class=\\\\\"markup--strong markup--li-strong\\\\\">Physical Layer → Data Link Layer →</strong> <strong class=\\\\\"markup--strong markup--li-strong\\\\\">Network Layer → Transport Layer → Session Layer → Presentation Layer → Application Layer</strong>.</li><li name=\\\\\"12ce\\\\\" id=\\\\\"12ce\\\\\" class=\\\\\"graf graf--li graf-after--li\\\\\">Each layer has its own concerns and functions in this data transfer procedure.</li><li name=\\\\\"c771\\\\\" id=\\\\\"c771\\\\\" class=\\\\\"graf graf--li graf-after--li\\\\\">Each time a data transfer occurs, the data is passed through the seven layers in order. For the source computer, the flow of data is from top to bottom (encoding process). When the data are sent across networks, and reach the receiving computer, they will be sent up from the bottom of the OSI model (decoding process), and are displayed to the end user.</li><li name=\\\\\"a7de\\\\\" id=\\\\\"a7de\\\\\" class=\\\\\"graf graf--li graf-after--li\\\\\">If we draw a mental picture, the data flow would be like a “U”, where the starting point (upper left) is the application layer of the source computer, and the end (upper right) is the corresponding application layer of the receiving computer.</li><li name=\\\\\"36c9\\\\\" id=\\\\\"36c9\\\\\" class=\\\\\"graf graf--li graf-after--li\\\\\">Between networks, each layer communicates only with its counterpart. That is, if computer A and B are sending data to each other, layer 1 in computer A woud only be talking to Layer 1 in computer B. Layer 2 in computer A to Layer 2 in computer B, and so on.</li></ol><h3>Why do we need OSI model?</h3><p>Before we go on, let us talk about why we need OSI model. First of all, it compartmentalizes a plethora of concepts and protocols in the network world into categories, and provides a nice structure for them so we can talk about these concerns separately and design/debug networks with more methods and efficiency. Another important advantage of the OSI model is data encapsulation. Layers in the model do not interfere with each other. They only pass data, and keep the implementation details to themselves. The benefit of this is that when something goes wrong, it is easier to pin down the source of errors.</p><p>With that in mind, to the OSI model we go.</p><h3>Layer Seven: Application Layer</h3><blockquote>Network Process to Application</blockquote><p>As the top layer of the OSI model, application layer is the layer that we (users) interact directly with. Application-layer functions typically include identifying communication partners (where to transmit the data), determining resource availability (is the destination available), and synchronizing communication (send the data).</p><p>In our url-clicking case, the application is the browser. The browser selects which web server it is sending data to, contacts the server and send the request. When a response is returned, the browser displays the desired content on the web page.</p><h3>Layer Six: Presentation Layer</h3><blockquote>Data Encapsulation and Encryption</blockquote><p>Sometimes called the syntax layer, the presentation layer provides a mapping of different syntaxes to a unified data representation. It translates between application and network format, and transform data into the format that the application accepts. Other functions of this layer includes data encryption and data compression.</p><p>Usually a web page contains different formats of data: HTML files, Javascript files, image files, etc. In the presentation layer these files are transformed by <a href=\\\\\"https://en.wikipedia.org/wiki/Abstract_Syntax_Notation_One\\\\\" data-href=\\\\\"https://en.wikipedia.org/wiki/Abstract_Syntax_Notation_One\\\\\" class=\\\\\"markup--anchor markup--p-anchor\\\\\" rel=\\\\\"nofollow noopener\\\\\" target=\\\\\"_blank\\\\\">Abstract Syntax Notation One</a> into XML format to be displayed on the browser.</p><h3>Layer Five: Session Layer</h3><blockquote>Interhost Communication</blockquote><p>The session layer controls the connections between two computers by establishing, managing, and terminating sessions. Whenever we visit any website, our computer is creating a session with the web server. In applications that uses Remote Procedure Calls, the session layer is is commonly implemented explicitly.</p><p>When we request a web page, the web browser opens a <strong class=\\\\\"markup--strong markup--p-strong\\\\\">TCP/UDP connection </strong>(explained below) to the web server. The web server sends back the web page and closes the connection. Each TCP/UDP connection is a session.</p><h3>Layer Four: Transport Layer</h3><blockquote>End-to-End Communication and Reliability</blockquote><p>This layer provides host-to-host communication services for applications. That is, it is responsible for delivering data to the appropriate application process on the host computers. It also coordinates the data transfer process: how much data to send, at what rate, with what behaviors, and so on. Two important protocols for this layer are the <a href=\\\\\"https://en.wikipedia.org/wiki/Transmission_Control_Protocol\\\\\" data-href=\\\\\"https://en.wikipedia.org/wiki/Transmission_Control_Protocol\\\\\" class=\\\\\"markup--anchor markup--p-anchor\\\\\" rel=\\\\\"nofollow noopener\\\\\" target=\\\\\"_blank\\\\\">TCP (Transmission Control Protocol)</a> and the <a href=\\\\\"https://en.wikipedia.org/wiki/User_Datagram_Protocol\\\\\" data-href=\\\\\"https://en.wikipedia.org/wiki/User_Datagram_Protocol\\\\\" class=\\\\\"markup--anchor markup--p-anchor\\\\\" rel=\\\\\"nofollow noopener\\\\\" target=\\\\\"_blank\\\\\">UDP (User Datagram Protocol)</a>. They each describes a very different approach to this transfer process.</p><h4 id=\"tcp\">TCP: Transmission Control Protocol</h4><p>We (well if you don’t, I) often hear the term “TCP/IP” in the context of computer networking. TCP is the original implementation which provides a delivery of data between hosts, or end systems, running via an IP network. Later, the term “TCP/IP” commonly refers to the entire network model (like the OSI model that we are walking through). We will go into that in the next post. Now, some characteristics of TCP:</p><ul><li name=\\\\\"55c1\\\\\" id=\\\\\"55c1\\\\\" class=\\\\\"graf graf--li graf-after--p\\\\\">It is a <a href=\\\\\"http://connection%20oriented%20protocol%20means\\\\\" data-href=\\\\\"http://connection oriented protocol means\\\\\" class=\\\\\"markup--anchor markup--li-anchor\\\\\" rel=\\\\\"nofollow noopener\\\\\" target=\\\\\"_blank\\\\\">connection-oriented</a> protocol. It requires handshaking (that is, acknowledging each side is there and ready) to set up communications.</li><li name=\\\\\"0329\\\\\" id=\\\\\"0329\\\\\" class=\\\\\"graf graf--li graf-after--li\\\\\">It is reliable. TCP makes sure of the right order, and the integrity of data. It manages message acknowledgment, retransmission and timeout. If a message is lost along the way, the server will re-request the lost parts.</li><li name=\\\\\"1e71\\\\\" id=\\\\\"1e71\\\\\" class=\\\\\"graf graf--li graf-after--li\\\\\">It is heavyweight. TCP’s handshaking mechanism requires three packets to set up a socket connection, before any user data can be sent. Also, it has a fat overhead so that it could provide the functionalities mentioned above.</li><li name=\\\\\"82ac\\\\\" id=\\\\\"82ac\\\\\" class=\\\\\"graf graf--li graf-after--li\\\\\">A brief TCP connection walk-through: new socket → bind → listen (handshakes begin) → (connection established) → accept</li></ul><h4 id=\"udp\">UDP: User Datagram Protocol</h4><p>Like TCP, UDP is a protocol that instructs how the data-transporting process in the Transport layer should go about. Yet UDP’s principle is quite different from TCP. TCP gets things done in a slower but throughout manner. UDP, on the other hand, values speed over reliability.</p><p>Some characteristics:</p><ul><li name=\\\\\"7ad2\\\\\" id=\\\\\"7ad2\\\\\" class=\\\\\"graf graf--li graf-after--p\\\\\">UDP uses a simple <a href=\\\\\"https://en.wikipedia.org/wiki/Connectionless_communication\\\\\" data-href=\\\\\"https://en.wikipedia.org/wiki/Connectionless_communication\\\\\" class=\\\\\"markup--anchor markup--li-anchor\\\\\" rel=\\\\\"nofollow noopener\\\\\" target=\\\\\"_blank\\\\\">connectionless communication</a> model. It has no hand-shaking dialogues, so a message can be sent from one end point to another without prior arrangement.</li><li name=\\\\\"f810\\\\\" id=\\\\\"f810\\\\\" class=\\\\\"graf graf--li graf-after--li\\\\\">UDP does not keep track of lost packets, nor does it care about packet arrival order.</li><li name=\\\\\"a298\\\\\" id=\\\\\"a298\\\\\" class=\\\\\"graf graf--li graf-after--li\\\\\">As a result, UDP requires less computer resources.</li><li name=\\\\\"42ea\\\\\" id=\\\\\"42ea\\\\\" class=\\\\\"graf graf--li graf-after--li\\\\\">UDP is suitable for purposes where error checking and correction are either not necessary or are performed in the application, like streaming media applications and real-time applications.</li><li name=\\\\\"5d61\\\\\" id=\\\\\"5d61\\\\\" class=\\\\\"graf graf--li graf-after--li\\\\\">Since it is transaction-oriented, UDP is suitable for simple query-response protocols such as the Domain Name System (where queries must be fast and only consist of a single request followed by a single reply packet.</li><li name=\\\\\"bfe9\\\\\" id=\\\\\"bfe9\\\\\" class=\\\\\"graf graf--li graf-after--li\\\\\">It provides datagrams, basic transfer units associated with a packet-switch network, suitable for modeling other protocols such as IP tunneling or Remote Procedure Call.</li></ul><h3>Layer Three: Network Layer</h3><blockquote>Path Determination and Logical Addressing</blockquote><p>This is the layer responsible for transferring variable-length network packets from a source to a destination, possibly through several proxies (networks). The <strong class=\\\\\"markup--strong markup--p-strong\\\\\">router</strong> here plays an important part. It connects networks formed by switches. An important protocol for this layer is <strong class=\\\\\"markup--strong markup--p-strong\\\\\">Internet Protocol (IP)</strong>.</p><h4>IP: Internet Protocol</h4><p>An IP is a piece of software that operates at the Network Layer of the OSI model. It provides unique addresses (IP addresses), connectionless communication, routing, and unicast/broadcast/multicast.</p><p>The IP address is for anything connected to an internet. These addresses can change, but they are guaranteed to be unique. For example, “104.27.187.82” would be a valid IP address for website jennycodes.me.</p><h4>Router/Gateway</h4><p>A router/gateway is a specialized host responsible for forwarding packets between networks. The reason why it exists is that many networks are partitioned into subnetworks and connect to other networks for wide-area communication.</p><h4>Sending a Packet to Router</h4><p>If we know both the <strong class=\\\\\"markup--strong markup--p-strong\\\\\">IP address</strong> and <strong class=\\\\\"markup--strong markup--p-strong\\\\\">MAC address</strong> (explained below) of our destination, we can send the data. In the case that the source and destination are not from the same IP domain, the source will be sending the data to the router first for transmission.</p><h3>Layer Two: Data Link Layer</h3><blockquote>Physical Addressing</blockquote><p>At the layer, data are decoded into frames of bits. It manages and handles errors in the physical layer, flow control and frame synchronization. Data link layer has two sub-layers: the <a href=\\\\\"https://en.wikipedia.org/wiki/Medium_access_control\\\\\" data-href=\\\\\"https://en.wikipedia.org/wiki/Medium_access_control\\\\\" class=\\\\\"markup--anchor markup--p-anchor\\\\\" rel=\\\\\"nofollow noopener\\\\\" target=\\\\\"_blank\\\\\">Medium Access Control (MAC)</a> layer and the <a href=\\\\\"https://en.wikipedia.org/wiki/Logical_link_control\\\\\" data-href=\\\\\"https://en.wikipedia.org/wiki/Logical_link_control\\\\\" class=\\\\\"markup--anchor markup--p-anchor\\\\\" rel=\\\\\"nofollow noopener\\\\\" target=\\\\\"_blank\\\\\">Logical Link Control (LLC)</a> layer. The implementation widely adopted now is a <a href=\\\\\"https://en.wikipedia.org/wiki/Network_switch\\\\\" data-href=\\\\\"https://en.wikipedia.org/wiki/Network_switch\\\\\" class=\\\\\"markup--anchor markup--p-anchor\\\\\" rel=\\\\\"nofollow noopener\\\\\" target=\\\\\"_blank\\\\\">network switch</a>.</p><h4>MAC: Medium Access Control</h4><p>This sub-layer controls how the computer hardware gains access to the data and permission to transmit them. A <a href=\\\\\"https://en.wikipedia.org/wiki/MAC_address\\\\\" data-href=\\\\\"https://en.wikipedia.org/wiki/MAC_address\\\\\" class=\\\\\"markup--anchor markup--p-anchor\\\\\" rel=\\\\\"nofollow noopener\\\\\" target=\\\\\"_blank\\\\\">MAC address (Media Access Control address)</a> is a unique identifier for a device in communications within a network segment. It is used as a network address for technologies including Wi-Fi, Bluetooth and Ethernet.</p><p>MAC address are assigned by the manufacturer of network interface cards, so they are sometimes referred to as burned-in address. A MAC address looks like this: ‘3A-34–52-C4–69-B8’.</p><h4>LLC: Logical Link Control</h4><p>The LLC sublayer acts as an interface between the MAC sublayer and the network layer. It controls frame synchronization, flow control and error checking, and makes it possible for several network protocols (IP and Appletalk for example) to coexist.</p><h4>Network Switch</h4><p>A switch is a computer networking device which connects devices on a network. It uses hardware addresses (physical addresses or MAC Addresses) to process and forward data in the data link layer. Also, it offers port-to-port support–data are only sent between concerning devices as well as buffering service.</p><h3>Layer One: Physical Layer</h3><blockquote>Media, Signal and Binary Transmission</blockquote><p>The physical layer is where the raw data are transported in the form of bits–0 and 1–across the network (i.e. where the magic happens). The form can be either electrical, mechanical or radio waves.</p><h3>That’s it</h3><p>When you click on a url, the browser will immediately translate the event into a request, and the request is sent down the OSI model, across networks, and climb up the layers in the destination server, where the data is received and processed, before a response is sent back. And it all happens in milliseconds (well if nothing crashes and it’s not a badly structured website). Amazing, isn’t it?</p><p>Next post will be on TCP/IP, a model built upon the OSI model. Be excited.</p><p>文章同步發表於 <a href=\\\\\"https://medium.com/@jinghua.shih\\\\\">Medium</a>。",
        "status": 1,
        "description": "what happens when you click on a URL?",
        "created_at": "2019-07-06T04:54:05.854507",
        "updated_at": "2019-07-07T21:26:24.940259",
        "slug": "networking-the-osi-model",
        "medium_url": "https://medium.com/@jinghua.shih/networking-the-osi-model-4a508d84444"
    },
    {
        "id": 43,
        "title": "[Networking] the TCP/IP Model",
        "body": "<p>The Open System Interconnection model (OSI), introduced in the last post, is a seven-layered network structure that groups different protocols/elements into well-defined categories. Idealized as the OSI model is, in reality, we use a different model–the TCP/IP model in implementation. </p>\\n<p>The TCP/IP model predates the OSI model. While the OSI model is developed based on a predefined architecture, and serves as a more comprehensive framework, the TCP/IP model has clearer/more practical boundaries, because the TCP/IP model is built upon existing protocols, and uses these protocols as boundaries.</p>\\n<p>In this post, besides introducing the TCP/IP model, we will also look at the principles behind both the TCP/IP and the OSI model, so that we can better understand how they are constructed as so.</p>\\n<h3 id=\"tcp-ip-or-internet-protocol-suite-\">TCP/IP (or Internet Protocol Suite)</h3>\\n<p>The official name of TCP/IP is the Internet Protocol Suite. It is a model that includes a set of communication protocols used in computer networks like the Internet. The name TCP/IP comes from the two foundational protocols in this model: the Transmission Control Protocol (TCP) and the Internet Protocol (IP). Like the OSI model, TCP/IP provides end-to-end data communication specifying how data should be packetized, addressed, transmitted, routed, and received. Unlike the OSI model, which has seven abstraction layers, TCP/IP has four layers–the Link layer, the Internet layer, the Transport layer, and the Application layer.</p>\\n<p>note: according to the <a href=\"https://tools.ietf.org/html/rfc1122\">RFC 1122</a>, this TCP/IP model has four layers. There are other versions that has five layers, which break the Link layer into Data Link layer and Physical/Hardware layer.</p>\\n<h3 id=\"principles-of-tcp-ip-and-the-osi-model\">Principles of TCP/IP and the OSI Model</h3>\\n<h4 id=\"the-end-to-end-principle\">The End-to-End Principle</h4>\\n<p>The end-to-end principle ensures that the Internet who connects the edges retains no state–any specific information on the edges–and focuses instead on the action of connecting. The idea is to separate the data and the function: the maintenance of states and the overall intelligence should be kept within the edges. Each request is considered new because there is no &quot;state&quot; saved in the function. In reality, however, this is hard to realized because of the needs for firewalls, web content caches, etc.</p>\\n<p>This stateless-ness has an exception in the transport layer, where the connection remains in place until all the packets in a message have been received and reassembled at the destination.</p>\\n<h4 id=\"the-robustness-principle\">The Robustness Principle</h4>\\n<blockquote>\\n<p>Be conservative in what you send, be liberal in what you accept. –reworded from Jon Postel</p>\\n</blockquote>\\n<p>The <a href=\"https://en.wikipedia.org/wiki/Robustness_principle\">robustness principle</a>, or Postel&#39;s law, states that programs that send messages to other machines (or to other programs on the same machine) should conform completely to the specifications, but programs that receive messages should accept non-conformant input as long as the meaning is clear.</p>\\n<p>RFC 1122 recommends programmers &quot;assume that the network is filled with malevolent entities that will send in packets designed to have the worst possible effect&quot;.</p>\\n<blockquote>\\n<p>In general, an implementation must be conservative in its sending behavior, and liberal in its receiving behavoir. It must be careful to send well-formed datagrams, but must accept any datagam that it can interpret (not object to technical errors where the meaning is still clear.)</p>\\n</blockquote>\\n<h4 id=\"encapsulation\">Encapsulation</h4>\\n<p>Encapsulation refers to the act that takes data from one protocol to another, with a process of translation, so the data can continue across a network. In reality, it&#39;s accomplished by adding headers &amp; trailers around the data.</p>\\n<p>In the OSI model, each layer builds a protocol data unit (PDU). Each layer provides a service to the layer above it (adjacent-layer interaction), while at the same time each layer communicates with its corresponding layer on the receiving node (same-layer interaction).</p>\\n<p>Now let&#39;s look at the four layers in the TCP/IP model.</p>\\n<h3 id=\"application-layer\">Application Layer</h3>\\n<blockquote>\\n<p>corresponding OSI layers: Application + Presentation + Session\\nrelated protocols: HTTP/HTTPS, FTP, Telnet, DNS\\ndata format: data</p>\\n</blockquote>\\n<p>TCP/IP model corresponds to the top three layers (application, presentation, session) in the OSI model. It does not consider the specifics of formatting and presenting data: such functions are the realm of libraries and application programming interfaces.</p>\\n<p>In this layer, applications, or processes, create and transport data to other applications/processes on the same/another host. Processes are addressed via <strong>ports</strong>, which represent services.</p>\\n<p>Application layer protocols do not care about the layers below. They only know (and expect) that these layers provide a stable connection across which to communicate. In reality, though, the applications are usually aware of some key qualities of the transport layer connection, such as the endpoint IP addresses and port numbers.</p>\\n<p>Application layer protocols are often associated with particular client-server applications. Some port numbers are reserved (by the Internet Assigned Numbers Authority) for common services, like port 80 for the HyperText Transfer Protocol server and port 23 for the Telnet server. Clients connecting to a service usually use ephemeral ports, that is, the port numbers are assigned at random and last only for the duration of the transaction in the application.</p>\\n<h3 id=\"transport-layer\">Transport Layer</h3>\\n<blockquote>\\n<p>corresponding OSI layers: Transport\\nrelated protocols: TCP, UDP\\ndata format: segments</p>\\n</blockquote>\\n<p>The transport layer perform host-to-host communications, either on local network or remote network separated by routers. Two important protocols here are <a href=\"https://jennycodes.me/posts/networking-the-osi-model#tcp\">TCP: Transmission Control Protocol</a> and <a href=\"https://jennycodes.me/posts/networking-the-osi-model#udp\">UDP: User Datagram Protocol</a>. They are explained in detail in the last post. The biggest difference between them is that UDP provides unreliable (connectionless) but fast data transmission, while TCP provides reliable (connection-oriented) but slower transmission.</p>\\n<h3 id=\"internet-layer\">Internet Layer</h3>\\n<blockquote>\\n<p>corresponding OSI layers: Networking\\nrelated protocols: IPv4, IPv6\\ndata format: packets</p>\\n</blockquote>\\n<p>In the Internet layer, datagrams are exchanged across network boundaries, based on the Internet Protocol (IP). The Internet Protocol performs two basic functions: <strong>host addressing</strong> and <strong>identification</strong>. Its routing function (sending packets of data from source to destination by forwarding them to the next network router closer to the final destination) enables internetworking, and essentially establishes the Internet.</p>\\n<h4 id=\"ip-address\">IP address</h4>\\n<p>An IP address is a 32-bit number that uniquely identifies a host (computer or other device, such as a printer or router) on a TCP/IP network. A typical IP address looks like this: 192.168.123.132. The Internet Protocol can deliver packets from the source host to the destination host solely based on the IP addresses.</p>\\n<h3 id=\"link-layer-network-interface-layer\">Link Layer / Network Interface Layer</h3>\\n<blockquote>\\n<p>corresponding OSI layers: Datalink + Physical\\nrelated protocols: Ethernet, Frame Relay\\ndata format: frames</p>\\n</blockquote>\\n<p>The <a href=\"https://en.wikipedia.org/wiki/Link_layer\">link layer</a> is the lowest component layer of the Internet protocols, as TCP/IP is designed to be hardware independent. That is, TCP/IP assumes a working network infrastructure that can deliver media level frames on the link, and can be implemented on top of any hardware networking technology.</p>\\n<p>The link layer has a group of communication protocols that only operate on a link a host is physically connected to. It is responsible for physical addressing and access control at MAC sub layer.</p>\\n<p>Now that we have seen both the OSI model and the TCP/IP model, surely we&#39;d know better how to debug if any (unfortunate) network-related situations arise.</p>\\n",
        "status": 1,
        "description": "and what exactly its relationship is with the OSI model",
        "created_at": "2019-07-23T17:49:03.193774",
        "updated_at": "2019-07-23T17:51:06.105981",
        "slug": "the-tcpip-model",
        "medium_url": ""
    },
    {
        "id": 44,
        "title": "[Security] DDoS: Distributed Denial of Service Attack",
        "body": "<p>這次要聊的是一個很重要的議題：資訊安全。由於資訊安全真的是個博大精深的領域，所以這應該會是一個系列文。這篇文章會先介紹資訊安全的基本概念，再來看一個網頁攻擊的經典例子：DDoS 分散式阻斷服務攻擊。</p>\\n\\n<h3 id=\"toc_1\">The CIA Triad: 資訊安全的三個向度</h3>\\n\\n<p>資訊安全（Infosec: Information Security） 在現今的世界中有越來越重要的地位。這個領域討論的是如何讓資訊在保存與傳遞的過程中，不會發生不預期的修改、竄改、毀損、或未經授權的檢視。一個常見的模型將資訊安全分成三大面向：<strong>機密性 Confidentiality</strong>, <strong>完整性 Integrity</strong>,  <strong>可用性 Availability</strong>，下面分別介紹。</p>\\n\\n<h4 id=\"toc_2\">機密性 Confidentiality</h4>\\n\\n<blockquote>\\n<p>authorization</p>\\n</blockquote>\\n\\n<p>這個向度在乎的是「身份是否正確」。只有經過授權的身份、實體或是程序才能夠存取資料。資料有價值：個人資料、信用卡號碼、政府機密文件......，機密性的一個特點是它的破壞是不可逆的：假設今天銀行帳戶資訊被竊取，或是一份電子郵件被偷轉發，資料一旦被公開就再也無法還原成「機密」的狀態了，就算抓到犯人也於事無補。</p>\\n\\n<p>假設今天有一個人向餐廳點了一份蛋炒飯，他要求不要加紅蘿蔔，並且這件事情需要保密。但是傳送訂單的服務生看到了，並且將這件事跟其他人說，於是乎所有人都知道了這個顧客點了一份不加紅蘿蔔的蛋炒飯，這個資訊的機密性就被破壞了。</p>\\n\\n<p>加密（encryption）是最常見用來保護資料機密性的做法。加密確保只有擁有「鑰匙」的人才能夠存取資料。幾乎所有主要的協議都有使用加密，比如說 HTTPS protocol 就是使用網路傳輸安全協定 SSL 與 TLS。</p>\\n\\n<h4 id=\"toc_3\">完整性 Integrity</h4>\\n\\n<blockquote>\\n<p>authenticity</p>\\n</blockquote>\\n\\n<p>這個向度在乎的是「資料是否能夠信任」，是資料的正確與完整性。也就是說，必須確保資料沒有在未經授權、監督的情況下被修改。假如今天有一份「不加紅蘿蔔的蛋炒飯」的訂單送到餐廳，但是送訂單的服務生偷偷把「不加紅蘿蔔」劃掉，於是廚師就依照這被竄改後的訂單做了一份（有紅蘿蔔的）蛋炒飯，送出來的炒飯，就不是顧客原本預期的樣子了，這就是這份交易的「完整性」被破壞的情況。</p>\\n\\n<p>如果今天不只是蛋炒飯被誤加紅蘿蔔，而是銀行資料、購物明細被竄改，那事情就變得有點嚴重了。</p>\\n\\n<p>密碼學（cryptography）就是專門在研究如何確保資訊安全的學問。前面提到的加密也是密碼學的一部份。很常見的做法是將加密前的資料–明文（plaintext）–經由某種演算法加密後變成秘文（ciphertext）；傳遞給對方之後，對方再使用鑰匙將秘文還原成明文。如此一來沒有鑰匙的人就無法存取，或是對資料進行修改。</p>\\n\\n<h4 id=\"toc_4\">可用性 Availability</h4>\\n\\n<blockquote>\\n<p>accessibility</p>\\n</blockquote>\\n\\n<p>可用性在乎的是「資料是否可以穩定存取」。一個擁有高可用性（high availability）的系統能夠應付各種可能造成服務中斷的原因，像是包含電力短缺、硬體故障、系統更新等等，而持續提供資源/服務。今天要介紹的主題：DDoS（Distriubted Denial of Service） 就是一個很知名的可用性攻擊手法。</p>\\n\\n<p>同樣的餐廳點菜例子，假設今天這家有賣蛋炒飯的餐廳常常因為冰箱壞了、員工出走或是老闆忘記開門而不營業，那麼這家餐廳的可用性就很低。另一種情況是，如果今天這家餐廳正常營業，但是突然接到大量惡作劇訂單（假客人）讓這家餐廳變得異常忙碌，在忙著消化大量（假）訂單的同時就無法顧及「不加紅蘿蔔的蛋炒飯」這個真顧客的要求，那麼這位顧客（與其他也想要點餐的真客人）就只能失望的離開了。</p>\\n\\n<p>在網路世界中，可能會是一個網站突然無法連上線，或是一個停止運作的應用程式。這可以造成很嚴重的後果。一個好的習慣是「備份」固定做好備份就可以減少因為硬碟損壞、天然災害等等而造成的損傷。下面也會講一些抵擋攻擊的方法。</p>\\n\\n<h3 id=\"toc_5\">IP Spoofing</h3>\\n\\n<p>開始談 DDoS 之前，我們必須先暸解什麼是 IP spoofing（IP 位址欺騙）。IP Spoofing 是指創造 IP packets（網路上的資料傳遞包裹）但是將這些 packets 的來源地址—source IP—填入其他人的資料。這樣做可以讓攻擊者達成兩個目的：</p>\\n\\n<ol>\\n<li>隱藏自己的身份，讓來源無從被追查。</li>\\n<li>讓回應的包裹導流到其他地方（被假造的 source IP）。</li>\\n</ol>\\n\\n<p>這兩個特徵本身看起來還算無害，但是有心的攻擊者可以利用 IP spoofing 來做 DDoS 攻擊，與更進階的 Amplification Attack。回到蛋炒飯餐廳的例子。今天有一個小明決定他突然想要讓小美吃蛋炒飯，所以他打了電話（送出請求）給餐廳，點了一份蛋炒飯，而當店員問「要送到哪裡」時，小明說了小美的地址。於是，當蛋炒飯準備好，它就會被送到小美的家（spoofed source IP），而不是小明的家，雖然小明才是發出請求的人。可以想像如果今天小明不只訂了一份蛋炒飯，而是一百份、一千萬份，那麼小美的家就會被蛋炒飯淹沒，而不能正常處理其他事情了。</p>\\n\\n<h3 id=\"toc_6\">DDoS: Distributed Denial of Service</h3>\\n\\n<p>上面描述的情況就是阻斷服務攻擊 DoS（Denial of Service）。它的目標只有一個：利用大量的請求癱瘓目標系統，讓目標系統無法正常提供服務或資源。 分散式阻斷服務攻擊 DDoS (Distributed Denial of Service)是 DoS 的進階版。</p>\\n\\n<h4 id=\"toc_7\">DoS vs DDoS</h4>\\n\\n<p>阻斷服務攻擊 DoS 攻擊手法是一對一單挑，哪邊性能比較好哪邊就贏。假設今天攻擊者電腦一秒最多可以發動 100 次攻擊，但是目標電腦一秒可以輕輕鬆鬆處理 10,000 個封包，那麼攻擊就無效了。</p>\\n\\n<p>分散式阻斷服務攻擊 DDoS 不一樣。「分散式」的意思就是「水平擴展」—一台電腦打不贏就用兩台打，兩台電腦打不贏就用 1000 台打，直到數量多到目標電腦招架不住為止。這些被抓進來一起打的電腦不一定是自願的，通常是因為自己系統中有漏洞所以被攻擊者控制的「殭屍」。如此一來，原本一台電腦一秒有 100 個攻擊，1000 台電腦一秒就有 100,000 個攻擊，就算目標電腦還是維持一秒處理 10,000 個封包，還是輸了，因為它只有一個人。</p>\\n\\n<p>另一個 DDoS 比 DoS 更令人害怕的是他發動攻擊的源頭不只有一個了，所以要對付不能像 DoS 一樣直接抓出作亂的源頭並且封鎖，而要使用更進階的方式（比如說 Ingres Filtering）才能夠防堵。</p>\\n\\n<p>暸解了 DoS 與 DDoS 的基本概念，我們現在來看看實際上他們都怎麼被實現的。下面介紹兩種 DDoS 攻擊：SYN Flooding 與 Amplification Attack。</p>\\n\\n<h4 id=\"toc_8\">SYN Flooding: 利用 TCP 協議的 DDoS 攻擊</h4>\\n\\n<p>SYN 洪水攻擊（SYN Flooding）。在伺服器與客戶端建立連線時，若在 network 層的連線方式是使用 TCP（目前主流的連線方式），則會經過一個<a href=\"https://study-ccna.com/tcp-three-way-handshake/\">三次握手（Three-Way Handshake）</a>的步驟。這三次握手的主要目的是讓雙方在交換資料之前確認彼此是自己想要交換資料的對象，使用 ACK (acknowledgment field significant) 與 SYN (synchronize sequence numbers) 兩個控制位元（Control Bits）來確認。</p>\\n\\n<p>SYN Flooding 會故意不回傳確認連線的訊息給伺服器，讓第三次握手失敗，這時伺服器的行為會是不停地重試並且等到一定的時間（SYN timeout）之後才會放棄。可以想見若是這種情形大量出現，對於伺服器會是非常大的負擔。SYN Flooding 難防的是它利用的是 TCP/IP 協議中的漏洞，所以使用 TCP/IP 連線的伺服器都有可能遭受這種威脅。</p>\\n\\n<h4 id=\"toc_9\">DDoS Amplification Attack</h4>\\n\\n<p>DDoS Amplification Attack 是一種讓 DDoS Attack 更上一層樓的攻擊方式。它利用請求封包與回應封包之間的大小差異來進行攻擊。簡單的說，它找到一種方式讓伺服器產生的回應封包比請求的大小還要大，於是可以發出很小的請求就觸發很大的回應，將許多小請求疊加（記得我們的殭屍嗎），並利用 IP spoofing 將回應的封包全部導流到目標伺服器，就可以事半功倍地癱瘓目標伺服器。</p>\\n\\n<p>一個常見的攻擊是 DNS Amplification Attack。這是利用 open DNS resolver 的功能來達到攻擊的目的。每一個機器人都用一個 IP-spoofed 的位址向 open DNS resolvers 發出請求，而這些 open DNS resolvers 就會將處理過後的，「被放大」後的回應封包丟給受害者伺服器。</p>\\n\\n<p>大致上一個 DNS Amplification Attack 的流程有四步：</p>\\n\\n<ol>\\n<li>攻擊者找到一個沒有被保護的節點，並且利用 IP-spoofed 的來源位址送 UDP packets 給一個 DNS recursor。這個被竄改的位址指向受害者的 IP。</li>\\n<li>每一個 UDP packet 都會對一個 DNS resolver 發出請求，這個請求唯一的目的就是能夠讓 response packet 越大越好。實作上常常會看到像是使用 <code>ANY</code> 的參數。</li>\\n<li>DNS resolver 盡責地處理好請求，將回應封包丟給不知情的受害者。</li>\\n<li>受害者的位址被大量的回應封包給淹沒，造成服務中斷，甚至可能影響到網路基礎。</li>\\n</ol>\\n\\n<h4 id=\"toc_10\">Reflector 的角色</h4>\\n\\n<p>Reflector 是無知的幫兇。它們是在網路上提供某種服務/資源的伺服器，比如說 DNS 服務。這些伺服器存在某種漏洞，或是說，攻擊者知道如何操縱這些伺服器，讓它們變成攻擊者拿去對付其他人的傀儡。在 DNS Amplification Attack 中，DNS server 就是 reflector。</p>\\n\\n<h4 id=\"toc_11\">UDP protocol: Amplification Attack 的功臣</h4>\\n\\n<p>幾個常見的 Amplification Attack 包含利用 DNS (Domain Name Service), NTP (Network Time Protocol), SNMPv2 (Simple Network Management Protocol v2) 這些協議的漏洞來進行攻擊。它們的共通點有兩個： </p>\\n\\n<ol>\\n<li>它們都是在 OSI model 中 application 層級的網路協議 </li>\\n<li><strong>它們在 network 層級都是使用 <a href=\"https://jennycodes.me/posts/networking-the-osi-model#udp\">UDP</a> protocol 來傳遞資料</strong>。</li>\\n</li>\\n</ol>\\n\\n<p>如果是使用 TCP，那麼就不會有「放大」的效果產生，因為攻擊發生在互相回傳確認碼的階段，所以請求與回應都只有大概 60 Bytes。UDP 則不一樣。使用 UDP 的雙方在開始傳送資料前不需要先經過握手，因此一個請求只要經過好好設計，就可以讓回應的大小比請求大許多，比如說從 1Gbps 增加到 100s Gbps，所謂事半功倍。現實中，一個 15 bytes 的請求可以導致 750kB 的回應，大約是 51,200 倍的放大，非常有效。</p>\\n\\n<p>一般而言，當一個伺服器的一個阜（port） 接受一個 UDP 封包，會經過兩步驟：</p>\\n\\n<ol>\\n<li>伺服器首先確定該阜是否有應用程式在待命（listening for requests）。</li>\\n<li>如果該阜沒有應用程式在待命，那麼伺服器會回傳一個 ICMP (Internet Control Message Protocol)(ping) 封包，告訴對方它指定的目的地不存在。</li>\\n</ol>\\n\\n<p>故意傳資料給一個伺服器不存在的阜，讓伺服器將 ICMP packet 傳到目標伺服器，這就是一種用 UDP protocol 做的 DDoS Attack.</p>\\n\\n<h4 id=\"toc_12\">DDoS Amplification Attack 實際案例：GitHub</h4>\\n\\n<p>截至目前（2019 年 8 月）為止發生過最嚴重的 DDoS attack 是在 2018 年 2 月 28 號， <a href=\"https://github.blog/2018-03-01-ddos-incident-report/\">Github 網站斷線了五分鐘</a>。這是一個利用 Memcached（一個開源的資料庫分散式快取系統）伺服器做的 DDoS Amplification attack。事件發生的當週 <a href=\"https://new.blog.cloudflare.com/memcrashed-major-amplification-attacks-from-port-11211/\">Cloudflare 正發佈了一個安全漏洞</a>：Memcached 伺服器的預設設定有支援 UDP protocol，而有將 UDP 打開的伺服器很容易成為 reflector 標的。本次事件就是攻擊者找到了這個漏洞，被利用拿來進行 Amplification Attacks 放大攻擊。巔峰時刻，網路流量達到 1.35 Tbps (terabytes per second)，封包數量也達到每秒 126.9 million。</p>\\n\\n<p>Cloudflare 表示 memcached protocol 對於攻擊者而言非常方便，因為它沒有檢查機制，資料可以非常快速的傳送，並且小型的請求就可以造成巨大的回應（到達 1 MB）。在 Github 事件中，這個放大效果甚至達到超過 50,000 倍。</p>\\n\\n<p>攻擊的程序很簡單：首先攻擊者鎖定一個沒有防護的 Memcached server，開始向 port UDP 11211 傳送大量資料，然後攻擊者偽造（spoof）GET 請求的 source IP，將回應導流到 Github IP。</p>\\n\\n<p>Github 首先從網路監控系統中偵測到資料流入（ingres traffic）與流出量（egress traffic）的比例異常，資料流入量超過了 100 Gbps。當下的決定是將流量導到能夠提供更多網路節點的 Akamai，將大概 40 Gbps 的資料從網絡中移走，同時也啟動保護機制，所以這起 DDoS 攻擊持續 20 分鐘後就落幕了。</p>\\n\\n<h3 id=\"toc_13\">Ingress Filtering: 試圖對付 DDoS 的嘗試</h3>\\n\\n<p>修改 source IP 是 <a href=\"https://jennycodes.me/posts/the-tcpip-model\">TCP/IP</a> 與生俱來的設計，因此很難有根絕疑慮的方法，只能盡量將風險降到最低。其中一個常見的方法是 <a href=\"https://en.wikipedia.org/wiki/Ingress_filtering\">Ingress Filtering</a>。Ingress Filtering 是在 <a href=\"https://tools.ietf.org/html/rfc2827\">RFC2728</a> 中建議的 best practice，許多 <a href=\"https://en.wikipedia.org/wiki/Internet_service_provider\">ISP (Internet Service Provider)</a> 現在都有實做。</p>\\n\\n<p>基本原理是這樣：Ingress Filtering 一種放在網路節點（network edge）上的封包過濾（packet filtering）機制，它會檢視每個進來的封包，像是查看是否 source IP 跟 origin 一樣。如果是一個內部網路來的 packet, 卻有一個外部網路的 source IP，那麼很有可能這個 packet 有被 IP-spoofed 了。當它發現了可疑的封包，就會將之拒絕/過濾掉。</p>\\n\\n<p>與 Ingres Filtering 相反的是 Egress Filtering，顧名思義這種方法會檢查所有從該網路發出去的封包，確認他們都有合法的 source header。</p>\\n\\n<h3 id=\"toc_14\">其他抵擋/預防 DDoS 的方法</h3>\\n\\n<blockquote>\\n<p>不要太相信預設設定</p>\\n</blockquote>\\n\\n<p>很多起 DDoS 攻擊之所以能夠得逞就是因為發現了伺服器預設設定的漏洞。像是在 9.4.1 版的 BIND DNS server 預設設定是允許 recursion 的，這讓 amplification attack 變得非常容易。Memcached server 也是一個很好的例子。</p>\\n\\n<blockquote>\\n<p>使用 Anycast</p>\\n</blockquote>\\n\\n<p>大部分的網路傳送是使用 <a href=\"https://en.wikipedia.org/wiki/Unicast\">Unicast</a>，也就是說，每一個網路中的節點（node）都會有自己的一個獨一無二的 IP address。當一個 packet 要從一個地方傳送到另一個地方，會經過很多個路由器（routers）。路由器們會保存一張 IP address 的地圖，當它收到一個要送廣其他地方的 packet，就會試圖將這個 packet 送到下一個離目的地更近的路由器（hop）。我們可以在終端機使用 <code>traceroute</code> 指令來看。</p>\\n\\n<p>Anycast，顧名思義（?），就是一種可以讓多台機器使用同一個 IP address 的方式。它與 Unicast 同樣是一對一（one-to-one）的關係，只是 Anycast 中的接收端是一個網絡中的任何一個點，所以更精確地說是「一對多個中的一」（one to one of many）的關係。今天一個請求進來的時候，Anycast 會依照其地理位置，將它傳遞給離他最近的可用節點。這樣做的好處除了速度之外，也代表當今天如果不幸的這個節點被攻擊了，那麼後續的請求還是不會被切斷，因為資料依然可以傳給下一個最近的節點。這裡有一份對於 <a href=\"https://www.researchgate.net/publication/298792185_Anycast_and_Its_Potential_for_DDoS_Mitigation\">Anycast 如何可以減緩 DDoS 攻擊的研究</a>。</p>\\n\\n<h3 id=\"toc_15\">就這樣</h3>\\n\\n<p>下次應該會講 MITM: Man in the Middle Attack. 下篇文章見！</p>\\n\\n<h3 id=\"toc_16\">Resources</h3>\\n\\n<ul>\\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/Security/\">https://developer.mozilla.org/en-US/docs/Web/Security/</a></li>\\n<li><a href=\"https://raw.githubusercontent.com/rodarima/lsi/master/p2/dnsdrdos.c\">https://raw.githubusercontent.com/rodarima/lsi/master/p2/dnsdrdos.c</a></li>\\n<li><a href=\"https://www.noction.com/blog/ddos-amplification-attacks\">https://www.noction.com/blog/ddos-amplification-attacks</a></li>\\n<li><a href=\"https://www.cloudflare.com/learning/ddos/glossary/ip-spoofing/\">https://www.cloudflare.com/learning/ddos/glossary/ip-spoofing/</a></li>\\n<li><a href=\"https://www.cloudflare.com/learning/ddos/dns-amplification-ddos-attack/\">https://www.cloudflare.com/learning/ddos/dns-amplification-ddos-attack/</a></li>\\n<li><a href=\"https://github.blog/2018-03-01-ddos-incident-report/\">https://github.blog/2018-03-01-ddos-incident-report/</a></li>\\n<li><a href=\"https://www.cloudflare.com/learning/ddos/famous-ddos-attacks/\">https://www.cloudflare.com/learning/ddos/famous-ddos-attacks/</a> </li>\\n<li><a href=\"https://new.blog.cloudflare.com/a-brief-anycast-primer/Information_Security_Basics/Confidentiality,_Integrity,_and_Availability\">https://new.blog.cloudflare.com/a-brief-anycast-primer/Information_Security_Basics/Confidentiality,_Integrity,_and_Availability</a></li>\\n<li><a href=\"https://security.blogoverflow.com/2012/08/confidentiality-integrity-availability-the-three-components-of-the-cia-triad/\">https://security.blogoverflow.com/2012/08/confidentiality-integrity-availability-the-three-components-of-the-cia-triad/</a></li>\\n</ul>\\n\\n",
        "status": 1,
        "description": "資訊安全系列文一：分散式阻斷服務攻擊",
        "created_at": "2019-08-09T05:54:50.193431",
        "updated_at": "2019-08-09T06:03:59.939578",
        "slug": "security-ddos-distributed-denial-of-service-attack",
        "medium_url": "https://medium.com/@jinghua.shih/security-ddos-distributed-denial-of-service-attack-254bae731464"
    },
    {
        "id": 78,
        "title": "[Security] 你該知道所有關於 SSH 的那些事",
        "body": "<p><a href=\"https://jennycodes.me/posts?tag=Security\">網路安全系列文</a>第二篇！今天要介紹一個很重要的工具：SSH (Secure Shell)。對於開發者而言，SSH 這個詞應該很不陌生。當我們想要進入遠端伺服器，通常會下 <code>ssh username@remote_host</code>，連接成功就可以直接讓遠端伺服器執行我們在本機上下的指令。有沒有想過 SSH 是什麼？它是如何讓我們可以這樣看似隨隨便便就進入一個應該是被嚴格保護的伺服器？它怎麼確保你可以登入，而壞人小王不行？怎麼確保連線的時候小王沒有從中<a href=\"https://en.wikipedia.org/wiki/Packet_analyzer\">竊聽</a>、<a href=\"https://en.wikipedia.org/wiki/Telnet#Security\">攔截</a>、<a href=\"https://en.wikipedia.org/wiki/Man-in-the-middle_attack\">竄改資料</a>？話不多說，馬上捲起袖子來看 SSH 到底是如何運作！</p>\\n\\n<h3 id=\"ssh\">SSH 是一個連線加密機制</h3>\\n\\n<p>SSH 的先行者們（<a href=\"https://en.wikipedia.org/wiki/File_Transfer_Protocol\">FTP</a>, <a href=\"https://en.wikipedia.org/wiki/Telnet\">Telnet</a>, <a href=\"https://en.wikipedia.org/wiki/Rlogin\">rlogin</a>, <a href=\"https://en.wikipedia.org/wiki/Remote_Shell\">rsh</a> 等）誕生於一個純真的年代，當時網路的使用還多在軍事與學術界，壞人還沒有開始湧入，因此安全性不是優先考量，就連敏感資料如密碼，也都是大大方方地以明文（plaintext）傳送。</p>\\n\\n<p>SSH 的出現就是為了解決這樣子的情況。安全是 SSH 的賣點。SSH 它讓我們在與遠端電腦（遠端伺服器）連線時，能夠先將訊息加密過後再傳送，並且確保只有「被認可的人」才能夠解密訊息。因此，就算是在一個不安全的網絡裡面，SSH 都能夠確保連線不被竊聽。</p>\\n\\n<p>想當然耳，現在已經很少人使用上述的連線方式了，基本上都被 SSH 取代。尤其像是 <a href=\"#openssh\">OpenSSH</a> 這個開源專案的出現，讓我們還真的找不到什麼理由不用 SSH。</p>\\n\\n<h3 id=\"sshclientservermodel\">SSH 的 Client-Server Model</h3>\\n\\n<p>SSH 使用 <a href=\"https://en.wikipedia.org/wiki/Client–server_model\">client-server 模型</a>，也就是說，要建立一個 SSH 連線，遠端的機器必須跑一個 SSH daemon，而本地機器則要有一個 SSH client 程序。SSH daemon 會預設聽從 TCP port 22 進來的連線，並在認證後提供相對應的環境給使用者。SSH client 則負責使用 SSH protocol 來傳送認證訊息與連線細節給遠端機器。</p>\\n\\n<p>SSH 最常見的使用情況就是開頭提到的遠端連線，不過它同時也支援 tunneling 或是也可以使用 <a href=\"https://en.wikipedia.org/wiki/SSH_File_Transfer_Protocol\">SFTP (SSH File Transfer)</a> 或 <a href=\"https://en.wikipedia.org/wiki/Secure_copy\">SCP (Secure Copy)</a> 來進行檔案傳輸。</p>\\n\\n<p>許多作業系統，包含 macOS, Linux, OpenBSD, FreeBSD 都支援 SSH。</p>\\n\\n<h3 id=\"sshpublickeycrytographypkcrypto\">SSH 與 Public Key Crytography (PK crypto)</h3>\\n\\n<p>SSH 使用 <a href=\"https://en.wikipedia.org/wiki/Public-key_cryptography\">public-key cryptography</a> 來為資料流加密。</p>\\n\\n<p>在一個 public-key 結構中，每一個使用者都有兩把鑰匙：<strong>公鑰（public key）</strong>與<strong>私鑰（secret key）</strong>。私鑰拿來做電子簽名與解密（任何你收到的加密文件），公鑰用來讓別人確認你的簽名的正確性（證明人家收到的，有你的簽名的東西真的是你傳的），還有讓別人將東西加密成只有你自己能（使用私鑰）解密的檔案。</p>\\n\\n<p>假設今天小明想要使用 SSH 傳一個訊息給小美，<em>他們已經互相擁有對方的公鑰了</em>，並且擁有各自的私鑰，此時會有五個步驟：</p>\\n\\n<ol>\\n<li>小明用自己的私鑰將訊息簽名。</li>\\n\\n<li>小明用小美的公鑰將訊息加密。（此時，被加密的訊息連小明也無法還原—只有小美的私鑰可以！）</li>\\n\\n<li>小明將訊息傳給小美。</li>\\n\\n<li>小美將訊息用自己的私鑰解密。</li>\\n\\n<li>小美用小明的公鑰來確認這個訊息是用小明的私鑰簽名的。</li>\\n</ol>\\n\\n<p>是不是很聰明！</p>\\n\\n<p>雖然比起<a href=\"https://en.wikipedia.org/wiki/Block_cipher\">分組加密／區塊加密（Block Cipher）</a>（一種對稱金鑰演算法，使用同一組鑰匙來做加密與解密的動作），PK crypto 聽起來很冗，並且比起其他演算法需要更多時間與 CPU，但卻是必要的麻煩，因為它讓我們可以傳送加密訊息而不需要先交換任何秘密資訊。</p>\\n\\n<h3 id=\"\">仍然需要注意的是</h3>\\n\\n<p>如何<strong>驗證未知的公鑰</strong>。上面的例子聽起來萬無一失，但是假設今天小明與小美還沒有交換公鑰，他們就必須要先連線傳送公鑰給對方。如果壞人小王在小明要把公鑰傳給小美時調包，換成小王自己的公鑰，這時與小美建立「安全連線」的人，就會是小王而不是小明了 😱 SSH 能夠提供的保護只在確保公鑰的擁有者同時擁有相對應的私鑰，但是不能保證擁有這個公私鑰組合的人是不是壞人。這就是著名的<a href=\"https://en.wikipedia.org/wiki/Man-in-the-middle_attack\">「在中間的人攻擊」(man-in-the-middle-attack)</a>。這個弱點可以用認證系統（authentication），像是 <a href=\"https://en.wikipedia.org/wiki/Public_key_infrastructure\">PKI (Public Key Infrastructure)</a> 來抵擋（系列下篇文章應該會好好講這個）。 </p>\\n\\n<h3 id=\"rsavsdsa\">加密演算法 RSA vs DSA</h3>\\n\\n<p>當我們在使用 SSH 時，很常會看到這兩個名詞出現。RSA 與 DSA 都是公鑰加密演算法（public key encryption algorithms），RSA ((Rivest–Shamir–Adleman) 是最早出現的加密演算法之一，之前受到專利保護，目前已經過效期了所以所有人都可以使用。所有的 SSH client 都支援 RSA，不過因為它很久了，所以建議使用 4096 bits 的鑰匙長度來加密（預設是 2048 bits），比較安全。DSA (Digital Signature Algorithm) 是另一個常被使用的演算法，不過由於該演算法的特性（使用的機制與鑰匙長度規定只能是 1024 bits），目前建議（也是預設）的演算法還是 RSA。</p>\\n\\n<p>除了這兩者之外，還有像是 <a href=\"https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm\">ECDSA</a>, <a href=\"https://en.wikipedia.org/wiki/Curve25519\">ED22519</a> 等比較新的演算法也都有支援了。 </p>\\n\\n<h3 id=\"openssh\">OpenSSH</h3>\\n\\n<p>SSH 本身是一個協定（protocol），而 <a href=\"https://www.openssh.com\">OpenSSH</a> 是一個 SSH 協定的開源實作，也可以說是遵守 SSH 的一組工具。<code>sshd</code> 是 OpenSSH 的 server component，當出現一個連線請求，<code>sshd</code> 會根據 client 來建立對應的連線。比如說，如果今天是一個 ssh client，那 OpenSSH server 就會建立一個遠端操控環境，如果今天是一個 scp (secure copy) client，那 OpenSSH server 就會建立一個檔案的 secure copy。</p>\\n\\n<h3 id=\"sshvsssl\">SSH vs SSL</h3>\\n\\n<p>SSH 與 SSL 名字實在是太像了，而且做的事情也挺像，都是為了確保兩端連線安全而產生，但他們其實還是不一樣的概念，這邊就來稍微介紹一下 SSL。</p>\\n\\n<p>先澄清一下，SSL (Secure Sockets Layer)，實際上已經被 <a href=\"https://en.wikipedia.org/wiki/Transport_Layer_Security\">TLS (Transport Layer Security)</a> 取代了（TLS 1.0 有時也被視為 SSL 3.1）。維基百科上甚至已經直接將兩者合併在 <a href=\"https://en.wikipedia.org/wiki/Transport_Layer_Security\">TLS 的條目</a>下了。為何 SSL 不再繼續被使用了呢？因為它是很早就出現的一套網路連線防護機制，在駭客們努力不懈的堅持之下，SSL 已經差不多被破解完了，所以基本上非常透氣，防禦力趨近於零。不過慣性使然，許多人仍然使用 SSL 來稱呼這套機制。</p>\\n\\n<p>SSL/TLS 其實大家都不陌生，<a href=\"https://en.wikipedia.org/wiki/HTTPS\">HTTPS (HyperText Transfer Protocol Secure)</a> （還有在網址前面那個 🔒 的圖案）是建立網站與訪客之間的安全連線的協定，取代了 HTTP 的不安全連線。</p>\\n\\n<blockquote>\\n  <p>順帶一提，如果你還沒，請養成好習慣在進入任何網站時先確保網址的開頭是 https 而不是 http。</p>\\n</blockquote>\\n\\n<p>SSL/TLS 是 HTTPS 的幕後功臣。它們讓瀏覽器（客戶端）連上網站（伺服器端）的時候，先進行一個<a href=\"https://www.ssl.com/article/ssl-tls-handshake-overview/\">握手的儀式</a>，並且使用 <a href=\"https://en.wikipedia.org/wiki/Certificate_authority\">CA (Certificate Authority)</a> 來進行身分確認。</p>\\n\\n<p>有 CA 的參與也是 SSL/TLS 與 SSH 最大的差異。另外一個差異是 SSL/TLS 是被使用在資料傳輸，而 SSH 是用來執行指令（通常就是用來登入遠端電腦）。</p>\\n\\n<p>說到 TLS，<a href=\"https://ietf.org/blog/tls13/\">TLS 1.3</a> 即將出世了。目前看到除了安全性升級之外，也將原本 asymmetric encryption 常常被詬病的低效率問題開刀，將客戶端與與伺服器端建立安全連線之前的身份確認程序簡化到一個來回（握一次手就好了），大大提升速度。</p>\\n\\n<h3 id=\"sshgithub\">所以說到底怎麼用 SSH？用 GitHub 當例子</h3>\\n\\n<p>對於 SSH 實際的指令，Digital Ocean 有一篇<a href=\"https://www.digitalocean.com/community/tutorials/ssh-essentials-working-with-ssh-servers-clients-and-keys#generating-and-working-with-ssh-keys\">詳細的教學</a>，想要好好暸解 SSH 指令們的人可以參考。</p>\\n\\n<p>以下就拿 GitHub 來當例子，有個實際的東西比較好將抽象概念印在腦海裡。GitHub 大概是每個開發者都會需要打交道的平台吧。當我們使用 <code>git push</code> 將在自己電腦中的 commit 們推到 GitHub 上時，其實背後就是使用了 SSH 連線（還記得當初設置帳號有經過一個很麻煩的 SSH 設定步驟嗎）。但總而言之，就是因為 SSH，我們可以不用每次都輸入密碼就連線到遠端的 repository。現在知道為什麼了吧？<a href=\"https://help.github.com/en/github/authenticating-to-github/connecting-to-github-with-ssh\">GitHub 官方教學在這</a>。以下是幾個重要的步驟：</p>\\n\\n<ol>\\n<li><p>產生一組 public &amp; private keys</p>\\n\\n<pre><code class='language-shell-session'>// 白話文：產生一組 ssh keys，使用 RSA 演算法加密，鑰匙長度 4096 bits，使用 your_email@example.com 作為這組 keys 的標籤。\\n$ ssh-keygen -t rsa -b 4096 -C \"your_email@example.com\"\\n&gt; Generating public/private rsa key pair.\\n\\n// 接下來會問你鑰匙存放的位置還有 pass phrase，可以都直接用預設即可。\\n&gt; file in which to save the key (/Users/you/.ssh/id_rsa): [Press enter]\\n&gt; Enter passphrase (empty for no passphrase): [Type a passphrase]\\n&gt; Enter same passphrase again: [Type passphrase again]\\n</code></pre></li>\\n\\n<li><p>把產生的 public &amp; private keys 加入 ssh-agent (一個作業系統內建幫忙管理 ssh keys 的背景程式，讓使用者只需要輸入一次密碼往後就可以用密鑰自動登入)</p>\\n\\n<ul>\\n<li>先將 ssh-agent 在背景啟動。會回傳該程式的 PID (process ID)。</li></ul>\\n\\n<pre><code class='language-shell-session'>$ eval \"$(ssh-agent -s)\"\\n&gt; Agent pid 59566\\n</code></pre>\\n\\n<ul>\\n<li>如果使用 macOS Sierra 10.12.2 之後的版本，要去修改 ~/.ssh/config，讓系統可以自動把鑰匙加入 ssh-agent 還有儲存 passphrase。</li></ul>\\n\\n<pre><code class='language-shell-session'>Host *\\n  AddKeysToAgent yes\\n  UseKeychain yes\\n  IdentityFile ~/.ssh/id_rsa\\n</code></pre>\\n\\n<ul>\\n<li>將 SSH private key 存進 ssh-agent 裡面。</li></ul>\\n\\n<pre><code class='language-shell-session'>$ ssh-add -K ~/.ssh/id_rsa\\n</code></pre></li>\\n\\n<li><p>將 public key 放到 Github 的 server 上。<a href=\"https://help.github.com/en/github/authenticating-to-github/adding-a-new-ssh-key-to-your-github-account\">步驟在這請直接參考</a>。</p></li>\\n</ol>\\n\\n<blockquote>\\n  <p>小試身手：為什麽我們會需要把 public key 放到 GitHub server 上面呢？如果你有從上面好好看下來，應該會覺得很簡單。如果答不出來，那...那只好繼續看下去。</p>\\n  \\n  <p>自問自答：因為在我們的例子中，GitHub 就是我們（clinet）想要連到的 remote server。要使用 SSH 連線，首先就是要讓那個伺服器知道你是一個合法的使用者。如果沒有將 public key 放在 remote server 上，那麼就算我們將加密的訊息傳過去了，這個伺服器還是不會知道要如何解密訊息。</p>\\n</blockquote>\\n\\n<p>如此一來，每當我們要送訊息（指令）給 GitHub (remote server) 時，我們就可以</p>\\n\\n<ol>\\n<li>用我們的私鑰加密指令。</li>\\n\\n<li>用 Github 的公鑰加密指令。</li>\\n\\n<li>傳送指令到 GitHub server。</li>\\n\\n<li>GitHub server 用它自己的私鑰解密。</li>\\n\\n<li>GitHub server 用我們的公鑰來驗證我們的身份。</li>\\n</ol>\\n\\n<p>這一切都是我們的 ssh client 幫我們自動完成，所以對我們而言我們可以直接使用。</p>\\n\\n<h3 id=\"-1\">就這樣</h3>\\n\\n<p>暸解 SSH，就會發現很多事情豁然開朗（程式方面啦），並且終於可以很帥的說出「我 ssh 進入 server 幫你喬一下」然後完全知道自己在說什麼了！</p>\\n\\n<h3 id=\"reference\">Reference</h3>\\n\\n<ul>\\n<li>https://en.wikipedia.org/wiki/Secure_Shell</li>\\n\\n<li>https://www.ssl.com/article/ssl-tls-handshake-overview/</li>\\n\\n<li>https://www.ssl.com/article/tls-1-3-is-here-to-stay/</li>\\n\\n<li>https://www.digitalocean.com/community/tutorials/ssh-essentials-working-with-ssh-servers-clients-and-keys#generating-and-working-with-ssh-keys</li>\\n</ul>",
        "status": 1,
        "description": "是什麼、怎麼用、要小心什麼",
        "created_at": "2019-12-09T05:29:46.261781",
        "updated_at": "2019-12-22T07:25:53.735767",
        "slug": "security-ssh",
        "medium_url": ""
    },
    {
        "id": 40,
        "title": "GraphQL with Ruby on Rails: The Big Picture",
        "body": "<p></p>\\n<blockquote>This is the first part in the <strong class=\"markup--strong markup--blockquote-strong\">GraphQL with Ruby on Rails</strong> series.</blockquote>\\n<p>As a server developer intern at PicCollage, I, quite happily, have been working on upgrading our codebase to match the latest version (1.9.4) of <a href=\"https://github.com/rmosolgo/graphql-ruby\" data-href=\"https://github.com/rmosolgo/graphql-ruby\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">graphql-ruby</a> library. This library, as the name suggests, is the Ruby implementation of <a href=\"https://graphql.org/\" data-href=\"https://graphql.org/\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">GraphQL</a>.</p>\\n<p>Part of our API uses GraphQL, and since I on-boarded I have been curious about (among other ten million things) how GraphQL really works, so much so that I wrote an article about it as an attempt to understand more. Now I officially have the right to work with GraphQL and read up on it, it is time to finally figure out how all the pieces come together.</p>\\n<p>After some exploring and stumbling, I realized (rather belatedly) I was missing the the bigger picture. I knew what a <em class=\"markup--em markup--p-em\">schema</em> is and what <em class=\"markup--em markup--p-em\">types</em> are, but how does GraphQL fit in the whole server structure? I could not answer that. It took me one week to re-figure that out and another week to be able to work properly with it.</p>\\n<h3>Two Things To Keep In Mind</h3>\\n<p>These are the two things that might be quite obvious but really helped me a lot when I was studying GraphQL.</p>\\n<h4>It is not that different from REST.</h4>\\n<p>One misleading idea about GraphQL is this: Graphql and REST (what has been the mainstream API design for decades) are very different paradigms. I believed that for a long time and it threw me into a mindset that my existing knowledge on the REST mechanisms cannot apply here, so everything became a blur of unknown to me when I tried to tackle GraphQL. <strong class=\"markup--strong markup--p-strong\">But they are really not that different.</strong> If we take a few steps back and go through the steps in the server from receiving the request to sending back the response (which we will do in a moment), without worrying about the details, GraphQL would become almost intuitive.</p>\\n<h4>GraphQL is the Controller.</h4>\\n<p>If we try to think of GraphQL in the MVC (Model-View-Controller) diagram, it would be the role of a controller. GraphQL is responsible for parsing the request, interacting with the model and formatting the response to be sent back, just like what a controller does.</p>\\n<h3>From Request to Response: The Overall Process</h3>\\n<p>In <a href=\"https://jennycodes.me/posts/%E5%BE%9E%E9%BB%9E%E4%B8%80%E5%80%8B-url-%E5%88%B0%E7%9C%8B%E5%88%B0%E9%A0%81%E9%9D%A2%E4%B8%AD%E9%96%93%E7%99%BC%E7%94%9F%E4%BA%86%E4%BB%80%E9%BA%BC%E4%BA%8B%E4%B8%8B%E9%9B%86\" data-href=\"https://jennycodes.me/posts/%E5%BE%9E%E9%BB%9E%E4%B8%80%E5%80%8B-url-%E5%88%B0%E7%9C%8B%E5%88%B0%E9%A0%81%E9%9D%A2%E4%B8%AD%E9%96%93%E7%99%BC%E7%94%9F%E4%BA%86%E4%BB%80%E9%BA%BC%E4%BA%8B%E4%B8%8B%E9%9B%86\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">this post</a> I have briefly explained the steps a Ruby on Rails application processes requests. Briefly, the <a href=\"https://guides.rubyonrails.org/routing.html\" data-href=\"https://guides.rubyonrails.org/routing.html\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">router</a> is the gate keeper responsible for the despatch of incoming requests. The router parses the url and sends the request to a <strong class=\"markup--strong markup--p-strong\">controller</strong>’s action. The controller then interact with the <strong class=\"markup--strong markup--p-strong\">model</strong> and the <strong class=\"markup--strong markup--p-strong\">view</strong> to gather necessary information, before packing everything up and send a response back.</p>\\n<p>We can think of the Rails router as the counter in a restaurant. When customer sends the order(url), the counter would send the order to different chefs (controllers). Chefs are responsible for collecting the ingredients (models), cook them up, and send them to the plate presenters (views) for the final brush up.</p>\\n<p>With GraphQL, instead of going through the Model-View-Controller diagram, when the Rails router has parsed the incoming requests, it sends the request to the GraphQL server instead of the controller. In our restaurant analogy it would be the counter sends the order to a different restaurant.</p>\\n<p>Inside the GraphQL server, the request goes through three phases: <strong class=\"markup--strong markup--p-strong\">parse</strong>, <strong class=\"markup--strong markup--p-strong\">validate</strong> and <strong class=\"markup--strong markup--p-strong\">execute,</strong> and a JSON response is returned. Just like in a typical REST structure a response is returned by the controller (either in the html format or in JSON format).</p>\\n<h4>Three Phases in GraphQL</h4>\\n<p>As just mentioned, every query (request, but in GraphQL we call it query–because it IS basically a query) goes through three phases. First, the query is <em class=\"markup--em markup--p-em\">parsed</em> into an an <a href=\"https://en.wikipedia.org/wiki/Abstract_syntax_tree\" data-href=\"https://en.wikipedia.org/wiki/Abstract_syntax_tree\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">AST (Abstract Syntax Tree)</a>. Then the AST is <em class=\"markup--em markup--p-em\">validated</em> against the schema (checking the query syntax and fields’ existence). Lastly, the runtime traverses down (up?) from the root of the tree, and with the help of <strong class=\"markup--strong markup--p-strong\">resolvers</strong>, collects up the results and send back a response.</p>\\n<h4>The Traversing of the Tree</h4>\\n<p>When the runtime starts executing the query, the first thing it does is detecting which of the <a href=\"https://graphql.org/learn/queries/#operation-name\" data-href=\"https://graphql.org/learn/queries/#operation-name\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">three operation types</a> (query, mutation, subscription) the query belongs. Then following the query tree structure, the runtime one by one checks further into the leaves, until it hits the end. At each step, there is a <code class=\"markup--code markup--p-code\">resolver</code> involved, who gathers the desired information for that specific field in the query. When the query is parsed through, and the results are collected, GraphQL packs up and sends back the response.</p>\\n<h4>What Does a Valid Query Look Like</h4>\\n<pre class='language-graphql'><code>query {\\n  category(key: \"summer\") {\\n    name\\n  }\\n}\\n</code></pre>\\n<p>A query looks like this. Here, we first specify which of the three operation types this query is going to be. We can omit the <code class=\"markup--code markup--p-code\">query</code> keyword here because this is the default. The rest simply translates as ‘Give me the name of the category whose key has the value “summer”’. This query will be used throughout the following sections.</p>\\n<h3>Using the GraphQL-Ruby Gem</h3>\\n<p>Like many well-designed and meticulous architectures, <a href=\"https://graphql-ruby.org/\" data-href=\"https://graphql-ruby.org/\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">GraphQL Ruby</a>–the Ruby implementation of GraphQL–compartmentalizes different functionalities into different classes.</p>\\n<h4>The Schema File: Where it All Begins</h4>\\n<p>If you have been searching around, you will know the <code class=\"markup--code markup--p-code\">schema</code> provides you the information of the possible types and fields in a query. With this in mind, you may be a little bit bewildered when you see the content of <code class=\"markup--code markup--p-code\">GraphQL::Schema</code> class.</p>\\n<pre class='language-rb'><code class='language-rb'># app/graphql/root_schema.rb\\nclass RootSchema < GraphQL::Schema\\n  query QueryType\\nend\\n</code></pre>\\n<p>That’s it. PicCollage’s real schema is really no more complex than that. Instead of expecting to see all the possible types and fields combination in this file, it is better if we think of a schema file as an <strong class=\"markup--strong markup--p-strong\">entry point</strong> in this map. We start from here, whose only line, <code class=\"markup--code markup--p-code\">query QueryType</code>, tells us the class for our query operation type is <code class=\"markup--code markup--p-code\">QueryType</code>. Let us see the <code class=\"markup--code markup--p-code\">QueryType</code> class now.</p>\\n<h4>QueryType: An Operation Type</h4>\\n\\n<pre class='language-rb'>\\n<code class='language-rb'># app/graphql/types/query_type.rb\\nclass QueryType < GraphQL::Schema::Object\\n  description 'the root query'\\n\\n  field :category, CategoryType, null: true do\\n    argument :name, String, required: false\\n    argument :key, String, required: false\\n  end\\n\\n  def category(**args)\\n    QueryResolver.category(object, args, context)\\n  end\\nend\\n</code></pre>\\n\\n<p>This is the simplified version of a <code>QueryType</code> class, with only one field and some essential elements.</p>\\n<p>First thing to note that a <code class=\"markup--code markup--p-code\">query</code> is a type/object, just like you may have a <code class=\"markup--code markup--p-code\">user</code> type, so it inherits class <code class=\"markup--code markup--p-code\"><a href=\"https://www.rubydoc.info/gems/graphql/GraphQL/Schema/Object\" data-href=\"https://www.rubydoc.info/gems/graphql/GraphQL/Schema/Object\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">GraphQL::Schema::Object</a></code> and is placed inside the /types folder. From there we see a declaration of <code class=\"markup--code markup--p-code\">field</code> followed by some arguments plus a block.</p>\\n<p>The first argument <code class=\"markup--code markup--p-code\">:category</code> is the field’s name, by which a query can call (like we just did). The second argument <code class=\"markup--code markup--p-code\">CategoryType</code> is the return type of this field. We will soon see that this links us to another GraphQL object class. The third argument is an option hash, inside it we passed <code class=\"markup--code markup--p-code\">null: true</code>, meaning we accept a null return value for this field.</p>\\n<p>Inside the block there are two arguments. These are the arguments to be provided with the query. In this case, you can choose to provide a <code class=\"markup--code markup--p-code\">name</code> or a <code class=\"markup--code markup--p-code\">key</code> of the category you are querying, both are of type <code class=\"markup--code markup--p-code\">String</code>.</p>\\n<p>Below the field definition is the method with the name <code class=\"markup--code markup--p-code\">category</code>. This is our <strong class=\"markup--strong markup--p-strong\">resolver</strong> for the field. GraphQL automatically looks into the method that has the same name with the field to look for the values the query is asking. Here, it directs us to class <code class=\"markup--code markup--p-code\">QueryResolver</code> with arguments <code class=\"markup--code markup--p-code\">object</code>, <code class=\"markup--code markup--p-code\">args</code>, and <code class=\"markup--code markup--p-code\">context</code>. Note that <code class=\"markup--code markup--p-code\">object</code> and <code class=\"markup--code markup--p-code\">context</code> are implicitly provided by the GraphQL server, and <code class=\"markup--code markup--p-code\">args</code> are the arguments specified in the <code class=\"markup--code markup--p-code\">field</code> definition above (in this case it may be either <code class=\"markup--code markup--p-code\">:name</code>, <code class=\"markup--code markup--p-code\">:key</code> or nothing at all).</p>\\n<p>We will dive deeper into resolvers in the following post. Let us look at the object type <code class=\"markup--code markup--p-code\">CategoryType</code> now.</p>\\n<h4>CategoryType: An Object Type</h4>\\n<pre class='language-rb'>\\n<code class='language-rb'># app/graphql/types/category_type.rb\\n\\nclass CategoryType < GraphQL::Schema::Object\\n  field :key, String, null: true\\n  field :name, String, null: false\\n  field :icon_url, String, null: true\\nend\\n</code></pre>\\n<p>Again this is a simplified version. Here, we see all three fields in this <code class=\"markup--code markup--p-code\">CategoryType</code> are of type <code class=\"markup--code markup--p-code\">String</code>, one of the built-in <a href=\"https://graphql.org/learn/schema/#scalar-types\" data-href=\"https://graphql.org/learn/schema/#scalar-types\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">scalar type</a>. This means we have hit the leaves in this tree. After the fields are resolved (values are collected), GraphQL will send back the response.</p>\\n<p>Now we have officially walked through the essential parts of the GraphQL server. In the next post we will look (a lot) closer into the resolvers.</p>\\n<h3>References (and Good Resources)</h3>\\n<div>\\n<a href=\"https://medium.com/paypal-engineering/graphql-resolvers-best-practices-cd36fdbcef55\" data-href=\"https://medium.com/paypal-engineering/graphql-resolvers-best-practices-cd36fdbcef55\" class=\"markup--anchor markup--mixtapeEmbed-anchor\" title=\"https://medium.com/paypal-engineering/graphql-resolvers-best-practices-cd36fdbcef55\"><strong class=\"markup--strong markup--mixtapeEmbed-strong\">GraphQL Resolvers: Best Practices</strong><br>medium.com</a><a href=\"https://medium.com/paypal-engineering/graphql-resolvers-best-practices-cd36fdbcef55\" class=\"js-mixtapeImage mixtapeImage u-ignoreBlock\" data-media-id=\"419f81d02c3026b861088e3f4d5abd12\" data-thumbnail-img-id=\"1*fMLqM5yV0HUWBGGYK7beLw.png\" style=\"background-image: url(https://cdn-images-1.medium.com/fit/c/320/320/1*fMLqM5yV0HUWBGGYK7beLw.png);\"></a>\\n</div>\\n<div>\\n<a href=\"https://github.com/Shopify/graphql-design-tutorial/blob/master/TUTORIAL.md\" data-href=\"https://github.com/Shopify/graphql-design-tutorial/blob/master/TUTORIAL.md\" class=\"markup--anchor markup--mixtapeEmbed-anchor\" title=\"https://github.com/Shopify/graphql-design-tutorial/blob/master/TUTORIAL.md\" rel=\"nofollow\"><strong class=\"markup--strong markup--mixtapeEmbed-strong\">Shopify/graphql-design-tutorial</strong><br>github.com</a><a href=\"https://github.com/Shopify/graphql-design-tutorial/blob/master/TUTORIAL.md\" class=\"js-mixtapeImage mixtapeImage u-ignoreBlock\" data-media-id=\"45907aa0bc95c41964283aede1482b04\" data-thumbnail-img-id=\"0*QF8NbLCtY0jASL7W\" style=\"background-image: url(https://cdn-images-1.medium.com/fit/c/320/320/0*QF8NbLCtY0jASL7W);\"></a>\\n</div><p>文章同步發表於 <a href=\"https://medium.com/@jinghua.shih\">Medium</a>。",
        "status": 1,
        "description": "A working example on using GraphQL with Ruby on Rails",
        "created_at": "2019-05-22T12:07:31.70496",
        "updated_at": "2019-12-22T07:45:30.891003",
        "slug": "graphql-with-ruby-on-rails-the-big-picture",
        "medium_url": "https://medium.com/@jinghua.shih/graphql-with-ruby-on-rails-the-big-picture-83acf28b1e4a"
    },
    {
        "id": 41,
        "title": "GraphQL with Ruby on Rails: Resolvers",
        "body": "<p></p>\\n<figure class=\"text-center\"><img class=\"lazy img-fluid\" data-src=\"https://cdn-images-1.medium.com/max/1600/1*kSMqZfFjHJkWIMpLbFR9zQ.png\"><figcaption class=\"imageCaption\">snapshot of a working example of GraphQL’s type</figcaption></figure><p>→ <a href=\"https://tech.pic-collage.com/graphql-with-ruby-on-rails-the-big-picture-83acf28b1e4a\" data-href=\"https://tech.pic-collage.com/graphql-with-ruby-on-rails-the-big-picture-83acf28b1e4a\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">Part I: The Big Picture</a></p>\\n<p>The hardest part of the GraphQL learning journey, in my humble opinion, is to understand <strong class=\"markup--strong markup--p-strong\">Resolvers</strong>. Last time resolvers are only briefly introduced,</p>\\n<p>Here is one way I find extremely useful to think about resolvers:</p>\\n<h3>Resolver is the Controller</h3>\\n<p>Now, I know I mentioned last time that the Controller role, in the context of the whole server, should be <em class=\"markup--em markup--p-em\">GraphQL itself</em>. But remember how we compared the server to a restaurant? When the Rails router (counter) receives a request (order), it sends the request to the corresponding controller(cook). If the request is to be sent to GraphQL, however, the request would be transferred to the GraphQL server (an outsourced restaurant) for the following proceedings.</p>\\n<p>We can imagine that when the request goes to the GraphQL server, GraphQL would have its own set of cooks to fetch and manipulate the data (prepare the dishes). Resolvers are those cooks. When GraphQL finishes executing, the response will be sent back to the application server. The client would not know its request is handled by whom or how it is processed.</p>\\n<p>If there is only one thing for you to take away in this article, I hope this is it. Next, let us see how resolvers are used in a Ruby implementation.</p>\\n<h3>Four Ways to Construct a Resolver (with GraphQL-Ruby gem)</h3>\\n<blockquote>1. Let it be (implicit resolver)</blockquote>\\n<blockquote>2. Same-name definition</blockquote>\\n<blockquote>3. Independent Ruby Class</blockquote>\\n<blockquote>4. GraphQL Resolver Class</blockquote>\\n<p>A modified example of an object/type <code class=\"markup--code markup--p-code\">CategoryType</code>:</p>\\n<figure class=\"text-center\"><script src=\"https://gist.github.com/jenny-codes/288a10ac60b43befd344650ed4b19464.js\"></script><figcaption class=\"imageCaption\"><a href=\"https://gist.github.com/jenny-codes/288a10ac60b43befd344650ed4b19464\" data-href=\"https://gist.github.com/jenny-codes/288a10ac60b43befd344650ed4b19464\" class=\"markup--anchor markup--figure-anchor\" rel=\"nofollow noopener\" target=\"_blank\">https://gist.github.com/jenny-codes/288a10ac60b43befd344650ed4b19464</a></figcaption></figure><p>It is mostly the same as the working example snapshot at the beginning, except that I took out some unrelated complications and modified some modified some resolver methods for illustrating purpose. In this example each of the four fields is using one of the four resolver methods.</p>\\n<h4>1. Let it be (Implicit Resolver)</h4>\\n<p>This is the easiest. When a query sees a field, it automatically tries to resolve a field when the following conditions are met:</p>\\n<ol>\\n<li name=\"ac3e\" id=\"ac3e\" class=\"graf graf--li graf-after--p\">The field is one of the <a href=\"https://graphql.org/learn/schema/#scalar-types\" data-href=\"https://graphql.org/learn/schema/#scalar-types\" class=\"markup--anchor markup--li-anchor\" rel=\"nofollow noopener\" target=\"_blank\">scaler types</a>.</li>\\n<li name=\"89b1\" id=\"89b1\" class=\"graf graf--li graf-after--li\">There is a method or hash key with the same name in the <code class=\"markup--code markup--li-code\">object</code> argument.</li>\\n</ol>\\n<p>This is what happens with the field <code class=\"markup--code markup--p-code\">key</code> in our example. It is a scalar type (String), and we assume the object respond to either <code class=\"markup--code markup--p-code\">object.key</code> or <code class=\"markup--code markup--p-code\">object[‘key']</code> (or else an error would occur), so the runtime will implicitly resolve the field without us providing a specific resolver.</p>\\n<h4>2. Same-Name Definition</h4>\\n<p>If we define a method that has the same name with the field, GraphQL will look into this method to resolve the field. In this example, <code class=\"markup--code markup--p-code\">name</code> method is the resolver for field <code class=\"markup--code markup--p-code\">name</code>. That is, the runtime will get the value of <code class=\"markup--code markup--p-code\">name</code> field by calling <code class=\"markup--code markup--p-code\">object.display_name</code>.</p>\\n<h4>3. Independent Ruby Class</h4>\\n<p>To be precise, this can actually be seen as an extension of the same-name definition resolver, except the logic is put inside a class/module of its own. The example here is the field <code class=\"markup--code markup--p-code\">icon_url</code>. The runtime still goes to the eponymous method first, which takes control to the <code class=\"markup--code markup--p-code\">QueryResolver</code> class</p>\\n<p>which takes it to the <code class=\"markup--code markup--p-code\">category</code> action of object. The return value of this action will be the object to be parsed against <code class=\"markup--code markup--p-code\">CategoryType</code>, the value of the second argument in the field definition.</p>\\n<p>The benefit of this structure is separation of concerns: the interface (schema) does not need to know the business logic (resolver), and</p>\\n<h4>4. GraphQL Resolver Class</h4>\\n<p>We need to make this clear that <a href=\"https://github.com/rmosolgo/graphql-ruby/blob/master/guides/fields/resolvers.md\" data-href=\"https://github.com/rmosolgo/graphql-ruby/blob/master/guides/fields/resolvers.md\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">the document</a> strongly advises AGAINST resorting to this method. Two main downsides: (1) [Coupling] It is coupled to GraphQL, which makes testing harder. (2) [Dependency] It inherits from the GraphQL-Ruby library, so if the library changes its code we might need to update ours accordingly.</p>\\n<p>But if we really have a good reason to use the resolver class, here is an example:</p>\\n<figure class=\"text-center\"><script src=\"https://gist.github.com/jenny-codes/bebc204b01a81271a1c41c772950e36c.js\"></script><figcaption class=\"imageCaption\"><a href=\"https://gist.github.com/jenny-codes/bebc204b01a81271a1c41c772950e36c\" data-href=\"https://gist.github.com/jenny-codes/bebc204b01a81271a1c41c772950e36c\" class=\"markup--anchor markup--figure-anchor\" rel=\"nofollow noopener\" target=\"_blank\">https://gist.github.com/jenny-codes/bebc204b01a81271a1c41c772950e36c</a></figcaption></figure><p>We will simply inherit <code class=\"markup--code markup--p-code\">GraphQL::Schema::Resolver</code> and implement <code class=\"markup--code markup--p-code\">resolver</code> method. GraphQL will take care of the rest.</p>\\n<h3>Recap</h3>\\n<p>We have learned that resolvers are how GraphQL knows where to fetch the data. A resolver’s job is like a controller’s in the GraphQL server, which is itself like a controller in the application. <a href=\"https://graphql-ruby.org/\" data-href=\"https://graphql-ruby.org/\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">GraphQL-Ruby</a> gives us a flexibility to build a resolver with one of the four choices. We will try not to use the last method unless absolutely necessary.</p>\\n<p>This is it. If you are still feeling unsatisfied, feel free to look into <a href=\"https://github.com/Shopify/graphql-design-tutorial/blob/master/TUTORIAL.md\" data-href=\"https://github.com/Shopify/graphql-design-tutorial/blob/master/TUTORIAL.md\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">Shopify’s GraphQL tutorial</a>–another well-written introduction to GraphQL with Ruby on Rails!</p><p>文章同步發表於 <a href=\"https://medium.com/@jinghua.shih\">Medium</a>。",
        "status": 1,
        "description": "the second part of GraphQL with Ruby on Rails",
        "created_at": "2019-05-31T12:56:10.311184",
        "updated_at": "2020-02-02T05:19:30.423772",
        "slug": "graphql-with-ruby-on-rails-resolvers",
        "medium_url": "https://medium.com/@jinghua.shih/graphql-with-ruby-on-rails-resolvers-110e828772b8"
    },
    {
        "id": 79,
        "title": "[Security] SSL—HTTPS 背後功臣",
        "body": "<p>上一篇講到<a href=\"https://jennycodes.me/posts/security-ssh\"> SSH (Secure Shell)</a>，一種加密連線方式，確保我們對遠端伺服器發送指令時，能夠不被竊聽或是竄改命令。本篇一鼓作氣，來介紹與 SSH （縮寫）只有一字之差的 SSL–Secure Sockets Layer。它們不僅名字相似，功能／目的也滿接近的。對了，這是 <a href=\"https://jennycodes.me/posts?tag=Security\">Security 資訊安全系列文</a>第三篇！</p>\\n\\n<p>本篇文章會從 SSL 基礎概念談起，介紹 SSL 背後原理、相關名詞介紹（包含 TLS, CA, chain of trust, OpenSSL）、 OpenSSL 實際操作、與 SSL 憑證種類。開始吧！</p>\\n\\n<h3>SSL: Secure Sockets Layer</h3>\\n\\n<p>當我們瀏覽網頁時，<strong>我們都有個好習慣</strong>：先檢查網址列的開頭是不是有個 🔒鎖的圖案。</p>\\n\\n<p><img alt=\"\" class=\"lazy img-fluid\" data-src=\"https://miro.medium.com/max/1508/1*zJDDftROOQTvLZSyRuT94Q.png\"></p>\\n\\n<p>這個鎖代表什麼？代表你現在連線到的網站是安全可信任的。更準確的說，這個鎖的記號代表你與這個網站是使用安全的 <a href=\"https://en.wikipedia.org/wiki/HTTPS\">HTTPS  (HTTP Secure)</a> 連線，而不是使用不安全的<a href=\"https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol\"> HTTP protocol</a>。連線後，只有瀏覽器本人跟網站能夠解讀雙方之間傳遞的資料，就算其他人想要從中攔截（比如說你的使用者帳號密碼），也沒辦法。</p>\\n\\n<p>HTTPS 背後的 protocol，就是 SSL。</p>\\n\\n<h3>SSL 加密步驟</h3>\\n\\n<p>SSL 讓瀏覽器（所謂的 client）要連到一個遠端網站（所謂的 server）之前，先要求這個網站提供身分認證，跟這個網站約定暗號（交換鑰匙），打好交情（建立加密的 session），才會心甘情願地跟這個網站連線。可以分成六個步驟：</p>\\n\\n<ol>\\n<li>瀏覽器對想要連線的網站送出連線請求，同時要求網站驗證自己。</li>\\n<li>網站將自己的 SSL 數位憑證 (SSL certificate) 回傳給 client，裡面包含了網站的 public key。</li>\\n<li>瀏覽器驗證網站回傳的的 root certificate，透過 <a href=\"#chainoftrust\">chain of trust 機制</a> 確認這個證明文件是否可以被信認，同時也確認這個憑證是否過期。</li>\\n<li>當認證通過，瀏覽器會用網站的 public key 建立一個 <a href=\"https://en.wikipedia.org/wiki/Session_key\">symmetric session key</a>。</li>\\n<li>網站用自己的 private key 解讀 session key，並且回傳一個確認訊息，開始一個被 SSL 保護的 session。</li>\\n<li>這個 session key 會被用來加密所有之後瀏覽器與網站之間傳送的資料。</li>\\n</ol>\\n\\n<p>下面來介紹一些 SSL 相關名詞。</p>\\n\\n<h3>TLS: Transport Layer Security Protocol</h3>\\n\\n<p>在<a href=\"https://jennycodes.me/posts/security-ssh#sshvsssl\">上一篇文</a>中有稍微提到 TLS 的歷史，簡而言之，由於 SSL 已經不再安全（<a href=\"https://en.wikipedia.org/wiki/POODLE\">POODLE</a> 與 <a href=\"https://drownattack.com/\">DROWN</a> 是兩個曾經發生過的著名攻擊），所以現在已經被 TLS protocol 取代。慣性使然，當我們說 SSL（比如說 SSL 憑證）時，大部分情況其實是在說 TLS。</p>\\n\\n<h3>CA: Certificate Authority</h3>\\n\\n<p><a href=\"https://en.wikipedia.org/wiki/Certificate_authority\">數位憑證認證機構，簡稱 CA</a>，是負責發放與管理數位憑證 （certificate）的單位。前面提到進行 SSL 連線的前置作業是 server 要提供數位憑證讓瀏覽器驗證，但瀏覽器要怎麼驗證？它會去看這個憑證是不是被一個它相信的 CA 簽署的。如果是，那瀏覽器就相信這個 server 可以信任，如果不是，那瀏覽器就再看這個 CA 有沒有它自己的 certificate，如果有，而這個 certificate 是被一個瀏覽器信任的 CA 簽的，那就放行，如果沒有，就再往下找。如果一路找下去，找不到可以信任的 CA，就失敗。</p>\\n\\n<p>假設今天世界上有甲乙丙三家 CA。CA 丙簽了 CA 乙的憑證，而 CA 乙簽了 CA 甲的憑證。瀏覽器小明想連線到網站 A，而小明只知道 CA 丙。連線前，網站 A 傳了它的 certificate 們給小明。小明先看第一張，眉頭一皺，發現 A 的憑證是不認識的 CA 甲簽的，往下翻，看到 CA 乙簽了甲的憑證，但小明也不認識乙，所以繼續往下翻，下一張是乙的憑證，是 CA 丙簽署的—bingo! 於是網站 A 順利與小明建立連線。</p>\\n\\n<p>所以 CA 其實很像保證人的角色，它向瀏覽器保證一個網域的合法性，讓想要連線的那一方確保自己的連線對象是安全的。</p>\\n\\n<h3>Chain of Trust</h3>\\n\\n<p>這樣一層一層檢查 certificate，直到找到信任的 CA 的機制，叫做 <a href=\"https://en.wikipedia.org/wiki/Chain_of_trust\">chain of trust</a>。你可能會疑惑，為什麼不直接讓所有 server 都帶著 CA 丙簽的 certificate 就好了？為什麼還需要經過這麼多層？主要原因是安全。如果今天壞人 B 找到一個破解 CA 甲的方法，可以偽造甲的簽名，這個漏洞一旦被發現，所有被甲簽過的憑證就都沒有意義了，那些網域必須要重新找 CA 來擔保自己的合法性。</p>\\n\\n<p>使用 chain of trust 的好處是，它可以降低 root CA（chain of trust 的源頭 CA，就是例子中的 CA 丙）被暴露的風險。不過這也代表，要成為一個 root CA，安全防護必須要做到謹慎再謹慎，不然如果 root CA 的私鑰被攻破了，後果不堪設想。</p>\\n\\n<h3>OpenSSL</h3>\\n\\n<p>SSL/TLS 是 protocol，而 <a href=\"https://www.openssl.org/\">OpenSSL</a> 就是一個開源的實作（<a href=\"https://jennycodes.me/posts/security-ssh#openssh\">SSH 與 OpenSSH</a> 也是同樣的關係）。</p>\\n\\n<h4>捲起袖子玩一玩</h4>\\n\\n<p>如果你的電腦是 Unix 系列的，很大的機率是系統已經裝好 OpenSSL 了。如果是 Windows 系統，也可以直接去<a href=\"https://www.openssl.org/source/\">網站</a>下載最新的版本。</p>\\n\\n<pre><code class=\"lang-shell\">$openssl version\\nLibreSSL 2.6.5\\n</code></pre>\\n\\n<p>可以先打開終端機，試試 <code>version</code> 指令，如果有回傳版本給你，就代表你的電腦已經有 OpenSSL 了。</p>\\n\\n<p>用 <code>$openssl help</code>（或是任何 OpenSSL 不認得的指令...）就可以看到 OpenSSL 提供的指令包。</p>\\n\\n<p><img alt=\"\" class=\"lazy img-fluid\" data-src=\"https://miro.medium.com/max/1440/1*d55YNUTMXy2HHEQpOEaf7A.png\"></p>\\n\\n<p>其中 <code>s_client</code> 是一個挺實用的工具，讓我們診斷與測試 SSL 的安全連線。下面示範測試 jennycodes.me 網站的 SSL 狀態。</p>\\n\\n<pre><code class=\"lang-shell\">$openssl s_client -connect jennycodes.me:443 -servername jennycodes.me\\n\\nCONNECTED(00000005)\\ndepth=2 C = IE, O = Baltimore, OU = CyberTrust, CN = Baltimore CyberTrust Root\\nverify return:1\\ndepth=1 C = US, ST = CA, L = San Francisco, O = \"CloudFlare, Inc.\", CN = CloudFlare Inc ECC CA-2\\nverify return:1\\ndepth=0 C = US, ST = CA, L = San Francisco, O = \"CloudFlare, Inc.\", CN = sni.cloudflaressl.com\\nverify return:1\\n---\\nCertificate chain\\n 0 s:/C=US/ST=CA/L=San Francisco/O=CloudFlare, Inc./CN=sni.cloudflaressl.com\\n   i:/C=US/ST=CA/L=San Francisco/O=CloudFlare, Inc./CN=CloudFlare Inc ECC CA-2\\n 1 s:/C=US/ST=CA/L=San Francisco/O=CloudFlare, Inc./CN=CloudFlare Inc ECC CA-2\\n   i:/C=IE/O=Baltimore/OU=CyberTrust/CN=Baltimore CyberTrust Root\\n---\\nServer certificate\\n-----BEGIN CERTIFICATE-----\\n（略）\\n-----END CERTIFICATE-----\\nsubject=/C=US/ST=CA/L=San Francisco/O=CloudFlare, Inc./CN=sni.cloudflaressl.com\\nissuer=/C=US/ST=CA/L=San Francisco/O=CloudFlare, Inc./CN=CloudFlare Inc ECC CA-2\\n---\\nNo client certificate CA names sent\\nServer Temp Key: ECDH, X25519, 253 bits\\n---\\nSSL handshake has read 2642 bytes and written 307 bytes\\n---\\nNew, TLSv1/SSLv3, Cipher is ECDHE-ECDSA-CHACHA20-POLY1305\\nServer public key is 256 bit\\nSecure Renegotiation IS supported\\nCompression: NONE\\nExpansion: NONE\\nNo ALPN negotiated\\nSSL-Session:\\n    Protocol  : TLSv1.2\\n    Cipher    : ECDHE-ECDSA-CHACHA20-POLY1305\\n    Session-ID: 5FEF2BA2A72483061BEB18C92222BBC507A1A95749AE67094F2863D537B7C600\\n    （略）\\n    Verify return code: 0 (ok)\\n---\\nclosed\\n</code></pre>\\n\\n<p>結果長這樣。解釋一下，我目前用的 SSL 是直接從 CloudFlare （CDN 伺服器）設定，不影響效用，但是 certificate 不會看到 jennycodes.me 的字樣。從上面一路看下來，<code>certificate chain</code> 的部分可以看到 openssl client 經過兩步 chain of trust 就認證了 jennycodes.me 網域（CloudFlare Inc ECC CA-2 -&gt; Baltimore CyberTrust Root），緊接著的是 <code>server certificate</code> 內容，再下面可以注意的是 <code>SSL-Session</code> 下的 protocol 是用 <code>TLSv1.2</code>，而不是 SSL。</p>\\n\\n<p>如果加上 <code>-state</code> 指令，變成：</p>\\n\\n<pre><code class=\"lang-shell\">$openssl s_client -connect jennycodes.me:443 -servername jennycodes.me -state\\n</code></pre>\\n\\n<p>就會看到前面出現這段</p>\\n\\n<pre><code>SSL_connect:before/connect initialization                                                                               \\nSSL_connect:SSLv3 write client hello A\\nSSL_connect:SSLv3 read server hello A\\ndepth=2 C = IE, O = Baltimore, OU = CyberTrust, CN = Baltimore CyberTrust Root\\nverify return:1\\ndepth=1 C = US, ST = CA, L = San Francisco, O = \"CloudFlare, Inc.\", CN = CloudFlare Inc ECC CA-2\\nverify return:1\\ndepth=0 C = US, ST = CA, L = San Francisco, O = \"CloudFlare, Inc.\", CN = sni.cloudflaressl.com\\nverify return:1\\nSSL_connect:SSLv3 read server certificate A\\nSSL_connect:SSLv3 read server key exchange A\\nSSL_connect:SSLv3 read server done A\\nSSL_connect:SSLv3 write client key exchange A\\nSSL_connect:SSLv3 write change cipher spec A\\nSSL_connect:SSLv3 write finished A\\nSSL_connect:SSLv3 flush data\\nSSL_connect:SSLv3 read server session ticket A\\nSSL_connect:SSLv3 read finished A\\n</code></pre>\\n\\n<p>可以看到連線前的握手過程，逐步確認 SSL 連線的步驟是否正確，滿好玩的。</p>\\n\\n<p>再來，上面的指令只會顯示最前面那張 certificate 內容（也就是 server certificate）。如果想要看到所有的 certificate ，可以加上 <code>-showcerts</code>：</p>\\n\\n<pre><code class=\"lang-shell\">$openssl s_client -connect jennycodes.me:443 -servername jennycodes.me -showcerts\\n</code></pre>\\n\\n<p>就可以拿到包含 root certificate 的所有憑證了。</p>\\n\\n<p>光是 <code>s_client</code> 就有很多指令可以用了，這邊送上 <a href=\"https://www.openssl.org/docs/man1.0.2/man1/openssl-s_client.html\">s_client 的 man page</a>，請好奇的人自行欣賞。</p>\\n\\n<h3>SSL 憑證種類</h3>\\n\\n<p>依照安全層級（validation level）分類的話，SSL 憑證可以分成三種：<strong>Domain Validated (DV)</strong>, <strong>Organization Validated (OV)</strong>, <strong>Extended Validation (EV)</strong>。以下分別介紹：</p>\\n\\n<h4>Domain Validated SSL Certificates (DV)</h4>\\n\\n<blockquote>\\n<p>SSL 中安全層級：低<br>\\n費用：低</p>\\n</blockquote>\\n\\n<p>CA 認證時，單純確認這個組織是否真的擁有這個網域（通常使用 email 確認）。</p>\\n\\n<p><img alt=\"\" class=\"lazy img-fluid\" data-src=\"https://miro.medium.com/max/1940/1*jGFRt5h6LYDAZmb3L9mwrw.png\"></p>\\n\\n<p>從上面的那三張 certificate 名稱中就已經可以看到該組織用的是哪一種 SSL certificate 了。拿 PicCollage 當例子，中間的那張 Sectigo RSA Domain Validation Secure Server CA 代表 PicCollage 使用的是 DV certificate。下面的 Details 欄位也可以看到 subject 就只有單純顯示 common name 這個資訊。</p>\\n\\n<h4>Organization Validated SSL Certificates (OV)</h4>\\n\\n<blockquote>\\n<p>SSL 中安全層級：中<br>\\n費用：中</p>\\n</blockquote>\\n\\n<p>CA 除了確認該組織是否擁有這個網域之外，也會聯絡並稍微調查該組織，確認該組織是可信的。發放的憑證中會有該組織的相關資訊，像是名字與位置。</p>\\n\\n<p><img alt=\"\" class=\"lazy img-fluid\" data-src=\"https://miro.medium.com/max/1944/1*wTnLUUWDYriygiSHxM7fpg.png\"></p>\\n\\n<p>跟 DV 比起來，OV 可以看到的訊息就更多，像是地區與組織名稱。</p>\\n\\n<h4>Extended Validation SSL Certificates</h4>\\n\\n<blockquote>\\n<p>SSL 中安全層級：高<br>\\n費用：高</p>\\n</blockquote>\\n\\n<p>CA 除了該組織的網域所有權、組織基本資料、實體位置，還會驗證該組織的法律地位。這種證書需要組織提供文件與耐心 (?) 來等待審核通過。</p>\\n\\n<p><img alt=\"\" class=\"lazy img-fluid\" data-src=\"https://miro.medium.com/max/966/1*sr8pECeyiMSqq5-1uMtoEA.png\"></p>\\n\\n<p>EV 比起 OV 又多了一些資訊，像是 business category 與 serial number。同樣可以從上面的 certificate issuer 看到這是 EV 等級的 SSL 憑證。</p>\\n\\n<p>若是依照網域/子網域數（number of secured domains/subdomains）分類，則 SSL 憑證也可以分成<a href=\"https://en.wikipedia.org/wiki/Wildcard_certificate\"><strong>Wildcard</strong></a>, <a href=\"https://www.ssls.com/knowledgebase/what-is-a-multi-domain-ssl-certificate/\"><strong>Multi-Domain (MDC)</strong></a>, <a href=\"https://en.wikipedia.org/wiki/Server_Name_Indication\"><strong>Unified Communications (UCC)</strong></a> 三種。這邊比較直觀，就不細講啦。</p>\\n\\n<h3>後話</h3>\\n\\n<p>最近我們的 Android team 遇到一個問題：有兩台 Samsung 的測試手機不知道為什麼一直無法連到 PicCollage 伺服器拿資料，錯誤訊息顯示是因為 SSL 無法認證。有趣的是只有這兩台 Samsung 手機出事，如果是 SSL 憑證的問題應該是所有手機都會被影響。我們試了一些不同方法，後來參考<a href=\"https://github.com/brunoos/luasec/issues/88\">這裡</a>跟<a href=\"https://github.com/webrtc/apprtc/issues/586\">這裡</a>將 server certificate 掛在 Android 程式碼中，直接承認這張 certificate 的合法性。可以動了，卻不是根本性的解法。</p>\\n\\n<p>後來，找到了原因：這兩台 Samsung 裝置的系統時間被改過了（改到了很久以後的未來），而我們的 SSL 最近剛要過期，所以系統認為我們的 SSL 憑證早就已經過期了...</p>\\n\\n<p>也是因為如此，這篇文章才會這麼早出現（本來想先寫其他更有趣的主題）（SSL 對不起），為了追這個 bug，順手查了一些相關資料，想想其實乾脆再順手一點，就把 SSL 寫出來了。</p>\\n\\n<h3>下回預告</h3>\\n\\n<p>最近在研究 Ruby on Rails 的效能與記憶體，新年之前不知道有沒有辦法再出一篇。如果沒有的話，新年快樂！</p>\\n",
        "status": 1,
        "description": "Security 資訊安全系列文第三篇 🤓",
        "created_at": "2019-12-23T12:17:59.559809",
        "updated_at": "2019-12-23T12:22:12.44307",
        "slug": "security-ssl-https",
        "medium_url": "https://medium.com/@jinghua.shih/security-ssl-https-%E8%83%8C%E5%BE%8C%E7%9A%84%E5%8A%9F%E8%87%A3-df714e4df77b"
    },
    {
        "id": 33,
        "title": "[Ruby] 如何理解 Ruby Block",
        "body": "<p></p>\\n<p>所以說，我們來談談這個讓我一開始學 Ruby 時非常困惑的概念：blocks。當初開始學 Ruby 時，本想著一切都會非常輕鬆寫意，畢竟當時跟 C++（我的程式母語）處得還不錯，而 Ruby 開宗明義的哲學就是 “Make programmers happy.” 有 C++ 的背景加上這個語言是如此人性化，學起來絕對輕輕鬆鬆啊——結果 Block 就出現了。看著那些 <code class=\"markup--code markup--p-code\">do…end</code>, <code class=\"markup--code markup--p-code\">yield</code>, <code class=\"markup--code markup--p-code\">block.call</code> 參數傳來傳去還有各式各樣的簡寫花式（一個 Ruby 讓人又愛又恨的特點），最讓我困惑的是「block 到底有什麼用？」直接用 function 不行嗎？為什麼要創造一個又不算是函式又不是變數的東西來混淆視聽？</p>\\n<p>但是 block 在 Ruby 中實在是太重要了，很多 Ruby 內建的方法也是利用了 block（像是 <code class=\"markup--code markup--p-code\">map</code>），所以用久了也就漸漸習慣它的存在，只是心中的謎團一直沒有解開。</p>\\n<p>直到最近，在公司的程式碼裡面看到了一個 block 用法，頓悟終於來了：原來 block 是這樣用的！太聰明了！偉哉 Ruby（還有寫出這段程式碼的智者）！如果沒有 block，就很難如此簡潔地達成目的。發現這件事，簡直像是發現新大陸一樣，從此用一個完全不一樣的態度來看 block 了。</p>\\n<p>但是在介紹 block 的存在意義之前，我們先來複習一下 block 與它的兄弟姐妹 Proc 與 Lambda。</p>\\n<h3>Ruby Block</h3>\\n<p>Ruby Block 在其他語言中對應的概念是 <code class=\"markup--code markup--p-code\">closure</code>或是匿名函式（<code class=\"markup--code markup--p-code\">lambda</code>）。我們可以把 block 想像成「函式中的函式」。一般我們呼叫一個函式，傳進去的參數（parameter）是靜態的變數（variable），處理這個／些變數的邏輯全部由函式本身包辦。也就是說，我們輸入的只是資料，並不包含這個函式該怎麼處理這個資料。比如說今天我們去餐廳吃飯，有一個簡單的 <code class=\"markup--code markup--p-code\">order_from_menu</code> 函式長這樣</p>\\n<pre>def order_dish(dish)<br>  # kitchen prepares the dish<br>  ...</pre>\\n<pre>  # serve<br>  \"Here comes your #{dish}!\"<br>end</pre>\\n<p>所以當我們呼叫 <code class=\"markup--code markup--p-code\">order_dish('蛋炒飯')</code> 則 <code class=\"markup--code markup--p-code\">'蛋炒飯'</code> 就是我們傳進 <code class=\"markup--code markup--p-code\">order_dish</code> 函式的參數。這個飯該怎麼炒、服務生要用什麼方式端過來，都不是我們的事。對這個函式的使用者而言，邏輯是這樣：</p>\\n<blockquote>點菜（把參數傳進去） → 等菜（等函式裡的邏輯處理參數） → 上菜（得到回傳值）</blockquote>\\n<p>所有使用這個函式的人都是得到一樣的處理邏輯，差別只在傳進的參數不同。</p>\\n<p>如果有 block 的話，就像是在這個函式的標準程序中，再插入自己想做的動作，比如說</p>\\n<pre># definition</pre>\\n<pre>def order_dish(dish)<br>  # kitchen prepares the dish<br>  ...<br>  <br><strong class=\"markup--strong markup--pre-strong\">  # if we do pass in a block, then execute the content<br>  if block_given?<br>    yield<br>  end</strong></pre>\\n<pre>  # serve the dish<br>  \"Here comes your #{dish}!\"<br>end</pre>\\n<pre># usage</pre>\\n<pre>order_dish('蛋炒飯')           <br>=&gt; \"Here comes your 蛋炒飯！\"   # same result</pre>\\n<pre>order_dish('蛋炒飯')<strong class=\"markup--strong markup--pre-strong\">{ p 'Sing a song.' }</strong>    # pass in a block<br>=&gt; \"Sing a song.\"<br>=&gt; \"Here comes your 蛋炒飯！\"</pre>\\n<p>當我們一個 block 附帶在 method 的後面時，它就會在函式進行到 yield 時被執行。<code class=\"markup--code markup--p-code\">block_given?</code> 是 ruby 內建的方法，幫助我們判斷是否有傳入 block。如果我們沒有傳入 block 卻執行 yield 的話就會出現錯誤 <code class=\"markup--code markup--p-code\">LocalJumpError: no block given (yield)</code>。</p>\\n<p>可以看到，上面這個例子在參數列完全沒有提示是否有 block，所以這是一個 “implicit block”。我們可以主動將 block 放在參數列，如下：</p>\\n<pre>def order_dish(dish, <strong class=\"markup--strong markup--pre-strong\">&amp;block</strong>)<br>  ...(some code)</pre>\\n<pre>  if block_given?<br>    # now whenever we want to call the block, we can use<br>    yield<br>    # or <br>    block.call<br>  end</pre>\\n<pre>  ...(some code)<br>end</pre>\\n<p>在 argument list 中加上 <code class=\"markup--code markup--p-code\">&amp;block</code> 這個函數的用法基本上是一樣的。我們依然可以選擇加上區塊或是不加區塊，有加區塊的話就可以用 <code class=\"markup--code markup--p-code\">yield</code> 或是 <code class=\"markup--code markup--p-code\">block.call</code> 來執行區塊內容。</p>\\n<p>什麼？你說為什麼<code class=\"markup--code markup--p-code\">&amp;block</code> 前面要加上一個 <code class=\"markup--code markup--p-code\">&amp;</code>？不加會怎麼樣？</p>\\n<p>這時候就要請 Proc 與 Lambda 登場了。</p>\\n<h3>Ruby Proc</h3>\\n<p>前面的 block 內容都是在我們呼叫函式的時候當場傳進去的，所以它沒有名字（直接用 <code class=\"markup--code markup--p-code\">yield</code> 它就執行了），也沒有被寫進記憶體中。如果今天我們想要先將一個 block 準備好，需要的時候再直接將它傳進函式中可不可以？可以！這就是 <code class=\"markup--code markup--p-code\">Proc</code>（Procedure）的功用。</p>\\n<blockquote>Blocks are used for passing blocks of code to methods, and procs and lambda’s allow storing blocks of code in variables.</blockquote>\\n<p>–擷取自 <a href=\"https://blog.appsignal.com/2018/09/04/ruby-magic-closures-in-ruby-blocks-procs-and-lambdas.html\" data-href=\"https://blog.appsignal.com/2018/09/04/ruby-magic-closures-in-ruby-blocks-procs-and-lambdas.html\" class=\"markup--anchor markup--p-anchor\" rel=\"noopener nofollow\" target=\"_blank\">App Signal</a>。</p>\\n<p>基本上，Proc 就是把 block 內容存進變數裡。而且其實，如果你在上面的例子中用 <code class=\"markup--code markup--p-code\">block.class</code> 看 block 的類別是什麼，你會看到 <code class=\"markup--code markup--p-code\">Proc</code>。我們先來創一個 <code class=\"markup--code markup--p-code\">Proc</code>看看：</p>\\n<pre>sing_a_song = Proc.new { p 'Sing a song.' }</pre>\\n<p>然後把它放進上面的例子中</p>\\n<pre>order_dish('蛋炒飯', &amp;sing_a_song)<br>=&gt; \"Sing a song.\"<br>=&gt; \"Here comes your 蛋炒飯！\"</pre>\\n<p>結果是一樣的，只是這次傳進的是一個預先定義好的區塊。</p>\\n<p>但是為什麼這裡又出現了 &amp;？</p>\\n<h4>&amp; 的深意</h4>\\n<p>在上面定義函式的例子 (<code class=\"markup--code markup--p-code u-paddingRight0 u-marginRight0\">def order_dish(dish, <strong class=\"markup--strong markup--p-strong\">&amp;</strong>block)</code>) 中，我們使用 &amp;block 的意思是如果今天有一個 block <strong class=\"markup--strong markup--p-strong\">的內容</strong>傳進來，那麼就把它放進名叫 block 的變數中在函式內部使用。如果沒有傳入 block <strong class=\"markup--strong markup--p-strong\">的內容</strong>，那麼這個變數就會是空的。我們當初用 <code class=\"markup--code markup--p-code u-paddingRight0 u-marginRight0\">order_dish('蛋炒飯') { '<strong class=\"markup--strong markup--p-strong\">Sing a song.'</strong> } </code>就是傳入了 block <strong class=\"markup--strong markup--p-strong\">的內容</strong>。</p>\\n<p>block 的內容跟 block 本身是不一樣的。我們用 <code class=\"markup--code markup--p-code\">Proc.new</code> 創立的 <code class=\"markup--code markup--p-code\">sing_a_song</code> 是一個 Proc <strong class=\"markup--strong markup--p-strong\">實例</strong>，所以如果直接把 <code class=\"markup--code markup--p-code\">sing_a_song</code> 傳進去當參數，會出現錯誤</p>\\n<pre>order_dish('蛋炒飯', sing_a_song)   # no ampersand<br>=&gt; ArgumentError: wrong number of arguments (given 2, expected 1)</pre>\\n<p>因為它要的不是 Proc 本身，而是 Proc 的內容。所以，在呼叫的時候，我們在 Proc 實例之前加入 &amp; 能夠讓程式碼幫我們將存在於 <code class=\"markup--code markup--p-code\">sing_a_song</code> 裡面的 block 拿出來（也就是 <code class=\"markup--code markup--p-code\">{p 'Sing a song.'}</code>）。</p>\\n<p>聰明如我們當然馬上舉一反三，所以今天如果函式定義是 <code class=\"markup--code markup--p-code\">def order_dish(dish, block)</code>，那麼 block 就會是跟 dish 一個正常的參數，在傳 Proc 參數進去時自然也不用再加入 &amp; 轉換了。</p>\\n<pre># definition<br>def order_dish (dish, block)<br>  ...<br>  block.call       # attention: can't use `yield` anymore<br>  ...<br>end</pre>\\n<pre># usage<br>order_dish('蛋炒飯', sing_a_song)<br>=&gt; \"Sing a song.\"<br>=&gt; \"Here comes your 蛋炒飯！\"</pre>\\n<p>為何不能用 <code class=\"markup--code markup--p-code\">yield</code>？因為之前的 block 是赤裸裸的貼在呼叫函式後面，<code class=\"markup--code markup--p-code\">yield</code> 很好找人，現在它被塞進變數裡，變成 Proc 實體了，<code class=\"markup--code markup--p-code\">yield</code> 抓不到了。</p>\\n<p>但這也代表一件事：我們可以傳超過一個 block 給函式！因為現在他們變成一般變數，所以我們想要放幾個 block 都可以。</p>\\n<pre># define some blocks<br>sing_a_song = Proc.new ('Sing a song.')<br>do_a_dance  = Proc.new ('Do a dance.')</pre>\\n<pre># define method<br>def order_dish(dish, blocks)<br>  ...<br>  blocks.each do |block|<br>    block.call<br>  end<br>  ...<br>end</pre>\\n<pre># usage<br>order_dish('蛋炒飯', [sing_a_song, do_a_dance])<br>=&gt; \"Sing a song.\"<br>=&gt; \"Do a dance.\"<br>=&gt; \"Here comes your 蛋炒飯！\"</pre>\\n<h3>Ruby Lambda</h3>\\n<p>lambda 其實跟 Proc 很相似，它叫做匿名函式，在其他語言中（比如說 <a href=\"https://docs.python.org/3/reference/expressions.html#lambda\" data-href=\"https://docs.python.org/3/reference/expressions.html#lambda\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">Python</a>）也有。先來看看如何使用：</p>\\n<pre>a_lambda = lambda { 'lambda here' }</pre>\\n<p>就是把原本 <code class=\"markup--code markup--p-code\">Proc.new</code> 的地方換成了 lambda。</p>\\n<p>前面提過，block 其實是一個 Proc，那麼 lambda 呢？</p>\\n<h4>block, Proc 與 lambda</h4>\\n<p>我們來實際輸出比較一下</p>\\n<figure class=\"text-center\"><script src=\"https://gist.github.com/jenny-codes/23fc0f97a9325581d74f12aff8580c44.js\"></script><figcaption class=\"imageCaption\"><a href=\"https://gist.github.com/jenny-codes/23fc0f97a9325581d74f12aff8580c44\" data-href=\"https://gist.github.com/jenny-codes/23fc0f97a9325581d74f12aff8580c44\" class=\"markup--anchor markup--figure-anchor\" rel=\"nofollow noopener\" target=\"_blank\">https://gist.github.com/jenny-codes/23fc0f97a9325581d74f12aff8580c44</a></figcaption></figure><pre>result:</pre>\\n<pre>A block is a Proc<br>A block instance: <br>#&lt;Proc:<a href=\"mailto:0x00007ffb1886b6e8@block.rb\" data-href=\"mailto:0x00007ffb1886b6e8@block.rb\" class=\"markup--anchor markup--pre-anchor\" rel=\"nofollow\" target=\"_blank\">0x00007ffb1886b6e8@block_proc_lamnda.rb</a>:11&gt;<br>A proc is a Proc<br>A proc instance: <br>#&lt;Proc:<a href=\"mailto:0x00007ffb1886b788@block.rb\" data-href=\"mailto:0x00007ffb1886b788@block.rb\" class=\"markup--anchor markup--pre-anchor\" rel=\"nofollow\" target=\"_blank\">0x00007ffb1886b788@block_proc_lambda.rb</a>:7&gt;<br>A lambda is a Proc<br>A lambda instance: <br>#&lt;Proc:<a href=\"mailto:0x00007ffb1886b738@block.rb\" data-href=\"mailto:0x00007ffb1886b738@block.rb\" class=\"markup--anchor markup--pre-anchor\" rel=\"nofollow\" target=\"_blank\">0x00007ffb1886b738@block_proc_lambda.rb</a>:8 <strong class=\"markup--strong markup--pre-strong\">(lambda)</strong>&gt;</pre>\\n<p>可以看到，lambda 其實也是個 Proc。不過在 lambda instance 中，我們可以發現有一個註解 <code class=\"markup--code markup--p-code\">(lambda)</code> 來將 lambda 區別出來。有趣。</p>\\n<h4>Proc 與 lambda 的差別</h4>\\n<p>既然 Proc 與 lambda 都會創造一個 Proc 實體，那它們的差別在哪裡？</p>\\n<blockquote>1. Return 的 scope</blockquote>\\n<p>直接看例子</p>\\n<figure class=\"text-center\"><script src=\"https://gist.github.com/jenny-codes/2d8c11eff334a9a54c281df277f08d12.js\"></script><figcaption class=\"imageCaption\"><a href=\"https://gist.github.com/jenny-codes/2d8c11eff334a9a54c281df277f08d12\" data-href=\"https://gist.github.com/jenny-codes/2d8c11eff334a9a54c281df277f08d12\" class=\"markup--anchor markup--figure-anchor\" rel=\"nofollow noopener\" target=\"_blank\">https://gist.github.com/jenny-codes/2d8c11eff334a9a54c281df277f08d12</a></figcaption></figure><p>執行的結果是</p>\\n<pre>return from inside Proc<br>return from lambda function</pre>\\n<p>Proc 裡面的 return 會結束整個 function，而 lambda 的 return 只會結束 lambda 本身。</p>\\n<blockquote>2. 會不會檢查 Argument 個數</blockquote>\\n<p>也是直接看例子</p>\\n<figure class=\"text-center\"><script src=\"https://gist.github.com/jenny-codes/92c848dcc27cd3af334466a38bac66e7.js\"></script><figcaption class=\"imageCaption\"><a href=\"https://gist.github.com/jenny-codes/92c848dcc27cd3af334466a38bac66e7\" data-href=\"https://gist.github.com/jenny-codes/92c848dcc27cd3af334466a38bac66e7\" class=\"markup--anchor markup--figure-anchor\" rel=\"nofollow noopener\" target=\"_blank\">https://gist.github.com/jenny-codes/92c848dcc27cd3af334466a38bac66e7</a></figcaption></figure><p>結果：</p>\\n<pre><code class=\"markup--code markup--pre-code\">a_proc outputs arg1 &amp; arg2 &amp;<br>Traceback (most recent call last):<br>\\t2: from block.rb:40:in `&lt;main&gt;'<br>\\t1: from block.rb:33:in `missing_arguments'<br>proc_lambda_argument.rb:37:in `block in &lt;main&gt;': wrong number of arguments (given 2, expected 3) (ArgumentError)</code></pre>\\n<p>Proc 如果沒有收到足夠的參數，它就直接讓該物件變成 <code class=\"markup--code markup--p-code\">nil</code>。lambda 遇到同樣的狀況就會報錯。</p>\\n<blockquote>Ruby 中的 Proc 像是代碼片段（code snippet），所以 Proc 中的 return 就會讓整個方法 return；lambda 比較像是 function（匿名的），所以它 return 時就只會讓自己 return。</blockquote>\\n<h3>一些不同的寫法</h3>\\n<p>以下列舉一些常見的寫法，存參。</p>\\n<pre># block<br>do...end  # or<br>{}</pre>\\n<pre># Proc<br>Proc.new {}  # or<br>proc {}</pre>\\n<pre># lambda<br>lambda {}  # or<br>-&gt; {}</pre><p>所以說，那段讓你頓悟的程式碼呢？</p>\\n<h3>終於（稍微）理解 block 的意義</h3>\\n<p>單純知道一個概念該怎麼用，不代表你就知道為什麼、什麼時候要使用它。讓我頓悟的程式碼長這樣：</p>\\n<figure class=\"text-center\"><script src=\"https://gist.github.com/jenny-codes/60847c96eac91a2bf13e59cc8d06564a.js\"></script><figcaption class=\"imageCaption\"><a href=\"https://gist.github.com/jenny-codes/60847c96eac91a2bf13e59cc8d06564a\" data-href=\"https://gist.github.com/jenny-codes/60847c96eac91a2bf13e59cc8d06564a\" class=\"markup--anchor markup--figure-anchor\" rel=\"nofollow noopener\" target=\"_blank\">https://gist.github.com/jenny-codes/60847c96eac91a2bf13e59cc8d06564a</a></figcaption></figure><pre>OUTPUT:</pre>\\n<pre><code class=\"markup--code markup--pre-code\">[Menu option] set: 蛋炒飯, side: 皮蛋豆腐, with_sauce: true<br>[Menu option] set: 蛋炒飯, side: 皮蛋豆腐, with_sauce: false<br>[Menu option] set: 蛋炒飯, side: 涼拌乾絲, with_sauce: true<br>[Menu option] set: 蛋炒飯, side: 涼拌乾絲, with_sauce: false<br>[Menu option] set: 蛋炒飯, side: 滷味拼盤, with_sauce: true<br>[Menu option] set: 蛋炒飯, side: 滷味拼盤, with_sauce: false<br>[Menu option] set: 紅蘿蔔蛋炒飯, side: 皮蛋豆腐, with_sauce: true<br>[Menu option] set: 紅蘿蔔蛋炒飯, side: 皮蛋豆腐, with_sauce: false<br>[Menu option] set: 紅蘿蔔蛋炒飯, side: 涼拌乾絲, with_sauce: true<br>[Menu option] set: 紅蘿蔔蛋炒飯, side: 涼拌乾絲, with_sauce: false<br>[Menu option] set: 紅蘿蔔蛋炒飯, side: 滷味拼盤, with_sauce: true<br>[Menu option] set: 紅蘿蔔蛋炒飯, side: 滷味拼盤, with_sauce: false</code></pre>\\n<p>我有稍微修改了一下，但是概念基本上是一樣的。<code class=\"markup--code markup--p-code\">run_variations</code> 這個 method 接受一系列的選項，將它們排列組合，重新放進一個 struct 裡面，並將這個 struct 傳入 block。於是在 block 中，我們可以便利地使用這些排列組合過後的值。</p>\\n<p>假設今天我要設計一個菜單，我決定要賣兩種套餐：蛋炒飯跟紅蘿蔔蛋炒飯，每種套餐可以選擇一種小菜，皮蛋豆腐、涼拌乾絲或是滷味拼盤，並且可以選擇要不要加醬。我想把所有可能的組合都印出來，上面就是我呼叫 <code class=\"markup--code markup--p-code\">run_variations</code> 後的結果。</p>\\n<p>在這裡，block 的用法很像是前置作業，先行的函式定義放在主要的 method 定義裡面，而我們真正想要對 argument 做的事則是放在 block 裡。如果沒有 block 的話，就要先把 run_variations 產生的結果放在一個陣列裡，再迭代這個陣列。這樣當然行得通，但是就多耗費了一個轉換跟儲存的資源，並且也不能使用 <code class=\"markup--code markup--p-code\">combination.set</code>這種有清楚架構的寫法。</p>\\n<h3>block 就像是場地租借空間</h3>\\n<p>延續餐廳的例子，block 就像是最近開始流行的場地租借空間，賣的不是食物，而是一個讓你聚會、辦活動的場地。它會提供一些基本的設備、小茶水點心，並且事後還幫你收拾，但你要做的事情是你自己決定的（自己傳進函式裡）。流程會像是</p>\\n<blockquote>人進去（參數傳進去） → 店家準備好環境（先對參數做一些處理 etc） → 人在裡面做自己的活動（在函式中執行自己的邏輯，也就是 block）→ 店家收拾 → 人出來（函式結束）</blockquote>\\n<pre>def use_space(guests, &amp;activity_block)<br>  # environment setup <br>  # (turn on the light, prepare seats for each guest etc.) <br>  ...</pre>\\n<pre>  # guests do their activity<br>  activity_block.call</pre>\\n<pre>  # environment cleanup<br>  ...<br>end</pre>\\n<p>大概是為了要讓讀者好理解（還有不要嚇壞讀者），參考書或是網路上解釋 block 的文件給的例子大都是「直接用 method 也可以解決」的情況，但是簡單的用法就無法彰顯 block 的威力，所以當時才讓我困惑這麼久。</p>\\n<p>既然現在知道 block 威力了，以後就更知道該在什麼時刻派他出場了！耶嘿！</p>\\n<h4>References</h4>\\n<div>\\n<a href=\"http://rubymonk.com/learning/books/4-ruby-primer-ascent/chapters/18-blocks/lessons/54-yield\" data-href=\"http://rubymonk.com/learning/books/4-ruby-primer-ascent/chapters/18-blocks/lessons/54-yield\" class=\"markup--anchor markup--mixtapeEmbed-anchor\" title=\"http://rubymonk.com/learning/books/4-ruby-primer-ascent/chapters/18-blocks/lessons/54-yield\" rel=\"nofollow\"><strong class=\"markup--strong markup--mixtapeEmbed-strong\">RubyMonk - Interactive ruby tutorials to learn Ruby</strong><br>rubymonk.com</a><a href=\"http://rubymonk.com/learning/books/4-ruby-primer-ascent/chapters/18-blocks/lessons/54-yield\" class=\"js-mixtapeImage mixtapeImage u-ignoreBlock\" data-media-id=\"610fe05179548ca9f61a6d0bce2bba7d\" data-thumbnail-img-id=\"0*eTyfK-oAX0ix6MGd\" style=\"background-image: url(https://cdn-images-1.medium.com/fit/c/320/320/0*eTyfK-oAX0ix6MGd);\"></a>\\n</div>\\n<div>\\n<a href=\"https://blog.appsignal.com/2018/09/04/ruby-magic-closures-in-ruby-blocks-procs-and-lambdas.html\" data-href=\"https://blog.appsignal.com/2018/09/04/ruby-magic-closures-in-ruby-blocks-procs-and-lambdas.html\" class=\"markup--anchor markup--mixtapeEmbed-anchor\" title=\"https://blog.appsignal.com/2018/09/04/ruby-magic-closures-in-ruby-blocks-procs-and-lambdas.html\" rel=\"nofollow\"><strong class=\"markup--strong markup--mixtapeEmbed-strong\">Closures in Ruby: Blocks, Procs and Lambdas</strong><br>blog.appsignal.com</a><a href=\"https://blog.appsignal.com/2018/09/04/ruby-magic-closures-in-ruby-blocks-procs-and-lambdas.html\" class=\"js-mixtapeImage mixtapeImage u-ignoreBlock\" data-media-id=\"bf46b9a7ba90f6156415a75642e5e7e2\" data-thumbnail-img-id=\"0*TrjI1Wg4U8c1FaBF\" style=\"background-image: url(https://cdn-images-1.medium.com/fit/c/320/320/0*TrjI1Wg4U8c1FaBF);\"></a>\\n</div>\\n<p><a href=\"http://rubyer.me/blog/917/\" data-href=\"http://rubyer.me/blog/917/\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener nofollow noopener\" target=\"_blank\">http://rubyer.me/blog/917/</a></p><p>文章同步發表於 <a href=\"https://medium.com/@jinghua.shih\">Medium</a>。",
        "status": 1,
        "description": "順便聊聊 Proc 與 lambda",
        "created_at": "2019-04-01T13:07:07.110236",
        "updated_at": "2020-02-02T05:19:30.361181",
        "slug": "ruby-如何理解-ruby-block",
        "medium_url": "https://medium.com/@jinghua.shih/ruby-%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3-ruby-block-2387b74f188b"
    },
    {
        "id": 24,
        "title": "[Rails 效能優化] 資料庫關聯查詢",
        "body": "<p></p>\\n<p>最近一次面試中討論到了一些 Rails 效能優化的問題，讓我驚覺以前還真的沒有仔細思考過當程式碼放在一個高流量環境下會出現的狀況。剛好最近回顧到 <a href=\"https://ihower.tw/rails/performance.html\" data-href=\"https://ihower.tw/rails/performance.html\" class=\"markup--anchor markup--p-anchor\" rel=\"noopener nofollow\" target=\"_blank\">ihower 的這篇文章</a>，發現裡面提到了不少面試討論到的觀念，又剛好看到其他相關主題的文章，所以擇日不直撞日，就打鐵趁熱來整理一下。</p>\\n<p>原本只想寫一篇的，但現在看來會變成一系列文章了（我怎麼不意外呢）。總之，這篇會聚焦在討論從 N+1 queries 問題衍伸出來的 <code class=\"markup--code markup--p-code\">includes</code> /<code class=\"markup--code markup--p-code\">preload</code> /<code class=\"markup--code markup--p-code\">eager_load</code> /<code class=\"markup--code markup--p-code\">joins</code> 使用情境，還有用資料庫實際測速結果。</p>\\n<p>（下一篇：<a href=\"https://jennycodes.me/posts/rails-%E7%B6%B2%E7%AB%99%E6%95%88%E8%83%BD%E5%84%AA%E5%8C%96%E4%BA%8C%E8%B3%87%E6%96%99%E5%BA%AB%E7%B4%A2%E5%BC%95-database-index\" data-href=\"https://jennycodes.me/posts/rails-%E7%B6%B2%E7%AB%99%E6%95%88%E8%83%BD%E5%84%AA%E5%8C%96%E4%BA%8C%E8%B3%87%E6%96%99%E5%BA%AB%E7%B4%A2%E5%BC%95-database-index\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">[Rails 效能優化] 資料庫索引 Database Indexing</a>）</p>\\n<h3>效能問題</h3>\\n<blockquote>效能問題其實可以分成兩種，一種是完全沒有意識到抽象化工具、開發框架的效能盲點，而寫下了執行效能差勁的程式碼。另一種則是對現有程式的效能不滿意，研究如何最佳化，例如利用快取機制隔離執行速度較慢的高階程式，來大幅提昇執行效能。</blockquote>\\n<p>摘錄自<a href=\"https://ihower.tw/rails/performance.html\" data-href=\"https://ihower.tw/rails/performance.html\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\"> Ruby on Rails 實戰聖經</a>。</p>\\n<p>這邊提到的兩種效能問題我自己是歸類為「程式碼之內」與「程式碼之外」。程式碼之內的問題就是自己的錯，也就是修改程式碼就可以改善的，程式碼之外的問題就是…不是自己的錯XD 所以要用像是快取的外部工具才能讓效能更上一層樓。以下討論的都是針對第一種問題的優化方式。</p>\\n<h3>ActiveRecord 的小陷阱</h3>\\n<p>ActiveRecord 提供了一個很方便的 ORM (<a href=\"https://en.wikipedia.org/wiki/Object-relational_mapping\" data-href=\"https://en.wikipedia.org/wiki/Object-relational_mapping\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">Object Relational Mapping</a>) 介面，把資料庫的操作抽象化，讓我們可以直接用 Ruby 語言下資料庫指令，經過介面轉換變成 SQL 語言去操作資料庫。但存取資料庫是一種相對緩慢的 I/O 操作，除了每一次 query 都會花時間，回傳結果的記憶體佔用問題也要留意。</p>\\n<h4>N + 1 查詢</h4>\\n<p>這大概是 Rails 最經典的問題了。Rails 的 association 機制讓我們可以輕輕鬆鬆的存取兩個有關連的物件，如下：</p>\\n<pre># model<br>class Speaker &lt; ActiveRecord<br>  has_many :talks<br>end</pre>\\n<pre>class Talk &lt; ActiveRecord <br>  belongs_to :speaker<br>end</pre>\\n<p>假設今天我們創建了兩個 model，<code class=\"markup--code markup--p-code\">Speaker</code> &amp; <code class=\"markup--code markup--p-code\">Talk</code>，並且他們之間有一個多對一的關聯，那麼我們可以用 <code class=\"markup--code markup--p-code\">Speaker.first.talks</code> 來找到 <code class=\"markup--code markup--p-code\">Talk</code> 資料表 <code class=\"markup--code markup--p-code\">speaker_id == 1</code> 的所有資料。單一例子沒有問題，問題出在我們很可能會自然而然地就寫出 <code class=\"markup--code markup--p-code\">Speaker.all.map{ |speaker| speaker.talks }</code> 這種句子。</p>\\n<p>表面上，這個式子看起來很合理，但是去看實際 SQL query 的呼叫，我們會發現它除了使用了一個 query 來取出<code class=\"markup--code markup--p-code\">Speaker</code>資料表中的資料之外，同時也在迭代每筆資料時，一邊呼叫 query 來從 <code class=\"markup--code markup--p-code\">Talk</code> 資料表取出資料，於是這條式子總共會造成 N+1 (N 在這是 Author 資料數量) 個 query。前面提到，存取資料庫是一個緩慢的操作，所以 query 能免則免，當資料量大的時候，N+1 query 造成的效能問題會難以忽視。</p>\\n<p>最常見的解決方式是使用 ActiveRecord 提供的 <code class=\"markup--code markup--p-code\">includes</code> 方法。將 <code class=\"markup--code markup--p-code\">Speaker.all.map{ |speaker| speaker.talks}</code> 改成 <code class=\"markup--code markup--p-code u-paddingRight0 u-marginRight0\">Speaker<strong class=\"markup--strong markup--p-strong\">.includes(:talks)</strong>.map{ |speaker| speaker.talks }</code> ，則發出的 query 總數會從 N+1 變成 2，一條存取 <code class=\"markup--code markup--p-code\">Speaker</code>，一條存取 <code class=\"markup--code markup--p-code\">Talk</code>。</p>\\n<h4>用了 includes 就一定比較快嗎？</h4>\\n<p>好問題。其實除了<code class=\"markup--code markup--p-code\">includes</code>，Rails 還提供了 <code class=\"markup--code markup--p-code\">preload</code>， <code class=\"markup--code markup--p-code\">eager_load</code>與 <code class=\"markup--code markup--p-code\">joins</code> 三種結合查詢的方法。我們來一個一個看。</p>\\n<h4>joins 使用情境</h4>\\n<p><code class=\"markup--code markup--p-code\">:joins</code> 使用 SQL 的 <code class=\"markup--code markup--p-code\">INNER JOIN</code> 方法，不會真的把關聯的資料取出來。如果你只是想要篩選結果，或是觀察關聯物件的某些屬性質，那麼使用 <code class=\"markup--code markup--p-code\">:joins</code> 是最有效率的，不會殺雞用到牛刀。不過要注意，如果你想要做的事是存取關聯物件本身，那麼 <code class=\"markup--code markup--p-code\">:joins</code> 還是會造成 N+1 問題。</p>\\n<figure class=\"text-center\"><script src=\"https://gist.github.com/jenny-codes/26d2e5ffa61798ad3ef92b5916a577e0.js\"></script><figcaption class=\"imageCaption\"><a href=\"https://gist.github.com/jenny-codes/26d2e5ffa61798ad3ef92b5916a577e0\" data-href=\"https://gist.github.com/jenny-codes/26d2e5ffa61798ad3ef92b5916a577e0\" class=\"markup--anchor markup--figure-anchor\" rel=\"nofollow noopener\" target=\"_blank\">https://gist.github.com/jenny-codes/26d2e5ffa61798ad3ef92b5916a577e0</a></figcaption></figure><h4>preload 使用情境</h4>\\n<p>使用<code class=\"markup--code markup--p-code\">includes</code>時，Rails 其實會在背地裡根據你的呼叫情境產生不同的 SQL 語法。<a href=\"https://medium.com/gusto-engineering/a-visual-guide-to-using-includes-in-rails-700a91cd3095\" data-href=\"https://medium.com/gusto-engineering/a-visual-guide-to-using-includes-in-rails-700a91cd3095\" class=\"markup--anchor markup--p-anchor\" target=\"_blank\">這篇文章</a>解釋得不錯。<code class=\"markup--code markup--p-code\">preload</code> 是 <code class=\"markup--code markup--p-code\">includes</code> 默認的 query 生產方式，會產生兩條 query：一條存取主要資料表，一條加載關聯數據。</p>\\n<p>大部分的時候，可以直接把兩者代換，如下面兩個指令等價。</p>\\n<pre># where 'includes' and 'preload' are interchangeable:</pre>\\n<pre>Speaker.<strong class=\"markup--strong markup--pre-strong\">includes</strong>(:talks).map { |speaker| speaker.talks }<br>Speaker.<strong class=\"markup--strong markup--pre-strong\">preload</strong>(:talks).map  { |speaker| speaker.talks }</pre>\\n<h4>eager_load 使用情境</h4>\\n<p><code class=\"markup--code markup--p-code\">eager_load</code>使用 SQL 的 <code class=\"markup--code markup--p-code\">LEFT OUTER JOIN</code> 方法，查詢的時候只會產生一個語句，直接加載所有的關聯數據。如果我們使用 <code class=\"markup--code markup--p-code\">includes</code>用了進階篩選/排序（e.g. <code class=\"markup--code markup--p-code\">where</code> &amp; <code class=\"markup--code markup--p-code\">sort</code>），那麼也可以使用 <code class=\"markup--code markup--p-code\">eager_load</code> 替換：</p>\\n<pre># where 'includes' can be replaced by 'eager_load' (with adjustment)</pre>\\n<pre>Speaker<strong class=\"markup--strong markup--pre-strong\">.includes</strong>(:talks).where( 'talks.topic = \"coding\"' )<strong class=\"markup--strong markup--pre-strong\">.references(:talks)<br></strong>Speaker<strong class=\"markup--strong markup--pre-strong\">.eager_load</strong>(:talks).where( 'talks.topic = \"coding\"' )</pre>\\n<h4>includes, preload 與 eager_load 實際上產生的 queries：</h4>\\n<figure class=\"text-center\"><script src=\"https://gist.github.com/jenny-codes/ffc3f177e8de163e81af9c488e8cfd45.js\"></script><figcaption class=\"imageCaption\"><a href=\"https://gist.github.com/jenny-codes/ffc3f177e8de163e81af9c488e8cfd45\" data-href=\"https://gist.github.com/jenny-codes/ffc3f177e8de163e81af9c488e8cfd45\" class=\"markup--anchor markup--figure-anchor\" rel=\"nofollow noopener\" target=\"_blank\">https://gist.github.com/jenny-codes/ffc3f177e8de163e81af9c488e8cfd45</a></figcaption></figure><h4>所以說誰比較快？</h4>\\n<p>其實這沒有一定的答案，端看你的資料筆數與查詢語句複雜程度。Rails 判斷 <code class=\"markup--code markup--p-code\">:includes</code> 要分給 <code class=\"markup--code markup--p-code\">:preload</code> 還是 <code class=\"markup--code markup--p-code\">:eager_load</code> 也不是依照實際運行的效率。不管怎麼樣，我們來使用 <a href=\"https://github.com/evanphx/benchmark-ips\" data-href=\"https://github.com/evanphx/benchmark-ips\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">benchmark-ips</a> 來測看看。我用來測試的資料庫裡面有兩張資料表 <code class=\"markup--code markup--p-code\">Speaker</code> 與 <code class=\"markup--code markup--p-code\">Talk</code>，剛好就是這篇文章舉的例子（所謂深謀遠慮），是一對多的關係。他們各自的資料筆數是 1873 與 1576。</p>\\n<p>這是我的程式碼：</p>\\n<figure class=\"text-center\"><script src=\"https://gist.github.com/jenny-codes/4cc9cb1747f3a2ce2f393282fdaf2ffc.js\"></script><figcaption class=\"imageCaption\"><a href=\"https://gist.github.com/jenny-codes/4cc9cb1747f3a2ce2f393282fdaf2ffc\" data-href=\"https://gist.github.com/jenny-codes/4cc9cb1747f3a2ce2f393282fdaf2ffc\" class=\"markup--anchor markup--figure-anchor\" rel=\"nofollow noopener\" target=\"_blank\">https://gist.github.com/jenny-codes/4cc9cb1747f3a2ce2f393282fdaf2ffc</a></figcaption></figure><p>測試三次，這是其中一次結果：</p>\\n<figure class=\"text-center\"><img class=\"lazy\" data-src=\"https://cdn-images-1.medium.com/max/1600/1*od5Kp1bUWc9swnCtv_DDsg.png\"><figcaption class=\"imageCaption\">preload vs eager_load vs includes vs joins</figcaption></figure><ol>\\n<li name=\"9d39\" id=\"9d39\" class=\"graf graf--li graf-after--figure\">基本上，放 <code class=\"markup--code markup--li-code\">:joins</code> 進來比其實不公平，這邊只是想要強調如果有用 <code class=\"markup--code markup--li-code\">:joins</code> 就可以處理好的情況，那就盡量用 <code class=\"markup--code markup--li-code\">:joins</code>。</li>\\n<li name=\"1d77\" id=\"1d77\" class=\"graf graf--li graf-after--li\">三次測試中，速度由到快慢的順序都是 <code class=\"markup--code markup--li-code\">joins &gt;&gt; preload ~= includes &gt; eager_load</code>。中間的 <code class=\"markup--code markup--li-code\">preload ~= includes</code> 非常合理因為在這種情況下，<code class=\"markup--code markup--li-code\">:includes</code> 跟 <code class=\"markup--code markup--li-code\">:preload</code> 的行為一樣。 如果再排除掉 <code class=\"markup--code markup--li-code\">:joins</code>，那麼這次測試的結果是 <code class=\"markup--code markup--li-code\">:preload</code> 的速度會比 <code class=\"markup--code markup--li-code\">:eager_load</code>快一點。</li>\\n<li name=\"b372\" id=\"b372\" class=\"graf graf--li graf-after--li\">網路上也可以找到其他人的測試結果，比如<a href=\"http://www.chrisrolle.com/en/blog/benchmark-preload-vs-eager_load\" data-href=\"http://www.chrisrolle.com/en/blog/benchmark-preload-vs-eager_load\" class=\"markup--anchor markup--li-anchor\" rel=\"noopener nofollow\" target=\"_blank\">這篇</a>與<a href=\"https://medium.com/gusto-engineering/a-visual-guide-to-using-includes-in-rails-700a91cd3095\" data-href=\"https://medium.com/gusto-engineering/a-visual-guide-to-using-includes-in-rails-700a91cd3095\" class=\"markup--anchor markup--li-anchor\" target=\"_blank\">這篇</a>。</li>\\n</ol>\\n<h3>後記</h3>\\n<p>其實本來自己比較想研究的問題是資料庫 transaction 還有 counter cahce， N+1 的問題我只是想要輕鬆帶過、快速交待，但是資料一查下去，就…變成…一整篇…文章…了。不說了。不過反正每次寫文章，收穫最大的總是自己，像是暸解 <code class=\"markup--code markup--p-code\">includes</code>與它的好朋友們的差異其實真的很實用。</p><p>雖然已盡能力所及地確保資料的正確性，但我恐怕還是會有不對/不精確的觀念或用字，如果願意<a href=\"https://jennycodes.herokuapp.com/contact\" data-href=\"https://jennycodes.herokuapp.com/contact\" class=\"markup--anchor markup--p-anchor\" rel=\"noopener nofollow nofollow noopener nofollow noopener\" target=\"_blank\">指正我</a>的話我會非常感激！</p><h4>Random Gems 一些不太相關的資源</h4>\\n<p>那天發現了 <a href=\"https://github.com/JuanitoFatas/fast-ruby\" data-href=\"https://github.com/JuanitoFatas/fast-ruby\" class=\"markup--anchor markup--p-anchor\" rel=\"noopener nofollow\" target=\"_blank\">fast-ruby</a> 這個解了我很多心中疑惑、令人讚嘆的 project。之後來發文介紹！</p>\\n<h3>參考資料</h3>\\n<div>\\n<a href=\"https://ihower.tw/rails/performance.html\" data-href=\"https://ihower.tw/rails/performance.html\" class=\"markup--anchor markup--mixtapeEmbed-anchor\" title=\"https://ihower.tw/rails/performance.html\" rel=\"nofollow\"><strong class=\"markup--strong markup--mixtapeEmbed-strong\">Ruby on Rails 實戰聖經 | 網站效能</strong><br>ihower.tw</a><a href=\"https://ihower.tw/rails/performance.html\" class=\"js-mixtapeImage mixtapeImage u-ignoreBlock\" data-media-id=\"4bdafafdae501ea144a1774fb980f082\" data-thumbnail-img-id=\"0*BAcpC9DbiwrZht2N\" style=\"background-image: url(https://cdn-images-1.medium.com/fit/c/320/320/0*BAcpC9DbiwrZht2N);\"></a>\\n</div>\\n<div>\\n<a href=\"https://blog.appsignal.com/2018/02/27/benchmarking-ruby-code.html\" data-href=\"https://blog.appsignal.com/2018/02/27/benchmarking-ruby-code.html\" class=\"markup--anchor markup--mixtapeEmbed-anchor\" title=\"https://blog.appsignal.com/2018/02/27/benchmarking-ruby-code.html\" rel=\"nofollow\"><strong class=\"markup--strong markup--mixtapeEmbed-strong\">Benchmarking Ruby code</strong><br>blog.appsignal.com</a><a href=\"https://blog.appsignal.com/2018/02/27/benchmarking-ruby-code.html\" class=\"js-mixtapeImage mixtapeImage u-ignoreBlock\" data-media-id=\"c64d8ff1c41ced87dcdd25d0ed02a3df\" data-thumbnail-img-id=\"0*7JUETIW7lScl81-G\" style=\"background-image: url(https://cdn-images-1.medium.com/fit/c/320/320/0*7JUETIW7lScl81-G);\"></a>\\n</div>\\n<div>\\n<a href=\"https://ruby-china.org/topics/17866\" data-href=\"https://ruby-china.org/topics/17866\" class=\"markup--anchor markup--mixtapeEmbed-anchor\" title=\"https://ruby-china.org/topics/17866\" rel=\"nofollow\"><strong class=\"markup--strong markup--mixtapeEmbed-strong\">Preload、 Eagerload、 Includes 和 Joins · Ruby China</strong><br>ruby-china.org</a><a href=\"https://ruby-china.org/topics/17866\" class=\"js-mixtapeImage mixtapeImage u-ignoreBlock\" data-media-id=\"41e98b24a7701256a9a1d4f2442784bc\" data-thumbnail-img-id=\"0*kXVhnmVVBPg-8273\" style=\"background-image: url(https://cdn-images-1.medium.com/fit/c/320/320/0*kXVhnmVVBPg-8273);\"></a>\\n</div>\\n<div>\\n<a href=\"https://scoutapp.com/blog/activerecord-includes-vs-joins-vs-preload-vs-eager_load-when-and-where\" data-href=\"https://scoutapp.com/blog/activerecord-includes-vs-joins-vs-preload-vs-eager_load-when-and-where\" class=\"markup--anchor markup--mixtapeEmbed-anchor\" title=\"https://scoutapp.com/blog/activerecord-includes-vs-joins-vs-preload-vs-eager_load-when-and-where\" rel=\"nofollow\"><strong class=\"markup--strong markup--mixtapeEmbed-strong\">Making sense of ActiveRecord joins, includes, preload, and eager_load | Scout APM Blog</strong><br>scoutapp.com</a><a href=\"https://scoutapp.com/blog/activerecord-includes-vs-joins-vs-preload-vs-eager_load-when-and-where\" class=\"js-mixtapeImage mixtapeImage u-ignoreBlock\" data-media-id=\"1bd4e22559a3b98e17122f5337096916\" data-thumbnail-img-id=\"0*1WFT79kPlrjyEEdb\" style=\"background-image: url(https://cdn-images-1.medium.com/fit/c/320/320/0*1WFT79kPlrjyEEdb);\"></a>\\n</div>\\n<div>\\n<a href=\"https://medium.com/gusto-engineering/a-visual-guide-to-using-includes-in-rails-700a91cd3095\" data-href=\"https://medium.com/gusto-engineering/a-visual-guide-to-using-includes-in-rails-700a91cd3095\" class=\"markup--anchor markup--mixtapeEmbed-anchor\" title=\"https://medium.com/gusto-engineering/a-visual-guide-to-using-includes-in-rails-700a91cd3095\"><strong class=\"markup--strong markup--mixtapeEmbed-strong\">A Visual Guide to Using :includes in Rails</strong><br>medium.com</a><a href=\"https://medium.com/gusto-engineering/a-visual-guide-to-using-includes-in-rails-700a91cd3095\" class=\"js-mixtapeImage mixtapeImage u-ignoreBlock\" data-media-id=\"28c1f28dd4af65612a54a092a2775e7c\" data-thumbnail-img-id=\"0*NjAfxXjIQARCqUg_.png\" style=\"background-image: url(https://cdn-images-1.medium.com/fit/c/320/320/0*NjAfxXjIQARCqUg_.png);\"></a>\\n</div>\\n<div>\\n<a href=\"https://github.com/evanphx/benchmark-ips\" data-href=\"https://github.com/evanphx/benchmark-ips\" class=\"markup--anchor markup--mixtapeEmbed-anchor\" title=\"https://github.com/evanphx/benchmark-ips\" rel=\"nofollow\"><strong class=\"markup--strong markup--mixtapeEmbed-strong\">evanphx/benchmark-ips</strong><br>github.com</a><a href=\"https://github.com/evanphx/benchmark-ips\" class=\"js-mixtapeImage mixtapeImage u-ignoreBlock\" data-media-id=\"79043551bb279316da2dacfe7970f367\" data-thumbnail-img-id=\"0*5vikd3yg4q8iSVQa\" style=\"background-image: url(https://cdn-images-1.medium.com/fit/c/320/320/0*5vikd3yg4q8iSVQa);\"></a>\\n</div><p>文章同步發表於 <a href=\"https://medium.com/@jinghua.shih\">Medium</a>。",
        "status": 1,
        "description": "你以為只懂 includes 就夠了嗎",
        "created_at": "2019-02-20T14:48:44.553903",
        "updated_at": "2020-02-02T05:19:30.378749",
        "slug": "rails-activerecord-效能優化上關聯查詢",
        "medium_url": "https://medium.com/@jinghua.shih/rails-activerecord-%E6%95%88%E8%83%BD%E5%84%AA%E5%8C%96-%E4%B8%8A-%E9%97%9C%E8%81%AF%E6%9F%A5%E8%A9%A2-75ca79f510b3"
    },
    {
        "id": 38,
        "title": "Automatic Files Upload to Github on Mac",
        "body": "<p></p>\\n<p>I have been planning to do this for some time. On my computer desktop there is a folder named ‘notes’ where I keep my, well, notes. I use Git to version control it (because why not), so I can access the notes from both my work and personal computer.</p>\\n<p>It is convenient–no additional software, a terminal and a few commands are all I need–but not enough. I need to issue the commands to upload the files everyday. Even if the commands are just three lines. Even if it takes only 10 seconds. More importantly, if I forget to do it, the notes would not get updated (duh), which sometimes can be annoying.</p>\\n<p>So the idea is simple. Write a script that contains the necessary commands for uploading(a.k.a. the three lines), and tell the computer to run it at a schedule. For the first part we need <a href=\"https://en.wikipedia.org/wiki/Shell_script\" data-href=\"https://en.wikipedia.org/wiki/Shell_script\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">shell script</a>. For the second part we need <a href=\"https://en.wikipedia.org/wiki/Launchd\" data-href=\"https://en.wikipedia.org/wiki/Launchd\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">launchd</a>.</p>\\n<h3>The Shell Script</h3>\\n<p>A shell script is basically a file that you can execute in the shell.</p>\\n<p>It can be as simple as a glob of shell commands lumped together (example below). Or it can be as powerful as system protection and data tracking.</p>\\n<p>The language used in shell scripts are called <a href=\"https://en.wikipedia.org/wiki/Scripting_language\" data-href=\"https://en.wikipedia.org/wiki/Scripting_language\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">scripting language</a>. You might have heard of this term along with dynamic <a href=\"https://en.wikipedia.org/wiki/High-level_programming_language\" data-href=\"https://en.wikipedia.org/wiki/High-level_programming_language\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">high-level languages</a> like Python or Ruby. These languages are executed line by line–you see the immediate result of the execution of each line. On the other end of the spectrum would be <a href=\"https://en.wikipedia.org/wiki/Low-level_programming_language\" data-href=\"https://en.wikipedia.org/wiki/Low-level_programming_language\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">low-level languages</a>, the ones that need to be compiled first before running, like C.</p>\\n<p>In our case, we will use <a href=\"https://en.wikipedia.org/wiki/Bash_%28Unix_shell%29\" data-href=\"https://en.wikipedia.org/wiki/Bash_(Unix_shell)\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">Bash</a> syntax:</p>\\n<figure class=\"text-center\"><script src=\"https://gist.github.com/jenny-codes/8862a38a72df5ed403421b251a78315e.js\"></script><figcaption class=\"imageCaption\"><a href=\"https://gist.github.com/jenny-codes/8862a38a72df5ed403421b251a78315e\" data-href=\"https://gist.github.com/jenny-codes/8862a38a72df5ed403421b251a78315e\" class=\"markup--anchor markup--figure-anchor\" rel=\"nofollow noopener\" target=\"_blank\">https://gist.github.com/jenny-codes/8862a38a72df5ed403421b251a78315e</a></figcaption></figure><p>And you thought writing a shell script is hard.</p>\\n<p>The first line of the script I unabashedly presented above is</p>\\n<pre>#!/bin/bash</pre>\\n<p>It tells the system that this script is to be executed by bash. Similarly, you can replace the line with <code class=\"markup--code markup--p-code\">#!/usr/bin/ruby</code> to execute the script with Ruby, or any other scripting language to your taste.</p>\\n<p>The second line translates as “if there is an argument passed in, assign the value to variable <code class=\"markup--code markup--p-code\">msg</code>, or else assign ‘regular update’ to <code class=\"markup--code markup--p-code\">msg</code>.” The variable <code class=\"markup--code markup--p-code\">msg</code>, as we can see at line five, will be the commit message of this upload.</p>\\n<p>Put this script anywhere you like. Call it whatever you want. I put my file directly at <code class=\"markup--code markup--p-code\">usr/local/bin</code>, and named it <code class=\"markup--code markup--p-code\">git_push_all</code>. Note that some will add a suffix <code class=\"markup--code markup--p-code\">.sh</code> to the script filename, but this is not obligatory.</p>\\n<p>The rest really needs no further explaining, but</p>\\n<h4>Make sure you script is executable</h4>\\n<p>is very important. Type this line if you haven’t already:</p>\\n<pre><code class=\"markup--code markup--pre-code\">chmod +x filename.sh</code></pre>\\n<p>The command <code class=\"markup--code markup--p-code\">chmod</code>, short for ‘change mode’, changes permissions on the file <code class=\"markup--code markup--p-code\">filename.sh</code>. Argument <code class=\"markup--code markup--p-code\">+x</code> grants execution permission to all three categories of users (<code class=\"markup--code markup--p-code\">the file owner</code>, <code class=\"markup--code markup--p-code\">the group where the file belongs</code>, <code class=\"markup--code markup--p-code\">others</code>). We can use <code class=\"markup--code markup--p-code\">ls -l</code> in the directory to double check. <a href=\"https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/4/html/Step_by_Step_Guide/s1-navigating-ownership.html\" data-href=\"https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/4/html/Step_by_Step_Guide/s1-navigating-ownership.html\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">See this good RedHat article</a> for detailed instructions and explanations.</p>\\n<h4>Test the Script</h4>\\n<p>You can test it by navigating to the directory where you put the file and type <code class=\"markup--code markup--p-code\">./git_push_all</code>. Or if you put it in one of your execution paths (declared in <a href=\"https://en.wikipedia.org/wiki/PATH_%28variable%29\" data-href=\"https://en.wikipedia.org/wiki/PATH_(variable)\" class=\"markup--anchor markup--p-anchor\" rel=\"noopener nofollow\" target=\"_blank\">$PATH environment variable</a>) like I did, you can use <code class=\"markup--code markup--p-code\">git_push_all</code> anywhere you wish. Of course, it should be used in a git directory or it would be useless. You should see the usual output messages printed on the console.</p>\\n<h3>Automate Our Script with Launchd</h3>\\n<p>Now that we have our script ready, our next step is put it on our machine’s schedule so it can run by itself. We will use MacOS’ built-in <a href=\"https://en.wikipedia.org/wiki/Launchd\" data-href=\"https://en.wikipedia.org/wiki/Launchd\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">Launchd</a> for our task. Launchd is a <strong class=\"markup--strong markup--p-strong\">service management framework</strong> on the operating system level used by MacOS. Its job is to manage various <a href=\"https://en.wikipedia.org/wiki/Daemon_%28computing%29\" data-href=\"https://en.wikipedia.org/wiki/Daemon_(computing)\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">daemons</a> (a fancy term for ‘background programs’) in the system.</p>\\n<h4>Launchd vs Cron</h4>\\n<p>When it comes to job scheduler, the term ‘cron’ usually comes along. Perplexing enough, MacOS provides a service named <strong class=\"markup--strong markup--p-strong\">crontab</strong> as well, which seems to have the same functionality as Launchd. It is worth investing some time to figure out their relationship. Let us look at the <a href=\"https://en.wikipedia.org/wiki/Man_page\" data-href=\"https://en.wikipedia.org/wiki/Man_page\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">man</a> definition first:</p>\\n<p><strong class=\"markup--strong markup--p-strong\">[CRON]</strong></p>\\n<blockquote>NAME<br> cron — daemon to execute scheduled commands (Vixie Cron)</blockquote>\\n<blockquote>…(omitted)</blockquote>\\n<blockquote>DESCRIPTION<br> <strong class=\"markup--strong markup--blockquote-strong\">The cron utility is launched by launchd(8)</strong>…(omitted)</blockquote>\\n<p><strong class=\"markup--strong markup--p-strong\">[CRONTAB]</strong></p>\\n<blockquote>NAME<br> crontab — maintain crontab files for individual users (V3)</blockquote>\\n<blockquote>…(omitted)</blockquote>\\n<blockquote>DESCRIPTION<br>…(omitted)</blockquote>\\n<blockquote>(Darwin note: Although cron(8) and crontab(5) are officially supported under Darwin, <strong class=\"markup--strong markup--blockquote-strong\">their functionality has been absorbed into launchd(8)</strong>, which provides a more flexible way of automatically executing commands. See launchctl(1) for more information.)</blockquote>\\n<p><strong class=\"markup--strong markup--p-strong\">[LAUNCHD]</strong></p>\\n<blockquote>NAME<br> launchd — System wide and per-user daemon/agent manager</blockquote>\\n<blockquote>DESCRIPTION<br> launchd manages processes, both for the system as a whole and for individual users.</blockquote>\\n<blockquote>…(omitted)</blockquote>\\n<blockquote>During boot launchd is invoked by the kernel to run as the first process on the system and to further bootstrap the rest of the system.</blockquote>\\n<p><strong class=\"markup--strong markup--p-strong\">[LAUNCHCTL]</strong></p>\\n<blockquote>NAME<br> launchctl — Interfaces with launchd</blockquote>\\n<blockquote>…(omitted)</blockquote>\\n<blockquote>DESCRIPTION<br> launchctl interfaces with launchd to manage and inspect daemons, agents and XPC services.</blockquote>\\n<p>I know we all read through the above definitions word by word, with patience and grace. So here is a brief recap:</p>\\n<ol>\\n<li name=\"37eb\" id=\"37eb\" class=\"graf graf--li graf-after--p\">Launchd is the manager of daemons/agents (both system-wide and per-user).</li>\\n<li name=\"2143\" id=\"2143\" class=\"graf graf--li graf-after--li\">Cron is a daemon to execute scheduled commands.</li>\\n<li name=\"c3c1\" id=\"c3c1\" class=\"graf graf--li graf-after--li\">When a job is assigned to cron, under the hood it is launchd that does the work.</li>\\n</ol>\\n<p>Thus we deduct: Launchd manages cron, has the functionality of cron, and does the real job for cron.</p>\\n<p>Who says life is fair?</p>\\n<p>While we are questioning cron’s reason of existence[1], let us use launchd to prop up our script.</p>\\n<h4>Launchctl</h4>\\n<p>To communicate with launchd, we use the interface <strong class=\"markup--strong markup--p-strong\">launchctl</strong>. Three steps are required: (1) Write a plist file (where all the configurations for this job are) (2) Place the plist file under <code class=\"markup--code markup--p-code\">~/Library/LaunchAgents</code> (3) Load the file.</p>\\n<h4>(1) Write a plist file</h4>\\n<figure class=\"text-center\"><script src=\"https://gist.github.com/jenny-codes/3ad160580627c34f98f1dca173fb821f.js\"></script><figcaption class=\"imageCaption\"><a href=\"https://gist.github.com/jenny-codes/3ad160580627c34f98f1dca173fb821f\" data-href=\"https://gist.github.com/jenny-codes/3ad160580627c34f98f1dca173fb821f\" class=\"markup--anchor markup--figure-anchor\" rel=\"nofollow noopener\" target=\"_blank\">https://gist.github.com/jenny-codes/3ad160580627c34f98f1dca173fb821f</a></figcaption></figure><p>Fill in the blanks, and we’re good to go.</p>\\n<p>In this plist, the program at <code class=\"markup--code markup--p-code\">/usr/local/bin/git_pushall</code>, which we just wrote, will be run twice a day, respectively at 10:03 and 20:03. If this is your first time dealing with plist, you may need a little time to get used to (it took me some 20 minutes to figure this out–I’m sure you can do better). Basically the &lt;key&gt; is the field of the configuration option, and the next line is its value. <a href=\"https://en.wikipedia.org/wiki/Launchd#Property_list\" data-href=\"https://en.wikipedia.org/wiki/Launchd#Property_list\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">Here</a> is a list of the keys you can configure.</p>\\n<p>Also, run this line to check if your plist syntax is valid:</p>\\n<pre>plutil -lint your_plist_file.plist</pre>\\n<h4>(2) Put the plist file into <code class=\"markup--code markup--h4-code\">~/Library/LaunchAgents</code>\\n</h4>\\n<p>There are several locations we can place our plist files:</p>\\n<pre># Per-user agents provided by the user.<br>~/Library/LaunchAgents </pre>\\n<pre># Per-user agents provided by the administrator.<br>/Library/LaunchAgents </pre>\\n<pre># System-wide daemons provided by the administrator.<br>/Library/LaunchDaemons</pre>\\n<pre># Per-user agents provided by Apple.<br>/System/Library/LaunchAgents </pre>\\n<pre># System-wide daemons provided by Apple.<br>/System/Library/LaunchDaemons</pre>\\n<p>In our case, we will put our file under ~/Library/LaunchAgents.</p>\\n<h4>(3) Load the file</h4>\\n<p>The commands we need:</p>\\n<pre># See the services list.<br>launchctl list</pre>\\n<pre># Load your plist<br>launchctl load [file name]</pre>\\n<pre># Unload the service<br>launchctl unload [file name]</pre>\\n<pre># Start the service (immediately, regardless of schedule)<br>launchctl start [service label]</pre>\\n<pre># remove ghost services (no longer used)<br>launchctl remove [service label]</pre>\\n<p>We use launchctl load [file name] to load the plist file onto launchctl. Use launchctl list to see if it is loaded, and <code class=\"markup--code markup--p-code\">launchctl start [service label]</code> for testing. If you make any changes after the upload, unload and load it again.</p>\\n<p>Note that some commands require [file name] while others require [service label], where you define in your plist under key <code class=\"markup--code markup--p-code\">label</code>.</p>\\n<p>Voila! That’s pretty much it!</p>\\n<h4>Note</h4>\\n<p>[1] <a href=\"https://developer.apple.com/library/archive/documentation/MacOSX/Conceptual/BPSystemStartup/Chapters/ScheduledJobs.html\" data-href=\"https://developer.apple.com/library/archive/documentation/MacOSX/Conceptual/BPSystemStartup/Chapters/ScheduledJobs.html\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">Apple’s document</a>: ‘Although it is still supported, <code class=\"markup--code markup--p-code\">cron</code> is not a recommended solution. It has been deprecated in favor of <code class=\"markup--code markup--p-code\">launchd</code>.’</p><p>文章同步發表於 <a href=\"https://medium.com/@jinghua.shih\">Medium</a>。",
        "status": 1,
        "description": "with shell scripts and Launchd",
        "created_at": "2019-05-11T12:16:59.871667",
        "updated_at": "2020-02-02T05:19:30.411663",
        "slug": "automatic-files-upload-to-github-on-mac",
        "medium_url": "https://medium.com/@jinghua.shih/automatic-files-upload-to-github-on-mac-71375d1ee281"
    },
    {
        "id": 80,
        "title": "2020 回顧與展望",
        "body": "<p> 新年到了，本來想要當沒事一樣直接催下去寫下一篇技術文章（然後一月就這樣過了），但想想畢竟過了一年，而 2019 年，現在回想起來，有不少值得紀念的里程碑—說實在還挺驕傲的。新年，當然也代表許願（新年新希望）的時間又到了。許了願，就要大聲說出來（還有要實現），所以技術文章還是先擱著，伸個懶腰、抖抖衣裳，帶著回顧與展望，好好迎接下一年。</p>\\n\\n\\n<p>（以下就隨心所欲地開始了）</p>\\n<h3 id=\"\">關關難過關關過</h3>\\n<p>關關難過關關過，不是一句繞口令，是自從 jennycodes 網站成立之初就一直掛在首頁上的一句<del>繞口令</del>話。其實我也忘了為什麼當初會選它，但是每次看到，總是有莫名的振奮人心的效果（大概這就是原因）。我想，這滿符合我的路程與心境，我也是一直這樣相信自己的。</p>\\n\\n<p>去年的新年新希望是開一個網站，寫技術文章，於是架了 <a href=\"https://jennycodes.me\">jennycodes</a> 。其實原本是想要一個禮拜寫一篇啦，不過這個堅持到六月就沒有了。唉。中間還停擺了兩個月左右（不過是正當理由，在<a href=\"https://jennycodes.me/posts/design-patterns\">寫IT 鐵人賽</a>）最後去年總共寫了三十篇文章，也漸漸摸索出適合自己的寫作步調。我很開心這個部落格沒有被中途棄養，算是給了自己一個交代。</p>\\n\\n<p>對我而言，寫作是件開心的事，但是很需要時間，所以最大的困難其實是如何做好時間規劃，才能夠讓部落格有定期產出。</p>\\n\\n<p>一年下來，寫技術文章帶給我的影響超乎想像。最重要的，是發現這是很適合自己的學習方式：選自己想要鑽研的題目、開始研究、消化、重新組織，整理成人看得懂的文字—雖然有時痛苦，但是經過這個淬煉歷程而留下來那些文字與思緒，讓我覺得非常超值。</p>\\n\\n<p>因緣際會之下，也因為部落格文章的關係，而在去年六月左右受邀去參加 OpenUP Summit (Polley 謝謝！）。對我而言這是很大的驚喜與鼓勵，在於寫出來的文章而被人看見與肯定，在於發現在不知不覺中，自己也走到了以前不曾想過會到達的地方（不是迷路）。當然前方的路還很長，但是這些加油打氣，都讓我對未來充滿信心。</p>\\n\\n<p>所以，我會繼續寫下去的，我們拭目以待。</p>\\n<h3 id=\"piccollage\">PicCollage</h3>\\n<p>當之無愧，PicCollage 是去年發生最重要的一件事。2019 年 2 月底，我以後端工程師實習生的身份加入。六月畢業後，成為正職。許多重要的成長與緣分，都在這裡。我遇到了許多又強又有趣的人、用心生活的人、真誠溫暖的人。說到底，人總是最重要的。這樣子的一群人創造出來的文化是我超超超超級喜歡的信任、開放與尊重。我們有很大的自由，也有很多說出來會讓人眼紅的福利（請洽我們的招募頁）、很舒服的辦公室（下午的那個陽光！🤤）......能夠在這樣子的地方工作，我何德何能。</p>\\n\\n<p>在這裏，很幸運地遇到了一個很棒的 coach （嗨彥廷）（解釋一下：「教練」，通常就是直屬主管，負責你的任務分配，也會跟你有每個禮拜一對一對談的時間，引導你的職涯成長），學了好多好多（坑也被推了很多好多）也經歷了一些 server team 的人們來來去去，但是每個曾經在這裡的人，我都不客氣地偷了點東西來。</p>\\n\\n<p>很多學習與成長。幾個月前一時興起，就邀了我的好工程師同事們一起參加了 IT 鐵人賽，最後大概十個人一起交出了 <a href=\"https://jennycodes.me/posts/design-patterns\">32 篇文章</a>。除了大家一起寫文章的樂趣（?），也順便得到了組織一個團隊，溝通、規劃、協調<del>（、催稿）</del>的經驗。</p>\\n\\n<p>好玩的事當然不只這個，比如說最近開始<a href=\"https://github.com/jenny-codes/aoc2019\">邊玩 Advent of Code 邊學 Elixir</a>，沒想到有幾個同事們也都感興趣，於是一起開了 Elixir 讀書會，感覺真好。</p>\\n\\n<p>今年開始，將要負起更多責任。變成組上暫時主要負責人，不再隨時有大腿抱，還要開始變成一個好大腿給別人抱，同時保持穩定交付。希望自己成為一個獨當一面，同時讓人信任與信賴 team player。</p>\\n\\n<p>在 PicCollage 就快要滿一年了。關關難過關關過，我可以的。</p>\\n<h3 id=\"\">大學畢業了</h3>\\n<p>沒什麼好說的，就是多了一張台大外文系的文憑。</p>\\n\\n<p>好啦，其實滿感謝自已大學五年的日子。感謝台大，因為\\n<ol>\\n<li> 地理位置超好—總區附近就有<strong>四</strong>間臺北市立圖書館的分館（！！？）、無數獨立書店、二手書店，還有超美的社圖（畢業後偶爾還會跑回去）。夫復何求！</li>\\n<li> 在這邊的水源二手車場撿到我的靈魂伴侶 Stephan Zweig（也可以叫它小黃）。現在還常常騎著它上班。</li>\\n<li> 讓我去了 UCLA 交換一年，沒有這一年就沒有現在的我。</li>\\n<li> 寬容的選課制度讓我修了很多外系的課（多到需要延畢一年把它們消化完）。</li>\\n<li> 人。再強調一次，人總是最重要的。</li></ol></p>\\n\\n<p>總之，畢業了，其實也不特別感傷。該留下的就會留下，好的回憶，我是帶著走了。</p>\\n<h3 id=\"\">繼續前進吧</h3>\\n<p>學習與工作之外，去年的生活中，有很多轉變與起伏，與許多的第一次。生活重心改變，失衡、迷惘、絕望、開心、驕傲、滿足，不斷旋轉著。</p>\\n\\n<p>有些回憶使人沉重，有些使人雀躍，有些使人成長。</p>\\n\\n<p>仍有所待，仍有所求，仍有所不足。</p>\\n\\n<p>新的一年，我會繼續<a href=\"https://jennycodes.me/about\">成為一個很強的後端工程師</a>，繼續督促自己寫文章，繼續兌現我該兌現的緣分，繼續學習。</p>\\n\\n<p>繼續前進吧！</p>\\n\\n<p>🐥</p>\\n",
        "status": 1,
        "description": "技術文章先擱一旁，伸個懶腰、抖抖衣裳，帶著回顧與展望，好好迎接下一年",
        "created_at": "2020-02-10T14:11:26.310483",
        "updated_at": "2020-02-10T14:16:51.098015",
        "slug": "2020-look-back-and-look-ahead",
        "medium_url": ""
    },
    {
        "id": 81,
        "title": "[Performance Speedup] Customizing GraphQL Tracing on NewRelic",
        "body": "<p>At PicCollage, one of server team's goals for the following three months is  optimizing the performance of our API services. To do optimization, our step one is to identify \"what\" should be optimized, among those numerous endpoints that the API provides. We can't fix a problem if we can't find it, of course. </p>\\r\\n\\r\\n<p>PicCollage uses NewRelic as the performance monitor for our Ruby on Rails API service. It makes life easier for us to go about our optimization mission. With NewRelic, we get real-time metrics (throughput, response time, etc,..) on different transactions, which can even be broken down to components for us to see what processes are the most time-consuming. In two words: it helps.</p>\\r\\n\\r\\n<p>Except that it didn't. As you may have already guessed (from the title), it has to do with GraphQL. Currently PicCollage API comes in both REST and GraphQL (see our <a href=\"https://jennycodes.me/posts?tag=GraphQL\">articles on GraphQL</a>). Due to the dynamic nature of GraphQL (in terms of query composition) and how NewRelic breaks down transactions, all requests coming through GraphQL API will be filed as one big <code>/grahql</code> route by default, whereas requests that come through REST API are nicely grouped by endpoint. When it comes to per-route performance analysis, the GraphQL routes become a headache. </p>\\r\\n\\r\\n<p><img alt=\"previously, GraphQL transactions were all grouped in one route\\r\\n\" class=\"lazy img-fluid\" data-src=\"https://user-images.githubusercontent.com/43872616/75088410-c4dd3a00-5587-11ea-9808-40025847556a.jpg\">\\r\\nAgain, as you may have already guessed (by the existence of this post), we have a solution for it. In the next sections I'll walk you through the two approaches you are encouraged to try, with code examples and real, just-out-of-the-oven NewRelic screenshots. </p>\\r\\n<h3 id=\"basic-info\">Basic Info</h3>\\r\\n<ul>\\r\\n<li>Our goal is to separate different GraphQL queries into different routes on NewRelic. </li>\\r\\n<li>We use Ruby on Rails, and <a href=\"https://graphql-ruby.org/\">GraphQL Ruby</a> for our GraphQL API.</li>\\r\\n<li>graphql-ruby provides a built-in NewRelic agent plugin, which we are also using. Below is our Schema before any changes.</li>\\r\\n</ul>\\r\\n\\r\\n<pre><code class=\"lang-ruby\">class RootSchema &lt; GraphQL::Schema\\r\\n  # ...(omitting unrelated part)\\r\\n\\r\\n  use GraphQL::Tracing::NewRelicTracing\\r\\n</code></pre>\\r\\n\\r\\n<p>There are two (reasonably feasible) ways to achieve our goal. The first is a one-liner solution, but with some limitations. The second requires more code, but you'll get tailor-made results in return. I say it's worth the trouble.</p>\\r\\n\\r\\n<blockquote>\\r\\n<p>bonus: I also ended up setting a custom attribute that records the full query on the report. It's another nuisance of NewRelic that's finally out of the way!</p>\\r\\n</blockquote>\\r\\n<h3 id=\"tracking-graphql-performance-by-query-the-one-liner\">Tracking GraphQL Performance by Query: The One Liner</h3>\\r\\n<p>The almighty graphql-ruby library gives us a convenient option in its integration with NewRelic. GraphQL has a concept called <a href=\"https://graphql.org/learn/queries/#operation-name\">operation name</a> for queries. Below is a quick example.</p>\\r\\n\\r\\n<pre><code class=\"lang-graphql\"># operation without a name\\r\\nquery {\\r\\n  ...\\r\\n}\\r\\n\\r\\n# operation with a name (i.e. a named operation)\\r\\nquery TheName {\\r\\n  ...\\r\\n}\\r\\n</code></pre>\\r\\n\\r\\n<p>If the queries that comes to you are already named operations, or if somehow you can make them so–congratulations! Pass in an optional argument (as shown below) and you shall read no more. <code>set_transaction_name</code> will tell the NewRelic agent to separate transactions by operation names.</p>\\r\\n\\r\\n<pre><code class=\"lang-ruby\">class RootSchema &lt; GraphQL::Schema\\r\\n  # ...(omitting unrelated part)\\r\\n\\r\\n  # Pass in the optional argument `set_transaction_name`\\r\\n  use GraphQL::Tracing::NewRelicTracing, set_transaction_name: true\\r\\n</code></pre>\\r\\n\\r\\n<p>And the result will be like this.</p>\\r\\n\\r\\n<p><img alt=\"GraphQL transactions with set_transaction_name option\" class=\"lazy img-fluid\" data-src=\"https://user-images.githubusercontent.com/43872616/75084879-58017a00-555e-11ea-8833-ddf79f58f49a.jpg\"></p>\\r\\n\\r\\n<p>One caveat, though. See the <code>GraphQL/query.anonymous</code>? That's what happens to the queries without names. If you're not in total control of the queries you receive, you can't be sure if they will all be named, or to take it furthur, named as expected.</p>\\r\\n\\r\\n<p>In our case, the end users of our GraphQL API are our Android team and iOS team. Currently, of the 10-ish queries they send, only one is named (which is the <code>.Feed</code> we see above). It's an easy operation to add names to the routes, but still it requires coordination and cross-team cooperation. But all we want is simple (or so I think): to monitor the routes with better granularity.</p>\\r\\n\\r\\n<p>What if we instrument our NewRelic agent so that it automatically parses the query's fields as transaction name? </p>\\r\\n<h3 id=\"tracking-graphql-performance-by-query-the-interesting-way\">Tracking GraphQL Performance by Query: The Interesting Way</h3>\\r\\n<p>That's what we ended up: making a customized NewRelic plugin for graphql-ruby library.</p>\\r\\n\\r\\n<script src=\"https://gist.github.com/jenny-codes/31a8d48df545489621bfdf5af1a02778.js\"></script>\\r\\n\\r\\n<p>Basically, our custom plugin inherits from the original built-in <code>GraphQL::Tracing::NewRelicTracing</code> class and overwrites its <code>platform_trace</code> method. In the method two things happen:</p>\\r\\n\\r\\n<ol>\\r\\n<li>The transaction name is set to the query's first-layer fields.</li>\\r\\n<li>The full query string is recorded as a custom attribute (that will be shown inside a report), which is a workaround to the annoying 255-byte limit of the query column provided by default in the request section.</li>\\r\\n</ol>\\r\\n\\r\\n<p>And the result looks like this: </p>\\r\\n\\r\\n<p><img alt=\"GraphQL transactions separated by query fields\" class=\"lazy img-fluid\" data-src=\"https://user-images.githubusercontent.com/43872616/75084931-d9f1a300-555e-11ea-8fba-71575eac15ce.jpg\"></p>\\r\\n\\r\\n<p>Inside a transaction trace:\\r\\n<img alt=\"full GraphQL query string as a custom attribute\" class=\"lazy img-fluid\" data-src=\"https://user-images.githubusercontent.com/43872616/75085035-f5a97900-555f-11ea-8338-03fbebcf1f2d.jpg\"></p>\\r\\n<h3 id=\"final-note\">Final Note</h3>\\r\\n<p>GraphQL queries, by nature, are dynamically formed, and it's up to you to decide how to group them into useful units. The method provided below is only one possiblity, which suits our business logic. Feel free to tweak them furthur (and <a href=\"https://jennycodes.me/contact\">let me know</a> if you do!).</p>\\r\\n\\r\\n<p>Voila, a day's work done. Now we have our analysis tool polished, it's time to DO the analysis and optimize things! Stay tuned!</p>",
        "status": 1,
        "description": "two ways to separate GraphQL routes by query",
        "created_at": "2020-02-22T07:45:54.707842",
        "updated_at": "2020-02-22T07:47:42.861545",
        "slug": "performance-speedup-customizing-graphql-tracing-on-newrelic",
        "medium_url": ""
    },
    {
        "id": 86,
        "title": "A Field Guide to Unit Testing: Maintainability",
        "body": "<hr>\\r\\n\\r\\n<p><strong>THE UNIT TESTING SERIES</strong></p>\\r\\n\\r\\n<blockquote>\\r\\n<ol>\\r\\n<li><a href=\"https://jennycodes.me/posts/unit-testing-overview\">A Field Guide to Unit Testing: Overview</a></li>\\r\\n<li>\\r\\n<a href=\"https://jennycodes.me/posts/unit-testing-trustworthiness\">A good test is trustworthy</a>\\r\\n\\r\\n<ul>\\r\\n<li>Test isolation (and what is dependency)</li>\\r\\n<li>Definition of a unit</li>\\r\\n<li>Testing scenarios</li>\\r\\n</ul>\\r\\n</li>\\r\\n<li>\\r\\n<a href=\"https://jennycodes.me/posts/unit-testing-maintainability\">A good test is maintainable</a>\\r\\n\\r\\n<ul>\\r\\n<li>Testing one thing at a time</li>\\r\\n<li>Use setup method, but use it wisely</li>\\r\\n</ul>\\r\\n</li>\\r\\n<li>\\r\\n<a href=\"https://jennycodes.me/posts/unit-testing-readability\">A good test is readable</a>\\r\\n<ul>\\r\\n<li>Test description</li>\\r\\n<li>Test pattern</li>\\r\\n</ul>\\r\\n</li>\\r\\n</ol>\\r\\n</blockquote>\\r\\n\\r\\n<hr>\\r\\n<p>Welcome to the part 3 of our unit testing series! Previously, we got ourselves comfortable with the idea of unit tests (the basic concepts, its reason of existence...etc), and introduced three pillars of a good unit test: <strong>trustworthiness</strong>, <strong>maintainability</strong> and <strong>readability</strong>. In the last article, we dived into how a good test can/should be trustworthy. Now, let's talk about how a test can be excitingly maintainable. </p>\\r\\n<h3 id=\"test-only-one-thing-at-a-time\">Test only one thing at a time</h3>\\r\\n<p>is an important mindset when we think about test maintainability.</p>\\r\\n\\r\\n<p>Often, we expect multiple outcomes for the unit that we are testing. It may be several attribute changes to one operation, or different states according to different inputs, so it feels natural enough if we have several assertions in one test case. </p>\\r\\n\\r\\n<p>Let's see an example first.</p>\\r\\n\\r\\n<p>In <a href=\"https://jennycodes.me/posts/unit-testing-overview#a-restaurant\">the restaurant that only serves French toast</a>, <code>Server</code> has this <code>take_order</code> function:</p>\\r\\n\\r\\n<pre><code class=\"lang-ruby\"># Inside class Restaurant::Server\\r\\n\\r\\ndef take_order(dish)\\r\\n  if dish == 'French toast'\\r\\n    Cook.new.make_french_toast\\r\\n  else\\r\\n    \"We only make French toast. Take it or leave it.\"\\r\\n  end\\r\\nend\\r\\n</code></pre>\\r\\n\\r\\n<p>When the dish name is \"French toast,\" server passes the order to a <code>Cook</code> instance. If it isn't, server simply replies with a reject message.</p>\\r\\n\\r\\n<p>Now, we can write a test like this</p>\\r\\n\\r\\n<pre><code class=\"lang-ruby\">RSpec.describe Restaurant::Server do\\r\\n  describe '#take_order' do\\r\\n    it 'works' do\\r\\n      server = Restaurant::Server.new\\r\\n      # ----- First scenario begins-----\\r\\n      # First assertion\\r\\n      expect_any_instance_of(Restaurant::Cook).to receive(:make_french_toast)\\r\\n\\r\\n      server.take_order('French toast')\\r\\n\\r\\n      # ----- Second scenario begins-----\\r\\n      result = server.take_order('Not French toast')\\r\\n\\r\\n      # Second assertion\\r\\n      expect(result).to be_kind_of String\\r\\n\\r\\n      # Third assertion\\r\\n      expect_any_instance_of(Restaurant::Server).not_to receive(:serve)\\r\\n\\r\\n      server.take_order('Not French toast')\\r\\n    end\\r\\n  end\\r\\nend\\r\\n</code></pre>\\r\\n\\r\\n<p>It is a perfectly valid test: it covers both scenarios, and it tests every expected behavior. But we can make it better. The problems with it are several:</p>\\r\\n\\r\\n<ol>\\r\\n<li>\\r\\n<strong>Ambiguous failures</strong>: If this test fails, it might fail at any of the three assertions. How would we know which one is it? And, if it fails in the middle, the code would be stopped. How do we know if the items after that failure will succeed?</li>\\r\\n<li>\\r\\n<strong>Complicated state management</strong>: Codes get complicated once you want to test multiple things at once. And managing objects' states is–trust me, you really don't want to get into it.</li>\\r\\n<li>\\r\\n<strong>Decreased readability</strong>: expected outcome cannot be immediately clear. We need to look through the code to know what the expected behavior is. The test description \"it works\" doesn't help us much here. \"Write a clearer description then,\" you'd say. But it is naturally hard if we need to encapsulate all the expected outcomes in one sentence.</li>\\r\\n</ol>\\r\\n\\r\\n<p>Let's see an improved version:</p>\\r\\n\\r\\n<pre><code class=\"lang-ruby\">RSpec.describe Restaurant::Server do\\r\\n  describe '#take_order' do\\r\\n    it 'when dish is French toast passes the order to Cook' do\\r\\n      server = Restaurant::Server.new\\r\\n\\r\\n      expect_any_instance_of(Restaurant::Cook).to receive(:make_french_toast)\\r\\n\\r\\n      server.take_order('French toast')\\r\\n    end\\r\\n\\r\\n    it 'when dish is others returns an error message' do\\r\\n      server = Restaurant::Server.new\\r\\n\\r\\n      result = server.take_order('Not French toast')\\r\\n\\r\\n      expect(result).to be_kind_of String\\r\\n    end\\r\\n\\r\\n    it 'when dish is others does not pass order to Cook' do\\r\\n      server = Restaurant::Server.new\\r\\n\\r\\n      expect_any_instance_of(Restaurant::Server).not_to receive(:serve)\\r\\n\\r\\n      server.take_order('Not French toast')\\r\\n    end\\r\\n  end\\r\\nend\\r\\n</code></pre>\\r\\n\\r\\n<p>Do you see? When we split the scenarios into three tests, magic happens:</p>\\r\\n\\r\\n<ol>\\r\\n<li>The test description is clear and to the point, so instead of grilling the test code, we can get a good grip of what this SUT does at a glance. It can almost server as a documentation, and life is so much more easier.</li>\\r\\n<li>We'd know exactly which part is not functioning if any of the tests fail because each test only have one assertion against a specific behavior. It makes debugging way more efficient.</li>\\r\\n</ol>\\r\\n<h3 id=\"use-setup-method-but-use-it-wisely\">Use setup method, but use it wisely</h3>\\r\\n<p>The second important thing I want to point out in this article is the <strong>setup</strong> method. It is a powerful tool. If you're working with an existing test suite, you may have already seen it. The idea is simple: Everything you put in the setup will be executed at the beginning of each test.</p>\\r\\n\\r\\n<p>We'll just take the tests above for example. Let's see how we can apply a setup method to them.</p>\\r\\n\\r\\n<p>Now, scroll up, look at the tests code again, and come back. See the</p>\\r\\n\\r\\n<pre><code class=\"lang-ruby\">server = Restaurant::Server.new\\r\\n</code></pre>\\r\\n\\r\\n<p>at the first line of all three tests? Let's dry it up:</p>\\r\\n\\r\\n<pre><code class=\"lang-ruby\">RSpec.describe Restaurant::Server do\\r\\n  # ----- Attention here -----\\r\\n  before :each do\\r\\n    @server = Restaurant::Server.new\\r\\n  end\\r\\n  # --------------------------\\r\\n\\r\\n  describe '#take_order' do\\r\\n    it 'with French toast passes the order to Cook' do\\r\\n      expect_any_instance_of(Restaurant::Cook).to receive(:make_french_toast)\\r\\n\\r\\n      @server.take_order('French toast')\\r\\n    end\\r\\n\\r\\n    it 'with other orders returns an error message' do\\r\\n      result = @server.take_order('Not French toast')\\r\\n\\r\\n      expect(result).to be_kind_of String\\r\\n    end\\r\\n\\r\\n    it 'with other orders does not pass order to Cook' do\\r\\n      expect_any_instance_of(Restaurant::Server).not_to receive(:serve)\\r\\n\\r\\n      @server.take_order('Not French toast')\\r\\n    end\\r\\n  end\\r\\nend\\r\\n</code></pre>\\r\\n\\r\\n<p>What changed is that instead of initializing the local variable <code>server</code> at the beginning of each test, we do the assignment to the <code>@server</code> instance variable at the <code>before :each</code> block. And it is readily usable inside each test.</p>\\r\\n\\r\\n<p>It doesn't seem like a big change, but when we move the same line of code into the <code>before :each</code> setup helper, we get the following benefits:</p>\\r\\n\\r\\n<ul>\\r\\n<li>If we are going to change the initialization of our <code>Restaurant::Server</code>, we will now only have to rewrite in one place (in the <code>before :each</code> block), instead of three. </li>\\r\\n<li>By removing the boilerplate part, we can focus on what we really want to test.</li>\\r\\n</ul>\\r\\n\\r\\n<p>Almost every testing framework supports this functionality, including RSpec. Apart from <code>before :each</code> method, RSpec provides three other helper methods at our disposal:</p>\\r\\n\\r\\n<ul>\\r\\n<li>\\r\\n<code>before :all</code> is executed once at the beginning of all tests.</li>\\r\\n<li>\\r\\n<code>after :each</code> is executed at the end of every test in the scope.</li>\\r\\n<li>\\r\\n<code>after :all</code> is executed once when all the tests are finished.</li>\\r\\n</ul>\\r\\n<h4 id=\"the-double-edged-sword\">The double-edged sword</h4>\\r\\n<p>Yet, precisely because it is such a convenient instrument, setup methods can be easily abused.  We may be tempted to swing too many stuff into our setup methods, so much that we will eventually find ourselves looking at a mess inside them as they have become a maintenance nightmare.</p>\\r\\n<h4 id=\"a-real-world-example-shall-we\">A real-world example, shall we?</h4>\\r\\n<p>Our restaurant example is really simple, so there isn't much room to mess around in the setup method. Let's walk out of that quaint little restaurant and into the real world for a while. </p>\\r\\n\\r\\n<p>At PicCollage, we have a good tradition of writing tests. At the time of writing, we have 4000-ish test cases in total that guards our server that serves millions of requests every day. They cover all the important logics in our codebase, and quite trust-worthy already. Yet, we do have some issues with our test suite, and one of them is, guess what, the setup method.</p>\\r\\n\\r\\n<p>We have this global setup method that runs at the beginning of every of those 4000 tests, and here is a snippet of it:</p>\\r\\n\\r\\n<pre><code class=\"lang-ruby\">def setup    \\r\\n  Rails.cache.clear\\r\\n\\r\\n  Redis.current.flushdb\\r\\n  Redis.current_2.flushdb\\r\\n\\r\\n  Sidekiq::Worker.clear_all\\r\\n  PC::Helpers::ElasticsearchHelpers.elasticsearch_clear!\\r\\n\\r\\n  OmniAuth.config.test_mode = true\\r\\n\\r\\n  Draper::ViewContext.clear!\\r\\n\\r\\n  setup_aws_stubs\\r\\n  setup_logger_stubs\\r\\n  setup_schema_patches\\r\\n\\r\\n  # And it goes on...\\r\\nend\\r\\n</code></pre>\\r\\n\\r\\n<p>Each line corresponds to an external component that our production code interacts with. Why is it bad? Because</p>\\r\\n\\r\\n<ol>\\r\\n<li>Some of the code only applies to a subset of the tests, yet we need to run them regardless, creating extra burden on the server.</li>\\r\\n<li>This makes it much slower to run the tests.</li>\\r\\n<li>When error happens, it's not readily visible where the error may be, because it's far away from where the actual tests are.</li>\\r\\n</ol>\\r\\n<h4 id=\"so-what-should-be-in-the-setup-method\">So what should be in the setup method?</h4>\\r\\n<p>To avoid misusing the setup methods, we can ask ourselves the following questions:</p>\\r\\n\\r\\n<ul>\\r\\n<li><p><strong>Does every test need this setup?</strong> If only a certain subset of tests need this setup, then they probably shouldn't be in the setup method. Also, if this setup is related to an external component, maybe you shouldn't need it at the first place if you are writing unit tests. Instead, you should have stubbed it to make your unit tests isolated.</p></li>\\r\\n<li><p><strong>Is it related to a certain logic that you want to test?</strong> If yes, then it shouldn't be in the setup method, because if we remove it from the test block, we may have to go back and forth between setup method and the code block to understand/remember what this test does. I'll let you in on a little secret: it's really easy to forget that each test has a setup method ahead of it.</p></li>\\r\\n</ul>\\r\\n<h3 id=\"we-39-re-not-done-yet\">We're not done yet</h3>\\r\\n<p>That's it! So in this article we talked about how a unit test can be <strong>maintainable</strong>. We looked at one important mindset and one powerful testing tool. Next article in this unit testing series will be on <strong>readability</strong>. Bye for now!</p>\\r\\n",
        "status": 1,
        "description": "Having maintainable tests is very important, just like 204 is very important.",
        "created_at": "2020-10-21T12:40:19.370149",
        "updated_at": "2020-11-14T10:13:34.219184",
        "slug": "unit-testing-maintainability",
        "medium_url": ""
    },
    {
        "id": 85,
        "title": "A Field Guide to Unit Testing: Trustworthiness",
        "body": "<hr>\\r\\n\\r\\n<p><strong>THE UNIT TESTING SERIES</strong></p>\\r\\n\\r\\n<blockquote>\\r\\n<ol>\\r\\n<li><a href=\"https://jennycodes.me/posts/unit-testing-overview\">A Field Guide to Unit Testing: Overview</a></li>\\r\\n<li>\\r\\n<a href=\"https://jennycodes.me/posts/unit-testing-trustworthiness\">A good test is trustworthy</a>\\r\\n\\r\\n<ul>\\r\\n<li>Test isolation (and what is dependency)</li>\\r\\n<li>Definition of a unit</li>\\r\\n<li>Testing scenarios</li>\\r\\n</ul>\\r\\n</li>\\r\\n<li>\\r\\n<a href=\"https://jennycodes.me/posts/unit-testing-maintainability\">A good test is maintainable</a>\\r\\n\\r\\n<ul>\\r\\n<li>Testing one thing at a time</li>\\r\\n<li>Use setup method, but use it wisely</li>\\r\\n</ul>\\r\\n</li>\\r\\n<li>\\r\\n<a href=\"https://jennycodes.me/posts/unit-testing-readability\">A good test is readable</a>\\r\\n<ul>\\r\\n<li>Test description</li>\\r\\n<li>Test pattern</li>\\r\\n</ul>\\r\\n</li>\\r\\n</ol>\\r\\n</blockquote>\\r\\n\\r\\n<hr><p>In <a href=\"https://jennycodes.me/posts/unit-testing-overview\">A Field Guide to Unit Testing: Overview</a>, we defined what a SUT (subject under test) is, looked at three different testing methodologies on the spectrum of scope (the universe of testing) and functionality (the testing pyramid). We also defined three pillars of a good test: trustworthiness, maintainability, and readability. Below is a brief overview of the topics for each of those pillars: </p>\\r\\n\\r\\n<ul>\\r\\n<li>\\r\\nA good test is trustworthy\\r\\n\\r\\n<ul>\\r\\n<li>Test isolation (and what is dependency)</li>\\r\\n<li>Definition of a unit</li>\\r\\n<li>Testing scenarios</li>\\r\\n</ul>\\r\\n</li>\\r\\n<li>\\r\\nA good test is maintainable\\r\\n\\r\\n<ul>\\r\\n<li>Testing one thing at a time</li>\\r\\n<li>Encapsulation</li>\\r\\n<li>The tricky setup method</li>\\r\\n</ul>\\r\\n</li>\\r\\n<li>\\r\\nA good test is readable\\r\\n\\r\\n<ul>\\r\\n<li>Structure</li>\\r\\n<li>Naming</li>\\r\\n</ul>\\r\\n</li>\\r\\n</ul>\\r\\n\\r\\n<p>This article covers the first part: <strong>A good test is trustworthy</strong>. A warmup question: How do we define a trustworthy test? Have an answer before you read on.</p>\\r\\n<h3 id=\"two-criteria-of-a-trustworthy-test\">Two criteria of a trustworthy test</h3>\\r\\n<p>We define a trustworthy test to have the two attributes:</p>\\r\\n\\r\\n<ol>\\r\\n<li><strong>We can be confident that it's the SUT that doesn't work when a test fails.</strong></li>\\r\\n<li><strong>We can be confident that the SUT works when the tests pass.</strong></li>\\r\\n</ol>\\r\\n\\r\\n<p>(refresher: SUT stands for Subject Under Test)</p>\\r\\n\\r\\n<p>Hold on to that thought, we will come back to it.</p>\\r\\n<h3 id=\"the-restaurant-that-serves-french-toast\">The restaurant that serves French toast</h3>\\r\\n<p>The simple restaurant that we conjured up last time has three entities: <code>Cook</code>, <code>Server</code> and <code>StorageRoom</code>. This restaurant serves one thing: French toast. Below is the implementation of <code>Cook</code> and <code>StorageRoom</code>. <code>Cook</code> has a <code>make_french_toast</code> method, which does three things: </p>\\r\\n\\r\\n<ol>\\r\\n<li>Get <code>egg</code> and <code>bread</code> from <code>StorageRoom</code>.</li>\\r\\n<li>Make French toast with the ingredients.</li>\\r\\n<li>Return the plate of French toast as a string.</li>\\r\\n</ol>\\r\\n\\r\\n<pre><code class=\"lang-ruby\"># Implementation of Restaurant::Cook\\r\\n\\r\\nmodule Restaurant   \\r\\n    class Cook\\r\\n    def make_french_toast\\r\\n      # [Step 1] Get eggs and bread from StorageRoom\\r\\n      egg = StorageRoom.get('egg')\\r\\n      bread = StorageRoom.get('bread')\\r\\n\\r\\n      # Some error cases handling\\r\\n      return 'Oops running out of eggs!' unless egg\\r\\n      return 'Oops running out of bread!' unless bread\\r\\n\\r\\n      # [Step 2] Making French toast with the eggs and bread\\r\\n      puts 'Making French toast'\\r\\n\\r\\n      # [Step 3] Return the plate of French toast as a string\\r\\n      'French toast is here. Ugh.'\\r\\n    end\\r\\n  end\\r\\nend\\r\\n</code></pre>\\r\\n\\r\\n<p><code>StorageRoom</code> has <code>get</code> and <code>put</code> class methods. They interact with a database.</p>\\r\\n\\r\\n<pre><code class=\"lang-ruby\"># Implementation of Restaurant::StorageRoom\\r\\n\\r\\nmodule Restaurant\\r\\n  class StorageRoom\\r\\n    def self.get(ingredient)\\r\\n      # We don't really care about the implementation.\\r\\n      # Just know that it's supposed to return the ingredient if the database has it.\\r\\n    end\\r\\n\\r\\n    def self.put(ingredient)\\r\\n      # We don't really care about the implementation.\\r\\n      # Just know that it's supposed to insert the ingredient into the database.\\r\\n    end\\r\\n  end\\r\\nend\\r\\n</code></pre>\\r\\n\\r\\n<p>(note: the full Restaurant code and its tests can be found <a href=\"https://gist.github.com/jenny-codes/18453bd3febf647a5afa4fe9d1e2cf59\">here</a>.</p>\\r\\n<h3 id=\"the-accidentally-integrated-unit-test\">The accidentally integrated unit test</h3>\\r\\n<p>This is the testing pyramid we looked at previously:</p>\\r\\n\\r\\n<p><img src=\"https://user-images.githubusercontent.com/43872616/87244391-7dd8de00-c46f-11ea-8866-e6e125776cfa.png\" alt=\"testing-pyramid\" style=\"zoom:33%;\"></p>\\r\\n\\r\\n<p>It is a perfectly valid pyramid–except it's not usually the case in reality. What we often see in the wild is the pyramid below:</p>\\r\\n\\r\\n<p><img src=\"https://user-images.githubusercontent.com/43872616/87262423-7ad00300-c4ec-11ea-8cb7-29f83c0e7653.png\" alt=\"testing-pyramid-in-reality\" style=\"zoom:50%;\"></p>\\r\\n\\r\\n<p>At the bottom, there are <strong>integration tests disguised as unit tests</strong>. Why? </p>\\r\\n<h4 id=\"dependency-and-why-it-is-bad-for-unit-tests\">Dependency, and why it is bad for unit tests</h4>\\r\\n<p>The first attribute of a trustworthy test is</p>\\r\\n\\r\\n<blockquote>\\r\\n<p>We can be confident that it's the SUT that doesn't work when a test fails.</p>\\r\\n</blockquote>\\r\\n\\r\\n<p>It seems almost redundant. How would it be otherwise? It turns out, there are a lot of ways for a test to fail besides the SUT itself. One (and a huge part) of them is a malfunctioning dependency.</p>\\r\\n\\r\\n<blockquote>\\r\\n<p>A dependency is something that a SUT calls that is out of its control. </p>\\r\\n</blockquote>\\r\\n\\r\\n<p>Some commonly used dependencies include time, random number generator, database, or simply just a message sent to another class. For example, we'll say that <code>Cook</code>'s <code>make_french_toast</code> depends on <code>StorageRoom</code> because it cannot control the result when it tries to get eggs and bread from <code>StorageRoom</code>. <code>StorageRoom</code> may return the eggs and bread, nothing at all, or a pair of unmatched socks for all it matters. </p>\\r\\n\\r\\n<p>Imagine when we write a test for <code>make_french_toast</code> test that actually calls a real <code>StorageRoom</code>. If it fails, the culprit may as well be that <code>StorageRoom</code> is returning weird stuff, instead of the <code>make_french_toast</code> method itself. </p>\\r\\n\\r\\n<p>A real unit test requires careful attention to be fully isolated from all the dependencies. If not, it becomes an integration test.</p>\\r\\n<h3 id=\"but-why-does-it-matter-if-we-write-integration-instead-of-unit-tests\">But why does it matter if we write integration instead of unit tests?</h3>\\r\\n<p>Getting rid of dependencies is hard. Isolation is hard. So why don't we just write integration tests and be done with it?</p>\\r\\n\\r\\n<p>Integration tests have their own benefits, but there are some advantages that only unit tests possess:</p>\\r\\n\\r\\n<ul>\\r\\n<li>\\r\\n<strong>Production code changes.</strong> All the time. If somehow we need to change the signature of a method that many other classes depend on, it'd a chaos to update the all the code occurrences in tests. With unit tests, we only have to change one place, with is the method itself, and the work is done.</li>\\r\\n<li>\\r\\n<strong>Debugging is easier.</strong> When a test fails, it's easier to see what went wrong. We don't need to trace through 10 layers of dependencies to see which part fails to work.</li>\\r\\n<li>\\r\\n<strong>They are fast.</strong> They rid of all the calls to external dependencies (most notably the database), so running them can be lightening fast. This is very important, because if it takes 20 minutes every time to run through the tests, let's face it, we won't run the tests as often (as we should), which will defeat the purpose of having tests in the first place.</li>\\r\\n</ul>\\r\\n\\r\\n<p>Time to go back to our restaurant. Shall we?</p>\\r\\n<h4 id=\"the-cook-39-s-unit-tests\">The Cook's unit tests</h4>\\r\\n<p>Below are two tests for <code>Restaurant::Cook</code>'s <code>make_french_toast</code> method that we just implemented. They're almost identical, but only one is a unit test.</p>\\r\\n\\r\\n<pre><code class=\"lang-ruby\"># Test cases for `Restaurant::Cook`'s `make_french_toast` method, using RSpec.\\r\\n\\r\\nRSpec.describe Restaurant::Cook do\\r\\n  describe '#make_french_toast' do\\r\\n    # First test\\r\\n    it 'with everything prepared returns French toast as string' do\\r\\n            # Prepare ingredients\\r\\n      Restaurant::StorageRoom.put(:egg)\\r\\n      Restaurant::StorageRoom.put(:bread)\\r\\n\\r\\n      result = Restaurant::Cook.new.make_french_toast\\r\\n\\r\\n      expect(result).to eq 'French toast is here. Ugh.'\\r\\n    end\\r\\n\\r\\n    # Second test\\r\\n    it 'with everything prepared returns French toast as string' do\\r\\n      # Prepare ingredients\\r\\n      Restaurant::StorageRoom.stub(:get).with('egg') { 'egg' }\\r\\n      Restaurant::StorageRoom.stub(:get).with('bread') { 'bread' }\\r\\n\\r\\n      result = Restaurant::Cook.new.make_french_toast\\r\\n\\r\\n      expect(result).to eq 'French toast is here. Ugh.'\\r\\n    end\\r\\n  end\\r\\nend\\r\\n</code></pre>\\r\\n\\r\\n<p>Can you see the difference? Look at the first two lines of each test, where we prepare the ingredients. The first test calls <code>Restaurant::StorageRoom.put(ingredient)</code> to put ingredients into the database, so that when <code>Cook#make_french_toast</code> later calls <code>Restaurant::StorageRoom.get(ingredient)</code>, those ingredients can be returned.</p>\\r\\n\\r\\n<p>The second test takes a different approach. It <a href=\"https://en.wikipedia.org/wiki/Test_stub\">stubs</a> the <code>StorageRoom#get</code> method to return arbitrary values for the storage room items (<code>egg</code> and <code>bread</code>). If you don't already know what a stub is, it is a testing technique that enables us to return a fixed response for a certain method call. In our example, </p>\\r\\n\\r\\n<pre><code class=\"lang-ruby\">Restaurant::StorageRoom.stub(:get).with('egg') { 'egg' } \\r\\n</code></pre>\\r\\n\\r\\n<p>means that the call of <code>Restaurant::StorageRoom.get(:egg)</code> is intercepted. This message will not be sent to the actual <code>Restaurant::StorageRoom</code>. Instead, we pretend that it's sent, and that a value <code>'egg'</code> is returned. In other words, we have <em>isolated</em> this test from its dependency for <code>Restaurant::StorageRoom</code>.</p>\\r\\n\\r\\n<p>The second test, therefore, is a unit test, because it is isolated from its dependencies. The first test is an integration test, because to make it pass, we need to guarantee that <code>StorageRoom</code> works as well.</p>\\r\\n\\r\\n<p>If it's still not clear, run the two tests now. The first test will fail, because we didn't (and will not) implement the <code>StorageRoom</code> functions, yet the first test depends on those functions. The second test will pass, because we use stubs to rid the SUT of its dependencies. </p>\\r\\n<h3 id=\"a-brief-recap\">A brief recap</h3>\\r\\n<p>Wow, that was a bit long. </p>\\r\\n\\r\\n<p>Now we know that having full isolation in tests allows us to achieve one of the two criteria of a trustworthy unit test: when a test fails, we can be confident that it's precisely the SUT, not anything else, that doesn't work.</p>\\r\\n\\r\\n<p>That concludes the first part in our journey to a trustworthy test. Next, let's explore the second criteria: </p>\\r\\n\\r\\n<blockquote>\\r\\n<p>We can be confident that the SUT works when the tests pass.</p>\\r\\n</blockquote>\\r\\n<h3 id=\"restaurant-now-serves\">Restaurant now serves</h3>\\r\\n<p>Of the three entities in our <code>Restaurant</code>, we've implemented <code>Cook</code> and <code>StorageRoom</code>. There's only one left: <code>Server</code>.</p>\\r\\n\\r\\n<p><code>Server</code> has two functions. <code>take_order</code> receives a dish name and passes it to <code>Cook</code> if the dish name is \"French toast,\" or else it returns an error message \"We only make French toast. Take it or leave it.\" <code>serve</code> takes a dish (that <code>Cook</code> has made), decorates it, and serves it with gusto.</p>\\r\\n\\r\\n<pre><code class=\"lang-ruby\">module Restaurant\\r\\n  class Server\\r\\n    def take_order(dish)\\r\\n      if dish == 'French toast'\\r\\n        Cook.new.make_french_toast\\r\\n      else\\r\\n        \"We only make French toast. Take it or leave it.\"\\r\\n      end\\r\\n    end\\r\\n\\r\\n    # This method is called when Cook is done cooking the dish.\\r\\n    def serve(dish)\\r\\n      decorated_dish = decorate(dish)\\r\\n\\r\\n      \"#{decorated_dish} yo!\"\\r\\n    end\\r\\n\\r\\n    private\\r\\n\\r\\n    def decorate(dish_with_murmur)\\r\\n      dish_name = dish_with_murmur.gsub(' is here. Ugh.', '')\\r\\n      \"Delicious #{dish_name}\"\\r\\n    end\\r\\n  end\\r\\nend\\r\\n</code></pre>\\r\\n\\r\\n<p>(note: the full Restaurant code and its tests can be found <a href=\"https://gist.github.com/jenny-codes/18453bd3febf647a5afa4fe9d1e2cf59\">here</a>.</p>\\r\\n\\r\\n<p>Now, <strong>how many unit test should we write for <code>Server</code>?</strong> Take your time to think about it, reason with it, keep your answer in mind, and read on.</p>\\r\\n<h3 id=\"what-is-a-unit\">What is a unit???</h3>\\r\\n<p>To write a unit test, it is very important to know what a <em>unit</em> is. Or what it can be. We might already have some pre-conceived ideas. For example,</p>\\r\\n\\r\\n<blockquote>\\r\\n<p>A unit is a function.</p>\\r\\n</blockquote>\\r\\n\\r\\n<p>should come almost instantly to everyone's mind. Nod your head if your answer is <em>3</em>–one for each method in <code>Restaurant::Server</code> (<code>take_order</code>, <code>serve</code>, <code>decorate</code>). It's a valid answer, but not ideal. The concept of a unit should not be defined by any physical code boundaries, convenient as they may be, but <em>interfaces</em>, that is, we can think of a unit as something that takes an input and produces an output.</p>\\r\\n\\r\\n<blockquote>\\r\\n<p>A unit is a piece of code that takes certain inputs, and returns an observable output to the end user.</p>\\r\\n</blockquote>\\r\\n\\r\\n<p>Often that \"piece of code\" is a function, but there are times when it spans several functions or even several classes. Our tendency might be to minimize the size of a unit of work being tested, but if making our SUT bigger will produce a more noticeable end result, the tests will be more maintainable.</p>\\r\\n\\r\\n<p>Let's look at a curious question first.</p>\\r\\n<h4 id=\"should-we-unit-test-private-methods\">Should we unit test private methods?</h4>\\r\\n<p>Should we have a unit test for the private <code>decorate</code> method in <code>Server</code> class?</p>\\r\\n\\r\\n<p>First of all, let's look at the unit definition again. \"[O]bservable result to the end user\". A private method is a private method precisely because it does not have an observable result to the end user, so we have very good reasons that testing private methods is not necessary.</p>\\r\\n\\r\\n<p>Secondly, from a \"test as documentation\" point of view, we shouldn't test private methods either. Tests provide documentation about the SUT. They tell a story about how this SUT interact with the world. If we include private methods, we will distract, and possibly confuse, people from the main purpose of this SUT.</p>\\r\\n\\r\\n<p>Thirdly, private methods are implementation details. </p>\\r\\n\\r\\n<blockquote>\\r\\n<p>We shouldn't test \"how\" the SUT works, but that it works.</p>\\r\\n</blockquote>\\r\\n\\r\\n<p>Private methods are of no concerns in the eyes of the public. So in our <code>Restaurant::Server</code> class, instead of testing <code>decorate</code> directly, we will treat it as part of the implementation for <code>serve</code>. So, if there really is a bug in this private method, we will catch it in our test for the public method that calls it. </p>\\r\\n<h3 id=\"testing-scenarios\">Testing scenarios</h3>\\r\\n<p>The answer is <em>2</em>, then? Because there are two public methods in <code>Restaurant::Server</code> class?</p>\\r\\n\\r\\n<p>It's not 2. Look at the <code>take_order</code> again. Does it always follow the same logic with any input?</p>\\r\\n\\r\\n<p>In <code>#take_order</code>, we have a conditional statement: if the input argument (<code>dish</code>) is \"French toast,\" the server will pass this order to <code>Restaurant::Cook</code>; if not, the server will simply return a string \"We only make French toast. Take it or leave it.\"</p>\\r\\n\\r\\n<p>This method has two logic flows to handle the input, based on the content of it. We can say there are <em>two scenarios</em> for this SUT, and we should write a unit test for each scenario. Why? Because unit tests should cover all situations. If we only test this SUT with the input \"French toast,\" the following sequence of things will happen:</p>\\r\\n\\r\\n<ol>\\r\\n<li>We do not have expectations against the code where the input is not \"French toast.\"</li>\\r\\n<li>We are not sure what happens if the input is not French toast. </li>\\r\\n<li>We <em>cannot</em> be confident that the SUT works when the tests pass. 😱</li>\\r\\n</ol>\\r\\n\\r\\n<p>Hmm. Doesn't look fun is it?</p>\\r\\n\\r\\n<p>So we will write the following three unit test cases for <code>Restaurant::Server#take_order</code>:</p>\\r\\n\\r\\n<ol>\\r\\n<li><p>It passes the order to Cook if order is French toast.</p></li>\\r\\n<li><p>It returns an error message if order is not French toast.</p></li>\\r\\n<li><p>It does not pass the order to cook if order is not French toast.</p></li>\\r\\n</ol>\\r\\n\\r\\n<p>You may have questions: Why do we need the third test case? Its scenario is exactly the same as the second one. If we do need it, why can't we just add an assertion in the second test case?</p>\\r\\n\\r\\n<p>Those questions will be answered in more depth when we get to the <strong>maintainable</strong> and <strong>readable</strong> pillars of unit tests in the following articles. Here's a concise version: the goal of the third case is both to make our intention clearer and to test its behavior, and the reason that we don't put it into the second test case is to follow the principle that we should test only one thing at a time.</p>\\r\\n\\r\\n<p>Yet, in the end, you must be the arbiter of the tests you write. It is up to you to choose.</p>\\r\\n\\r\\n<p>Alas, the actual test code (for <code>Restaurant::Server#take_order</code>):</p>\\r\\n\\r\\n<pre><code class=\"lang-ruby\">RSpec.describe Restaurant::Server do\\r\\n  describe '#take_order' do\\r\\n    # 1.\\r\\n    it 'with French toast passes the order to Cook' do\\r\\n      expect_any_instance_of(Restaurant::Cook).to receive(:make_french_toast)\\r\\n\\r\\n      Restaurant::Server.new.take_order('French toast')\\r\\n    end\\r\\n\\r\\n    # 2.\\r\\n    it 'with other orders returns an error message' do\\r\\n      result = Restaurant::Server.new.take_order('Not French toast')\\r\\n\\r\\n      expect(result).to be_kind_of String\\r\\n    end\\r\\n\\r\\n    # 3.\\r\\n    it 'with other orders does not pass order to Cook' do\\r\\n      expect_any_instance_of(Restaurant::Server).not_to receive(:serve)\\r\\n\\r\\n      Restaurant::Server.new.take_order('Not French toast')\\r\\n    end\\r\\n  end\\r\\nend\\r\\n</code></pre>\\r\\n\\r\\n<p>What about <code>#serve</code> then?</p>\\r\\n\\r\\n<p>In our case, I'd write one test for <code>#serve</code>, because there is only one logic flow in it.</p>\\r\\n\\r\\n<ul>\\r\\n<li>It returns the decorated dish as a string.</li>\\r\\n</ul>\\r\\n\\r\\n<pre><code class=\"lang-ruby\">RSpec.describe Restaurant::Server do\\r\\n    describe '#serve' do\\r\\n    it 'returns decorated dish as a string' do\\r\\n      dish_from_cook = 'French toast is here. Ugh.'\\r\\n      result = Restaurant::Server.new.serve(dish_from_cook)\\r\\n\\r\\n      expect(result).to eq 'Delicious French toast yo!'\\r\\n    end\\r\\n  end\\r\\nend\\r\\n</code></pre>\\r\\n\\r\\n<p>And the tests pass.</p>\\r\\n\\r\\n<p><img src=\"https://user-images.githubusercontent.com/43872616/91653656-42ed4100-ead5-11ea-8b05-9ffecb5bd8de.png\" alt=\"restaurant-server-serve-test-passes\" style=\"zoom:50%;\"></p>\\r\\n<h3 id=\"there-39-s-more\">There's more</h3>\\r\\n<p>So that concludes the first pillar of a good test: being trustworthy. In this article, we broke the definition of trustworthiness down to two criteria (the SUT works when the tests pass, it doesn't work when the tests fail), and looked at three topics (test isolation, definition of a unit, testing scenarios) that help us understand achieve this goal.</p>\\r\\n\\r\\n<p>In the next article, we will look into the other two pillars for a good test: being maintainable and being readable. See you there!</p>\\r\\n",
        "status": 1,
        "description": "How to make your tests trustworthy?",
        "created_at": "2020-08-30T07:20:33.305885",
        "updated_at": "2020-11-14T10:13:59.760122",
        "slug": "unit-testing-trustworthiness",
        "medium_url": ""
    },
    {
        "id": 84,
        "title": "A Field Guide to Unit Testing: Overview",
        "body": "<hr>\\r\\n\\r\\n<p><strong>THE UNIT TESTING SERIES</strong></p>\\r\\n\\r\\n<blockquote>\\r\\n<ol>\\r\\n<li><a href=\"https://jennycodes.me/posts/unit-testing-overview\">A Field Guide to Unit Testing: Overview</a></li>\\r\\n<li>\\r\\n<a href=\"https://jennycodes.me/posts/unit-testing-trustworthiness\">A good test is trustworthy</a>\\r\\n\\r\\n<ul>\\r\\n<li>Test isolation (and what is dependency)</li>\\r\\n<li>Definition of a unit</li>\\r\\n<li>Testing scenarios</li>\\r\\n</ul>\\r\\n</li>\\r\\n<li>\\r\\n<a href=\"https://jennycodes.me/posts/unit-testing-maintainability\">A good test is maintainable</a>\\r\\n\\r\\n<ul>\\r\\n<li>Testing one thing at a time</li>\\r\\n<li>Use setup method, but use it wisely</li>\\r\\n</ul>\\r\\n</li>\\r\\n<li>\\r\\n<a href=\"https://jennycodes.me/posts/unit-testing-readability\">A good test is readable</a>\\r\\n<ul>\\r\\n<li>Test description</li>\\r\\n<li>Test pattern</li>\\r\\n</ul>\\r\\n</li>\\r\\n</ol>\\r\\n</blockquote>\\r\\n\\r\\n<hr>\\r\\n<p>As a server developer at PicCollage, what I'm most proud of among all the things I've developed is my relationship with testing.</p>\\r\\n\\r\\n<p>I didn't start my software career loving tests. When I first started writing them, it was a lot of trouble–I wasn't familiar with its methodology, and the benefits of writing tests weren't readily obvious. It took me some time to warm up the idea of testing. When I did, however, stop seeing it as a necessary evil, I started to see how powerful a tool/mindset it is. If nothing else, it improves code quality significantly.</p>\\r\\n\\r\\n<h3 id=\"table-of-content\">From Survival to Sophistication</h3>\\r\\n<p>Quite similar to the evolution of civilization, my mental journey went through three stages–<a href=\"https://www.goodreads.com/quotes/71510\">the How, Why and Where</a>: How to write tests? Why should we write tests? Where should we start refactoring our tests? (Yes there will be urges to refactor your tests once you've gone through the first two phases.)</p>\\r\\n\\r\\n<p>This series is an attempt to answer the first question: How to write a test? We'll set up a restaurant to be our example throughout the series. Specifically, a restaurant that makes French toast. With that, we'll go through the following topics in this article.</p>\\r\\n\\r\\n<ul>\\r\\n<li><strong>The universe of software testing</strong></li>\\r\\n<li><strong>The testing pyramid</strong></li>\\r\\n<li><strong>Pillars for a good unit test</strong></li>\\r\\n</ul>\\r\\n\\r\\n<blockquote>\\r\\n<p>Note: the example will be in <code>Ruby</code> and <code>RSpec</code> (a Ruby testing framework). It is totally fine if you're not familiar with them. Their friendly syntax should be pseudo-codey enough to understand. I'll also explain the parts where they're not instantly digestable.</p>\\r\\n</blockquote>\\r\\n<h3 id=\"a-restaurant\">A restaurant</h3>\\r\\n<p>In the beginning there was a restaurant. Everything in this restaurant is kept to a minimum. It serves only French toast, and has three entities: <code>Server</code>, <code>Cook</code>, and <code>StorageRoom</code>. </p>\\r\\n\\r\\n<pre><code class=\"lang-ruby\">module Restaurant\\r\\n  class Server\\r\\n    def take_order(order); end\\r\\n    def serve(dish); end\\r\\n  end\\r\\n\\r\\n  class Cook\\r\\n    def make_french_toast; end\\r\\n  end\\r\\n\\r\\n  class StorageRoom\\r\\n    def self.get(ingredient); end\\r\\n    def self.put(ingredient); end\\r\\n  end\\r\\nend\\r\\n</code></pre>\\r\\n\\r\\n<p><code>Server</code> has two functions: <code>take_order(dish)</code> receives and passes the order to <code>Cook</code>; <code>serve(dish)</code> takes the dish and serves it to a customer.</p>\\r\\n\\r\\n<p><code>Cook</code> has one function: <code>make_french_toast</code>, since it's all this restaurant offers. To make French toast, <code>Cook</code> will get the ingredients (eggs and bread) from <code>StorageRoom</code>.</p>\\r\\n\\r\\n<p><code>StorageRoom</code> has two static/class functions: <code>get(ingredient)</code> fetches <code>ingredient</code> from a persistant datastore; <code>put(ingredient)</code> is the other way around. It puts <code>ingredient</code> into the datastore.</p>\\r\\n\\r\\n<p>Below is an illustration of their relationships:</p>\\r\\n\\r\\n<p><img src=\"https://user-images.githubusercontent.com/43872616/87243033-f9815d80-c464-11ea-9d7c-7e3ffbe64793.png\" alt=\"french-toast-serving-process\" style=\"zoom:50%;\"></p>\\r\\n\\r\\n<p>Now, how do we write tests for this restaurant? </p>\\r\\n<h3 id=\"sut-subject-under-test\">SUT: Subject under Test</h3>\\r\\n<p>To make life easier for both you and me, let's introduce a term first: <strong>SUT</strong>. SUT stands for <strong>Subject Under Test</strong>. It is the piece of code that a test case is testing against. For example, if we want to write a test to make sure <code>Cook</code> can make French toast as expected, the <code>make_french_toast</code> function will be the SUT.</p>\\r\\n\\r\\n<p>This term will stay with us throughout the series.</p>\\r\\n<h3 id=\"the-universe-of-software-testing\">The universe of software testing</h3>\\r\\n<p>Before diving into the actual test code (don't worry, there will be), let's have a bird eye's view on software testing first.</p>\\r\\n\\r\\n<p>The universe of software testing can be roughly categorized the into three types: <strong>acceptance test</strong><em>, *</em>integration test<strong>, and **unit test</strong>. Below is a diagram of the <strong>scope</strong> of SUT that each type covers.</p>\\r\\n\\r\\n<p><img src=\"https://user-images.githubusercontent.com/43872616/87242251-81636980-c45d-11ea-9115-26846db55ed4.png\" alt=\"unit-testing-world\" style=\"zoom:33%;\"></p>\\r\\n\\r\\n<p>* Acceptance tests are sometimes referred to as end-to-end tests. Conceptually speaking they are ambiguously different, but in practice, they are often treated as the same.</p>\\r\\n<h4 id=\"unit-test\">Unit test</h4>\\r\\n<p>Unit test, our star in this series, is the smallest component in the testing universe. Each unit test covers a, well, unit of code. A very important trait about unit test is <strong>isolation</strong>. A unit test tests the SUT in isolation. That is, it tests the SUT under the assumption that every else works. </p>\\r\\n\\r\\n<p>Think about the restaurant. Suppose there was a sudden fire that burns everything of the restaurant down to ashes, the unit test for <code>Cook</code>'s <code>make_french_toast</code> should still pass because this test only cares that SUT works provided everything else does. It cares about nothing else.</p>\\r\\n\\r\\n<p>How do I know if it's safe to dine in this restaurant if we test everything in isolation? Well, if the restaurant is really burnt to ashes, or simply has a server that steals a bite from the plate every time they serve, it will fail in other unit tests that cover that specific functionality (e.g., the test case <code>'#serve presents the dish without modifications to the dish'</code> will certainly fail).</p>\\r\\n<h4 id=\"integration-test\">Integration test</h4>\\r\\n<p>Integration test, like unit test, asserts against a certain behavior of a piece of code; yet, unlike unit test, it does not test the SUT in isolation. An integration test expects the right behavior of the SUT using the SUT's real dependencies.</p>\\r\\n\\r\\n<p>So in a burnt-down restaurant, an integration test for <code>Cook</code>'s <code>make_french_toast</code> will fail, and quite quickly–at the cook's first attempt to step into the kitchen, let alone getting the ingredients from the <code>StorageRoom</code>.</p>\\r\\n<h4 id=\"acceptance-test\">Acceptance test</h4>\\r\\n<p>Acceptance test, a concept that has an intricately ambiguous relationship with <strong>end-to-end test</strong>, is the testing method that covers the end to end functionality of a unit. In simpler words, <strong>it tests the whole thing</strong>, from the end user of the system. It takes everything into consideration: network, device-specific quirks, UI, etc.</p>\\r\\n\\r\\n<p>An acceptance test case for our restaurnat will be <code>'Ordering a French toast from this restaurant gets a plate of French toast'</code>.</p>\\r\\n<h4 id=\"brief-recap\">Brief recap</h4>\\r\\n<p><img src=\"https://user-images.githubusercontent.com/43872616/87242261-97712a00-c45d-11ea-8681-72c727c851a1.png\" alt=\"unit-testing-world-with-french-toast\" style=\"zoom:33%;\"></p>\\r\\n\\r\\n<p>Let's look at this diagram again, and apply the concept to our <code>Restaurant</code>. Below are some example test cases we will write for each type of tests we just defined.</p>\\r\\n\\r\\n<ul>\\r\\n<li>\\r\\n<strong>[Unit test]</strong> <code>Cook#make_french_toast</code> with all ingredients returns a plate of French toast.</li>\\r\\n<li>\\r\\n<strong>[Integration test]</strong> <code>Cook#make_french_toast</code> returns a plate of French toast.</li>\\r\\n<li>\\r\\n<strong>[Acceptance test]</strong> When customer orders a French toast, they will be served a plate of French toast with fork and knife.</li>\\r\\n</ul>\\r\\n\\r\\n<p>We will dig deeper into the difference between our unit test case and integration test case, as you might think the two look like the same test.</p>\\r\\n<h3 id=\"the-testing-pyramid\">The testing pyramid</h3>\\r\\n<p><img src=\"https://user-images.githubusercontent.com/43872616/87244391-7dd8de00-c46f-11ea-8866-e6e125776cfa.png\" alt=\"testing-pyramid\" style=\"zoom:33%;\"></p>\\r\\n\\r\\n<p>Now, let's look at the three types of tests from another perspective: their roles in a codebase. The pyramid above is how you should distribute/use them for your code. </p>\\r\\n\\r\\n<p>At the bottom we have unit tests. Unit tests should take up the biggest proportion, as they (ideally cover every piece of code in every scenario (more on scenarios later), because they are the first and fundamental guard to make sure your code works.</p>\\r\\n\\r\\n<p>Acceptance and integration tests should be the fewest, for two main reasons. And all due to the reason that they use the SUT's real dependencies. First, <strong>it's painful to execute.</strong> Some acceptance tests are executed manually (hi QA engineers), as for integration tests, it requires extra setup to execute a test, database connections for a common example. Second, <strong>it's painful to debug.</strong> Using real dependencies means when a test fails, the root cause can be in anywhere of the dependencies web for the SUT. </p>\\r\\n\\r\\n<p>We should, therefore, not use acceptance tests and integration tests to catch any bugs that can be caught by unit tests. This is also why the pyramid has unit tests at the bottom. If we have a robust set of unit tests, we can be very efficient in debugging. Even if an acceptance test fails, we will have better navigation to the root cause since we don't have to inspect the components that our unit tests are already covering.</p>\\r\\n\\r\\n<p>With that said, we will focus on unit testing for the remainder of the series. In the next section, we will explore the three criteria for a good unit test and expand on each of them in the next article.</p>\\r\\n<h3 id=\"three-pillars-for-a-good-unit-test\">Three pillars for a good unit test</h3>\\r\\n<p>Here it comes, the fundamental question we need to answer: <strong>What is a good unit test?</strong></p>\\r\\n\\r\\n<p>There are many traits you can find that describe a good unit test. <a href=\"https://www.manning.com/books/the-art-of-unit-testing-second-edition\">The Art of Unit Testing by Roy Osherove</a>, the authoritative guide to unit testing, has itself about 10 items on its \"good test\" list. We will not attempt to iterate them in this article because (1) I only brought this up as a proof that <strong>to write a good unit test is hard</strong>, as there are many boxes it needs to check to be passed as \"good\" (2) no one is going to remember any of those 10+ criteria (3) I cannot remember them. What we'll do instead is to consolidate them into three guidelines. Yes, three short, sweet guidelines. If we follow those guidelines, our tests will check all the boxes and be good. Here they are.</p>\\r\\n\\r\\n<ul>\\r\\n<li>A good unit test is <strong>trustworthy</strong>.</li>\\r\\n<li>A good unit test is <strong>maintainable</strong>.</li>\\r\\n<li>A good unit test is <strong>readable</strong>.</li>\\r\\n</ul>\\r\\n\\r\\n<p>Huh? I can hear you say. Too general? Too vague? Guilty as charged. But don't leave just yet. Let's walk through one by one, and put them in the context of unit testing. By the end of this article, I hope you'll understand why I chose those three terms to be the pillars of a good test.</p>\\r\\n<h4 id=\"a-good-unit-test-is-trustworthy\">A good unit test is trustworthy</h4>\\r\\n<p>Being trustworthy is the <em>raison d'etre</em> of a test. We want to be confident that when the tests for a piece of code pass, that means the code <strong>really works</strong>, and works the way it's intended. On the other hand, we also want to be confident that when a test fails, it is <strong>exactly the SUT that fails to work</strong>, not anything else.</p>\\r\\n\\r\\n<p>Three topics need to be covered to accomplish the above two important goals:</p>\\r\\n\\r\\n<ul>\\r\\n<li>Definition of a unit</li>\\r\\n<li>Testing scenarios</li>\\r\\n<li>Test isolation</li>\\r\\n</ul>\\r\\n<h4 id=\"a-good-unit-test-is-maintainable\">A good unit test is maintainable</h4>\\r\\n<p>Maintainability is important in not just unit testing, but the whole software universe. In the scope of unit testing, though, there are some specific measures that we can leverage to achieve maintainability. These are:</p>\\r\\n\\r\\n<ul>\\r\\n<li>Testing one thing at a time</li>\\r\\n<li>Encapsulation</li>\\r\\n</ul>\\r\\n<h4 id=\"a-good-unit-test-is-readable\">A good unit test is readable</h4>\\r\\n<p>A unit test shouldn't content itself only with being trustworthy and maintainable, but it should have a bigger vision: documentation. Think about it, <strong>a robust set of unit tests covers every scenario for every unit that the code contains</strong>. In essence, the test cases are the SUTs' documentation, because they narrate how the SUTs should behave. </p>\\r\\n\\r\\n<p>Amazing, I know right.</p>\\r\\n\\r\\n<p>To make our unit tests into a source of documentation, we need to guarantee their readability. If we follow the best practice of the following two topics, readability can be achieved as easily as you can ever dream of.</p>\\r\\n\\r\\n<ul>\\r\\n<li>Test structure</li>\\r\\n<li>Naming</li>\\r\\n</ul>\\r\\n<h3 id=\"what-39-s-next\">What's next</h3>\\r\\n<p>In the next article, we will expand on the three criteria for a good unit test (trustworthiness, maintainability, readability), and see how they can applied to our restaurant. See you there!</p>\\r\\n",
        "status": 1,
        "description": "How to do testing right",
        "created_at": "2020-07-28T00:52:00.852277",
        "updated_at": "2020-11-14T10:14:33.307893",
        "slug": "unit-testing-overview",
        "medium_url": ""
    },
    {
        "id": 87,
        "title": "A Field Guide to Unit Testing: Readability",
        "body": "<hr>\\r\\n\\r\\n<p><strong>THE UNIT TESTING SERIES</strong></p>\\r\\n\\r\\n<blockquote>\\r\\n<ol>\\r\\n<li><a href=\"https://jennycodes.me/posts/unit-testing-overview\">A Field Guide to Unit Testing: Overview</a></li>\\r\\n<li>\\r\\n<a href=\"https://jennycodes.me/posts/unit-testing-trustworthiness\">A good test is trustworthy</a>\\r\\n\\r\\n<ul>\\r\\n<li>Test isolation (and what is dependency)</li>\\r\\n<li>Definition of a unit</li>\\r\\n<li>Testing scenarios</li>\\r\\n</ul>\\r\\n</li>\\r\\n<li>\\r\\n<a href=\"https://jennycodes.me/posts/unit-testing-maintainability\">A good test is maintainable</a>\\r\\n\\r\\n<ul>\\r\\n<li>Testing one thing at a time</li>\\r\\n<li>Use setup method, but use it wisely</li>\\r\\n</ul>\\r\\n</li>\\r\\n<li>\\r\\n<a href=\"https://jennycodes.me/posts/unit-testing-readability\">A good test is readable</a>\\r\\n\\r\\n<ul>\\r\\n<li>Test description</li>\\r\\n<li>Test pattern</li>\\r\\n</ul>\\r\\n</li>\\r\\n</ol>\\r\\n</blockquote>\\r\\n\\r\\n<hr>\\r\\n<h3 id=\"a-good-test-is-readable\">A good test is readable</h3>\\r\\n<p>Although it is one of the three important pillars in a unit test, readability usually gets less attention than it deserves. The situation is even more dismal in tests. Why do we care if a test looks pretty or not? You may wonder. Tests are not even production code, so it is good enough if does it job, right?</p>\\r\\n\\r\\n<p>Let's see a famous quote from Robert C. Martin:</p>\\r\\n\\r\\n<blockquote>\\r\\n<p>[The] ratio of time spent reading versus writing is well over 10 to 1. We are constantly reading old code as part of the effort to write new code. </p>\\r\\n</blockquote>\\r\\n\\r\\n<p>When we write code that is readable, we are doing everyone–including our future selves–a big, big favor.</p>\\r\\n\\r\\n<p>Coding is like writing, in many aspects. A good piece of writing has a clear, easy-to-follow narrative in a well-organized structure. It can even be elegant and enjoyable. Our goal for the code is the same. If a piece of code has high readability, it would not only greatly improve our mood, but also enhances maintainability.</p>\\r\\n<h3 id=\"test-as-documentation\">Test as documentation</h3>\\r\\n<p>Better yet, since tests are describing the behavior of the subject (and validating it) it is naturally a documentation. If we do it right, we can achieve \"test as documentation\"–creating documentation as we write tests. This \"documentation\" will be inherently valid and up-to-date because it <em>actually fails</em> if the production code isn't what it describes. What a bargain!</p>\\r\\n\\r\\n<p>So what do we do to make our tests readable, instead of a messy blob of code that no one dares/bothers to look at?</p>\\r\\n\\r\\n<p>Turns out, it's really quite easy. There are two patterns we can follow are instantly achievable yet very effective. The first is about <strong>test description</strong>, the second <strong>code arrangement</strong>.</p>\\r\\n<h3 id=\"test-description\">Test description</h3>\\r\\n<p>The purpose of a test's name/description is to describe what this test does. Duh. However, to make it readable, it does require some brain. Let's see an example first.</p>\\r\\n\\r\\n<p>In our <a href=\"TODO\">restaurant that only serves French toast</a>, the <code>Server</code> class has two functions: <code>take_order</code> and <code>serve</code>. We can name our test cases as below:</p>\\r\\n\\r\\n<pre><code class=\"lang-ruby\">it '#take_order' do\\r\\n  # ...\\r\\nend\\r\\n\\r\\nit '#serve' do\\r\\n  # ...\\r\\nend\\r\\n</code></pre>\\r\\n\\r\\n<p>That's often the case you see in the wild (including our own codebase at PicCollage :P). Well, what's wrong with it? Unmistakably, it tells us what the subject of this unit test is. The problem is that it is the only information it gives us. We don't know what behavior it is expected to have. How many scenarios are there? How does it handle errors? To get the answers, we will need to dive into the test code, and we can't even be sure that the answer will be there. </p>\\r\\n\\r\\n<p>Another problem that this kind of naming has is that it often violates the <a href=\"https://jennycodes.me/posts/unit-testing-maintainability#test-only-one-thing-at-a-time\">\"test one thing at a time\"</a> principle that we discussed in the last article. The fact is, naming a test case like this (with only the subject) not only introduces readability issues, but also makes the codes less maintainable.</p>\\r\\n<h3 id=\"the-quot-good-quot-way-of-naming-a-test\">The \"good\" way of naming a test</h3>\\r\\n<p>When we write a test name, our goal is to make it clear <em>what this subject is</em>, <em>what scenario we are testing</em>, and <em>what the expected result is</em>. If we somehow make the three elements into our test description, whoever that reads the tests will be able to understand the subject instantly, without having to be bothered with the technical details. Even people with no experience in the underlying technology can understand it, because a test description is plain English.</p>\\r\\n\\r\\n<p>A brief recap of the three elements:</p>\\r\\n\\r\\n<ul>\\r\\n<li>Subject</li>\\r\\n<li>Scenario</li>\\r\\n<li>Outcome</li>\\r\\n</ul>\\r\\n\\r\\n<p>And here is the format we can loosely follow</p>\\r\\n\\r\\n<pre><code>[subject]_[scenario]_[outcome]\\r\\n</code></pre>\\r\\n\\r\\n<p>Going back to our restaurant, we can have our tests for <code>Restaurant::Server</code> class written like this:</p>\\r\\n\\r\\n<pre><code class=\"lang-ruby\">#  [subject]    [scenario]                [outcome]    \\r\\nit '#take_order when dish is French toast passes the order to Cook' do\\r\\n  # ...\\r\\nend\\r\\n\\r\\n#  [subject]    [scenario]                    [outcome]    \\r\\nit '#take_order when dish is not French toast returns an error message' do\\r\\n  # ...\\r\\nend\\r\\n\\r\\n#  [subject][outcome]    \\r\\nit '#serve returns dish as a string' do\\r\\n  # ...\\r\\nend\\r\\n</code></pre>\\r\\n\\r\\n<p>Here we've made two adjustments:</p>\\r\\n\\r\\n<ol>\\r\\n<li>Separate the test for <code>#take_order</code> in two, because there are two scenarios for this subject.</li>\\r\\n<li>Include the subject, the scenario, the expected outcome in the description, instead of just the subject.</li>\\r\\n</ol>\\r\\n\\r\\n<p>🍰, right?</p>\\r\\n\\r\\n<p>If we zoom in on the third test, though, we'll find that the \"scenario\" part is missing.</p>\\r\\n\\r\\n<p>Why? Simply because we don't need it. Let's see the actual implementation:</p>\\r\\n\\r\\n<pre><code class=\"lang-ruby\">class Restaurant::Server\\r\\n  def serve(dish)\\r\\n    \"Serving delicious #{decorated_dish} yo!\"\\r\\n  end\\r\\nend\\r\\n</code></pre>\\r\\n\\r\\n<p>Given that, the test description <code>'#serve returns decorated dish as a string'</code> is self is clear and self-explanatory enough.</p>\\r\\n\\r\\n<p>I brought this up as a reminder that the <strong>Subject + Scenario + Outcome</strong> combo is just a guideline (and a really nice one), not a hard rule to obey. Our ultimate goal, we should all remember, is to make our tests as readable as they can be. That said, if you don't have a good reason to not follow this guideline, stick to it for now, and your teammates would all love you.</p>\\r\\n\\r\\n<p>So that took care of the first part of this article. Now here's another thing we can do to make our tests readable: follow a test pattern.</p>\\r\\n<h3 id=\"the-3a-test-pattern\">The 3A test pattern</h3>\\r\\n<p>There are three elements you can find in every test. They are conveniently named <strong>3A–Arrange, Act, Assert</strong>.</p>\\r\\n\\r\\n<p><strong>Arrange</strong> is where we set up the necessary environment for the subject under test to do its work.</p>\\r\\n\\r\\n<p><strong>Act</strong> is where the subject under test does its work.</p>\\r\\n\\r\\n<p><strong>Assert</strong> is where we validate the correctness of the result produced in Act.</p>\\r\\n\\r\\n<p>If we write our tests following this <strong>Arrange</strong> --&gt; <strong>Act</strong> --&gt; <strong>Assert</strong> order, the resulting code would be highly readable.</p>\\r\\n\\r\\n<p>Let us look at <code>Restaurant::Cook</code>'s <code>make_french_toast</code> method as an example.</p>\\r\\n\\r\\n<pre><code class=\"lang-ruby\">it '#make_french_toast with everything prepared returns French toast as string' do\\r\\n  # [Arrange]\\r\\n  # Make sure the subject is isolated from all its dependencies.\\r\\n  Restaurant::StorageRoom.stub(:get).with('egg') { 'egg' }\\r\\n  Restaurant::StorageRoom.stub(:get).with('bread') { 'bread' }\\r\\n\\r\\n  # [Act]\\r\\n  result = Restaurant::Cook.new.make_french_toast\\r\\n\\r\\n  # [Assert]\\r\\n  expect(result).to eq 'French toast is here. Ugh.'\\r\\n  end\\r\\nend\\r\\n</code></pre>\\r\\n\\r\\n<p>We don't necessarily have to insert the [Arrange], [Act], and [Assert] comments. My habit is to use an empty line to separate the three parts, like below:</p>\\r\\n\\r\\n<pre><code class=\"lang-ruby\">it '#make_french_toast with everything prepared returns French toast as string' do\\r\\n  Restaurant::StorageRoom.stub(:get).with('egg') { 'egg' }\\r\\n  Restaurant::StorageRoom.stub(:get).with('bread') { 'bread' }\\r\\n\\r\\n  result = Restaurant::Cook.new.make_french_toast\\r\\n\\r\\n  expect(result).to eq 'French toast is here. Ugh.'\\r\\n  end\\r\\nend\\r\\n</code></pre>\\r\\n\\r\\n<p>Another 🍰.</p>\\r\\n<h3 id=\"double-trouble-for-doubles\">Double trouble for doubles!</h3>\\r\\n<p>It's not happily ever after once we learn the <strong>Arrange</strong> -&gt; <strong>Act</strong> -&gt; <strong>Assert</strong> structure. Some frameworks, including our friend <a href=\"https://github.com/rspec/rspec\">RSpec</a>, does not syntactically allow us to follow this structure when dealing with mock objects. Let's see what that means:</p>\\r\\n\\r\\n<pre><code class=\"lang-ruby\"># Test for Restaurant::Server, using RSpec\\r\\ndescribe '#take_order' do\\r\\n  it 'when dish is French toast passes the order to Cook' do\\r\\n    # [Arrange and Assert]\\r\\n    server = Restaurant::Server.new\\r\\n    expect_any_instance_of(Restaurant::Cook).to receive(:make_french_toast)\\r\\n\\r\\n    # [Act]\\r\\n    server.take_order('French toast')\\r\\n  end\\r\\nend\\r\\n</code></pre>\\r\\n\\r\\n<p>In this example, the line</p>\\r\\n\\r\\n<pre><code class=\"lang-ruby\">expect_any_instance_of(Restaurant::Cook).to receive(:make_french_toast)\\r\\n</code></pre>\\r\\n\\r\\n<p>serves both as an arrangement (stubbing an external call) and an assertion (it is expected to be called). This is the 2-in-1 nature of mock objects, and frameworks like RSpec do not separate the two functions in the syntax, with reasons of conciseness I would guess.</p>\\r\\n\\r\\n<p>If we are not familiar enough with the concept of mocks, we will be surprised to see no assertions at the end of tests. Even worse, we might find ourselves (or others) unintentionally hiding assertions inside the tests because we can easily use throw mocks around as a setup and forget that they come with expectations.</p>\\r\\n\\r\\n<p>But the difference between stub objects and mock objects is another topic for another day. The question at hand is: Is there any way that we can fit the mock objects inside the <strong>Arrange</strong> -&gt; <strong>Act</strong> -&gt; <strong>Assert</strong> pattern?</p>\\r\\n<h3 id=\"yes-we-can\">Yes we can</h3>\\r\\n<p>Use another framework. Yup. RSpec is not the only Ruby test framework that we can use, you know. Another popular Ruby test framework, also the built-in framework in Rails, is <a href=\"https://github.com/seattlerb/minitest\">Minitest</a>. Minitest provides the mock syntax that we want: we can separate the stub function and the assertion function from a <code>Minitest::Mock</code> object. Let's see how we can rewrite the above test case with Minitest:</p>\\r\\n\\r\\n<pre><code class=\"lang-ruby\"># Test for Restaurant::Server, using Minitest\\r\\n\\r\\nrequire 'minitest'\\r\\nrequire 'minitest/mock'\\r\\n\\r\\ndescribe '#take_order' do\\r\\n  test 'when dish is French toast passes the order to Cook' do\\r\\n    # [Arrange]\\r\\n    server = Restaurant::Server.new\\r\\n    mock   = Minitest::Mock.new\\r\\n    mock.expect(:make_french_toast, nil) # second arg is return value, which is nil here.\\r\\n\\r\\n    Restaurant::Cook.stub(:new, mock) do\\r\\n        # [Act]\\r\\n      server.take_order('French toast')\\r\\n    end\\r\\n\\r\\n    # Assert\\r\\n    assert_mock mock\\r\\n  end\\r\\nend\\r\\n</code></pre>\\r\\n\\r\\n<p>See how it beautifully follows the pattern? The intention of this test has become much clearer here–we don't have to remember that the assertion actually lies in the setup section, we only have to look at the final line and know that it is testing the behavior (sending a correct outgoing message to another class).</p>\\r\\n\\r\\n<p>Admittedly, this is more verbose than the RSpec version. It sacrifices brevity for readability. But If you ask me, I say it's worth it. </p>\\r\\n<h3 id=\"that-39-s-it\">That's it</h3>\\r\\n<p>In this article, we have learned how to make our tests readable. First we looked at what a responsible test description looks like, and then we looked into the test structure to see how we can follow the 3A test pattern.</p>\\r\\n\\r\\n<p>This article also concludes the <strong>A field guide to unit testing</strong> series. If you have not read the previous articles, go read them (spoilers: they're good!) If you have read through all of them already, I'm impressed.</p>\\r\\n\\r\\n<p>As always, any feedback and/or questions is strongly encouraged/welcome. Reach out to me through this form: <a href=\"https://jennycodes.me/contact\">https://jennycodes.me/contact</a>. See you in the next article!</p>\\r\\n",
        "status": 1,
        "description": "Test as documentation!",
        "created_at": "2020-11-14T09:54:59.857812",
        "updated_at": "2020-11-14T11:50:28.565992",
        "slug": "unit-testing-readability",
        "medium_url": ""
    }
]
